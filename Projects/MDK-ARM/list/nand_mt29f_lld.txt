; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\nand_mt29f_lld.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\nand_mt29f_lld.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\nand_mt29f_lld.crf" ..\..\Src\core\nand_MT29F_lld.c]
                          THUMB

                          AREA ||i.DWT_Delay||, CODE, READONLY, ALIGN=2

                  DWT_Delay PROC
;;;308    
;;;309    void DWT_Delay(uint32_t us) // microseconds
000000  4907              LDR      r1,|L1.32|
;;;310    	{
000002  b510              PUSH     {r4,lr}
000004  684a              LDR      r2,[r1,#4]
;;;311    	int32_t tp = DWT_Get() + us * (SystemCoreClock / 1000000);
000006  4b07              LDR      r3,|L1.36|
000008  4c07              LDR      r4,|L1.40|
00000a  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
00000c  fbb3f3f4          UDIV     r3,r3,r4
000010  fb002003          MLA      r0,r0,r3,r2
                  |L1.20|
000014  684a              LDR      r2,[r1,#4]
000016  1a12              SUBS     r2,r2,r0
000018  0fd2              LSRS     r2,r2,#31
;;;312    	while( DWT_Compare(tp) );
00001a  d1fb              BNE      |L1.20|
;;;313    	}
00001c  bd10              POP      {r4,pc}
;;;314    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0xe0001000
                  |L1.36|
                          DCD      SystemCoreClock
                  |L1.40|
                          DCD      0x000f4240

                          AREA ||i.DWT_Get||, CODE, READONLY, ALIGN=2

                  DWT_Get PROC
;;;297    
;;;298    uint32_t DWT_Get(void)
000000  4801              LDR      r0,|L2.8|
;;;299    	{
;;;300    	return DWT->CYCCNT;
000002  6840              LDR      r0,[r0,#4]
;;;301    	}
000004  4770              BX       lr
;;;302    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0xe0001000

                          AREA ||i.DWT_Init||, CODE, READONLY, ALIGN=2

                  DWT_Init PROC
;;;287    
;;;288    void DWT_Init(void)
000000  4807              LDR      r0,|L3.32|
;;;289    	{
;;;290      if (!(CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk))
000002  6801              LDR      r1,[r0,#0]
000004  01c9              LSLS     r1,r1,#7
000006  d40a              BMI      |L3.30|
;;;291    		{
;;;292    		SCB_DEMCR  |= 0x01000000;
000008  6801              LDR      r1,[r0,#0]
00000a  f0417180          ORR      r1,r1,#0x1000000
00000e  6001              STR      r1,[r0,#0]
;;;293    		DWT_CYCCNT  = 0;
000010  4804              LDR      r0,|L3.36|
000012  2100              MOVS     r1,#0
000014  6041              STR      r1,[r0,#4]
;;;294    		DWT_CONTROL|= 1; // enable the counter
000016  6801              LDR      r1,[r0,#0]
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
                  |L3.30|
;;;295    		}
;;;296    	}
00001e  4770              BX       lr
;;;297    
                          ENDP

                  |L3.32|
                          DCD      0xe000edfc
                  |L3.36|
                          DCD      0xe0001000

                          AREA ||i.Init_Driver||, CODE, READONLY, ALIGN=2

                  Init_Driver PROC
;;;347    
;;;348    MT_uint8 Init_Driver(void)
000000  b538              PUSH     {r3-r5,lr}
;;;349    	{
;;;350    	flash_width onfi_signature[ONFI_SIGNATURE_LENGHT];
;;;351    
;;;352    	/* check if the driver is previously initialized */
;;;353    	if( DRIVER_STATUS_INITIALIZED == driver_status )
000002  4c0c              LDR      r4,|L4.52|
000004  7820              LDRB     r0,[r4,#0]  ; driver_status
000006  2800              CMP      r0,#0                 ;349
000008  d013              BEQ      |L4.50|
;;;354    		return DRIVER_STATUS_INITIALIZED;
;;;355    
;;;356    	/* initialize platform */
;;;357    	PLATFORM_Init();
00000a  f7fffffe          BL       PLATFORM_Init
;;;358    	/* reset at startup is mandatory */
;;;359    	NAND_Reset();
00000e  f7fffffe          BL       NAND_Reset
;;;360    	/* read if this device is ONFI complaint */
;;;361    	NAND_Read_ID_ONFI(onfi_signature);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       NAND_Read_ID_ONFI
;;;362    
;;;363    	//NAND_Read_ID(onfi_signature);
;;;364    
;;;365    	/* verify ONFI signature in the first field of parameter page */
;;;366    	if( strcmp((const char *)onfi_signature, "ONFI") && ( NAND_BAD_PARAMETER_PAGE != NAND_Read_Param_Page(&device_info)) )
000018  a107              ADR      r1,|L4.56|
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       strcmp
000020  b130              CBZ      r0,|L4.48|
000022  4807              LDR      r0,|L4.64|
000024  f7fffffe          BL       NAND_Read_Param_Page
000028  2820              CMP      r0,#0x20
00002a  d001              BEQ      |L4.48|
;;;367    		driver_status = DRIVER_STATUS_INITIALIZED;
00002c  2000              MOVS     r0,#0
00002e  7020              STRB     r0,[r4,#0]
                  |L4.48|
;;;368    
;;;369    	return driver_status;
000030  7820              LDRB     r0,[r4,#0]  ; driver_status
                  |L4.50|
;;;370    	}
000032  bd38              POP      {r3-r5,pc}
;;;371    
                          ENDP

                  |L4.52|
                          DCD      ||.data||
                  |L4.56|
000038  4f4e4649          DCB      "ONFI",0
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L4.64|
                          DCD      ||.bss||+0x38

                          AREA ||i.NAND_Block_Erase||, CODE, READONLY, ALIGN=2

                  NAND_Block_Erase PROC
;;;876    
;;;877    MT_uint8 NAND_Block_Erase(nand_addr_t addr)
000000  b5fe              PUSH     {r1-r7,lr}
;;;878    	{
000002  4604              MOV      r4,r0
;;;879    	MT_uint8 row_address[5];
;;;880    	MT_uint8 status_reg;
;;;881    	MT_uint8 ret;
;;;882    
;;;883    	/* verify if driver is initialized */
;;;884    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  481a              LDR      r0,|L5.112|
000006  460d              MOV      r5,r1                 ;878
000008  4616              MOV      r6,r2                 ;878
00000a  7800              LDRB     r0,[r0,#0]  ; driver_status
00000c  461f              MOV      r7,r3                 ;878
00000e  bb58              CBNZ     r0,|L5.104|
;;;885    		return DRIVER_STATUS_NOT_INITIALIZED;
;;;886    
;;;887    	/* check input parameters */
;;;888    	if(NAND_SUCCESS != __is_valid_addr(addr))
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       __is_valid_addr
000016  b108              CBZ      r0,|L5.28|
;;;889    		return NAND_INVALID_NAND_ADDRESS;
000018  2030              MOVS     r0,#0x30
                  |L5.26|
;;;890    
;;;891    	__build_cycle_addr(addr, row_address);
;;;892    
;;;893    	/* init board transfer */
;;;894    	PLATFORM_Open();
;;;895    
;;;896    	/* send command  */
;;;897    	PLATFORM_SendCmd(CMD_ERASE_BLOCK);
;;;898    
;;;899    	/* send row address (3rd, 4th, 5th cycle) */
;;;900    	PLATFORM_SendAddr(row_address[2]);
;;;901    	PLATFORM_SendAddr(row_address[3]);
;;;902    	PLATFORM_SendAddr(row_address[4]);
;;;903    
;;;904    	/* send confirm command */
;;;905    	PLATFORM_SendCmd(CMD_ERASE_BLOCK_CONFIRM);
;;;906    
;;;907    	/* wait */
;;;908    	PLATFORM_Wait(TIME_WB);
;;;909    	ret = __wait_for_ready();
;;;910    
;;;911    	/* return if timeout occurs */
;;;912    	if (NAND_SUCCESS != ret)
;;;913    		return ret;
;;;914    
;;;915    	status_reg = NAND_Read_Status();
;;;916    
;;;917    	/* close board transfer */
;;;918    	PLATFORM_Close();
;;;919    
;;;920    	/* check if erase is good */
;;;921    	if(!(status_reg & STATUS_WRITE_PROTECTED))
;;;922    		return NAND_ERASE_FAILED_WRITE_PROTECT;
;;;923    
;;;924    	if(status_reg & STATUS_FAIL)
;;;925    		return NAND_ERASE_FAILED;
;;;926    
;;;927    	if(status_reg & NAND_BAD_BLOCK)
;;;928    		return NAND_BAD_BLOCK;
;;;929    
;;;930    	return ret;
;;;931    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L5.28|
00001c  a801              ADD      r0,sp,#4              ;891
00001e  9000              STR      r0,[sp,#0]            ;891
000020  463b              MOV      r3,r7                 ;891
000022  4632              MOV      r2,r6                 ;891
000024  4629              MOV      r1,r5                 ;891
000026  4620              MOV      r0,r4                 ;891
000028  f7fffffe          BL       __build_cycle_addr
00002c  4911              LDR      r1,|L5.116|
00002e  2060              MOVS     r0,#0x60              ;897
000030  7008              STRB     r0,[r1,#0]            ;897
000032  4811              LDR      r0,|L5.120|
000034  f89d2006          LDRB     r2,[sp,#6]            ;900
000038  7002              STRB     r2,[r0,#0]            ;900
00003a  f89d2007          LDRB     r2,[sp,#7]            ;901
00003e  7002              STRB     r2,[r0,#0]            ;901
000040  f89d2008          LDRB     r2,[sp,#8]            ;902
000044  7002              STRB     r2,[r0,#0]            ;902
000046  20d0              MOVS     r0,#0xd0              ;905
000048  7008              STRB     r0,[r1,#0]            ;905
00004a  2064              MOVS     r0,#0x64              ;908
00004c  f7fffffe          BL       PLATFORM_Wait
000050  f7fffffe          BL       __wait_for_ready
000054  0004              MOVS     r4,r0                 ;909
000056  d1e0              BNE      |L5.26|
000058  f7fffffe          BL       NAND_Read_Status
00005c  0601              LSLS     r1,r0,#24             ;921
00005e  d401              BMI      |L5.100|
000060  2041              MOVS     r0,#0x41              ;922
000062  bdfe              POP      {r1-r7,pc}
                  |L5.100|
000064  07c0              LSLS     r0,r0,#31             ;927
000066  d001              BEQ      |L5.108|
                  |L5.104|
000068  2001              MOVS     r0,#1                 ;928
00006a  bdfe              POP      {r1-r7,pc}
                  |L5.108|
00006c  4620              MOV      r0,r4                 ;930
00006e  bdfe              POP      {r1-r7,pc}
;;;932    
                          ENDP

                  |L5.112|
                          DCD      ||.data||
                  |L5.116|
                          DCD      0x70010000
                  |L5.120|
                          DCD      0x70020000

                          AREA ||i.NAND_Cache_Program||, CODE, READONLY, ALIGN=1

                  NAND_Cache_Program PROC
;;;1533    */
;;;1534   MT_uint8 NAND_Cache_Program(void) {
000000  20ff              MOVS     r0,#0xff
;;;1535   
;;;1536   	/*
;;;1537   	 * TO BE IMPLEMENTED
;;;1538   	 *
;;;1539   	 * Please contact Micron support for any request
;;;1540   	 */
;;;1541   
;;;1542   	return NAND_UNIMPLEMENTED;
;;;1543   
;;;1544   }
000002  4770              BX       lr
;;;1545   
                          ENDP


                          AREA ||i.NAND_Cache_Read||, CODE, READONLY, ALIGN=1

                  NAND_Cache_Read PROC
;;;1518    */
;;;1519   MT_uint8 NAND_Cache_Read(void) {
000000  20ff              MOVS     r0,#0xff
;;;1520   
;;;1521   	/*
;;;1522   	 * TO BE IMPLEMENTED
;;;1523   	 *
;;;1524   	 * Please contact Micron support for any request
;;;1525   	 */
;;;1526   
;;;1527   	return NAND_UNIMPLEMENTED;
;;;1528   
;;;1529   }
000002  4770              BX       lr
;;;1530   
                          ENDP


                          AREA ||i.NAND_Copy_Back||, CODE, READONLY, ALIGN=2

                  NAND_Copy_Back PROC
;;;1397   
;;;1398   MT_uint8 NAND_Copy_Back(nand_addr_t src_addr, nand_addr_t dest_addr) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b089              SUB      sp,sp,#0x24
000006  ae17              ADD      r6,sp,#0x5c
;;;1399   	MT_uint8 src_address_stream[NUM_OF_ADDR_CYCLE];
;;;1400   	MT_uint8 dest_address_stream[NUM_OF_ADDR_CYCLE];
;;;1401   	MT_uint8 status_reg;
;;;1402   	MT_uint8 ret;
;;;1403   //	MT_uint32 k;
;;;1404   	int i;
;;;1405   
;;;1406   	/* verify if driver is initialized */
;;;1407   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000008  483e              LDR      r0,|L8.260|
00000a  e89600b0          LDM      r6,{r4,r5,r7}         ;1398
00000e  7800              LDRB     r0,[r0,#0]  ; driver_status
000010  f8dd9058          LDR      r9,[sp,#0x58]         ;1398
000014  468a              MOV      r10,r1                ;1398
000016  4693              MOV      r11,r2                ;1398
000018  4698              MOV      r8,r3                 ;1398
00001a  2800              CMP      r0,#0                 ;1398
00001c  d104              BNE      |L8.40|
;;;1408   		return driver_status;
;;;1409   
;;;1410   	/* check if this feature/command is supported */
;;;1411   	if ((device_info.command & OPTIONAL_CMD_COPYBACK) == 0)
00001e  4e3a              LDR      r6,|L8.264|
000020  7ab0              LDRB     r0,[r6,#0xa]  ; device_info
000022  06c0              LSLS     r0,r0,#27
000024  d403              BMI      |L8.46|
;;;1412   		return NAND_UNSUPPORTED;
000026  20fd              MOVS     r0,#0xfd
                  |L8.40|
;;;1413   
;;;1414   	/* check input parameters */
;;;1415   	if((NAND_SUCCESS != __is_valid_addr(src_addr)) || (NAND_SUCCESS != __is_valid_addr(dest_addr)))
;;;1416   		return NAND_INVALID_NAND_ADDRESS;
;;;1417   
;;;1418   	/* check if the source and destination address are the same */
;;;1419   	if(!__compare_addr(src_addr, dest_addr))
;;;1420   		return NAND_INVALID_NAND_ADDRESS;
;;;1421   
;;;1422   	/* check if odd to even copy back is supported */
;;;1423   	if ((device_info.command & SUPPORTED_ODD_TO_EVEN_PAGE_COPYBACK) == 0) {
;;;1424   		if(((src_addr.page & 1) != 0) && ((dest_addr.page & 1) == 0))
;;;1425   			return NAND_INVALID_NAND_ADDRESS;
;;;1426   		if(((src_addr.page & 1) == 0) && ((dest_addr.page & 1) != 0))
;;;1427   			return NAND_INVALID_NAND_ADDRESS;
;;;1428   	}
;;;1429   
;;;1430   	/* copy back allows to move data from one page to another on the same plane */
;;;1431   	if(((src_addr.block & 1) != 0) && ((dest_addr.block & 1) == 0))
;;;1432   		return NAND_INVALID_NAND_ADDRESS;
;;;1433   	if(((src_addr.block & 1) == 0) && ((dest_addr.block & 1) != 0))
;;;1434   		return NAND_INVALID_NAND_ADDRESS;
;;;1435   
;;;1436   	/* copy back is allowed only at the start of a page (ignoring column) */
;;;1437   	src_addr.column = 0;
;;;1438   	dest_addr.column = 0;
;;;1439   
;;;1440   	/* build address cycles for source and destination address */
;;;1441   	__build_cycle_addr(src_addr, src_address_stream);
;;;1442   	__build_cycle_addr(dest_addr, dest_address_stream);
;;;1443   
;;;1444   	/* init board transfer */
;;;1445   	PLATFORM_Open();
;;;1446   
;;;1447   	/* send command */
;;;1448   	PLATFORM_SendCmd(CMD_READ_MODE);
;;;1449   
;;;1450   	/* send source address */
;;;1451   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;1452   		PLATFORM_SendAddr(src_address_stream[i]);
;;;1453   
;;;1454   	/* read for internal data move */
;;;1455   
;;;1456   	/* send command */
;;;1457   	PLATFORM_SendCmd(CMD_READ_INTERNAL_DATA_MOVE);
;;;1458   
;;;1459       /* wait (see datasheet for details) */
;;;1460   	PLATFORM_Wait(TIME_WB);
;;;1461   	ret = __wait_for_ready();
;;;1462   
;;;1463       /* return if timeout */
;;;1464       if (NAND_SUCCESS != ret)
;;;1465       	return ret;
;;;1466   
;;;1467       /* program for internal data move */
;;;1468   
;;;1469   	/* send command */
;;;1470   	PLATFORM_SendCmd(CMD_PROGRAM_INTERNAL_DATA_MOVE);
;;;1471   
;;;1472   	/* send destination address */
;;;1473   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;1474   		PLATFORM_SendAddr(dest_address_stream[i]);
;;;1475   
;;;1476   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM_CONFIRM);
;;;1477   
;;;1478   	/* wait (see datasheet for details) */
;;;1479   	PLATFORM_Wait(TIME_WB);
;;;1480   	ret = __wait_for_ready();
;;;1481   
;;;1482       /* return if timeout */
;;;1483       if (NAND_SUCCESS != ret)
;;;1484       	return ret;
;;;1485   
;;;1486   	status_reg = NAND_Read_Status();
;;;1487   
;;;1488   	/* close board transfer */
;;;1489   	PLATFORM_Close();
;;;1490   
;;;1491   	/* check if program is good */
;;;1492   	if(!(status_reg & STATUS_WRITE_PROTECTED))
;;;1493   		return NAND_PROGRAM_FAILED_WRITE_PROTECT;
;;;1494   
;;;1495   	if(status_reg & STATUS_FAIL)
;;;1496   		return NAND_PROGRAM_FAILED;
;;;1497   
;;;1498   	return ret;
;;;1499   }
000028  b00d              ADD      sp,sp,#0x34
00002a  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.46|
00002e  9809              LDR      r0,[sp,#0x24]         ;1415
000030  f7fffffe          BL       __is_valid_addr
000034  bb28              CBNZ     r0,|L8.130|
000036  463b              MOV      r3,r7                 ;1415
000038  462a              MOV      r2,r5                 ;1415
00003a  4621              MOV      r1,r4                 ;1415
00003c  4648              MOV      r0,r9                 ;1415
00003e  f7fffffe          BL       __is_valid_addr
000042  b9f0              CBNZ     r0,|L8.130|
000044  a801              ADD      r0,sp,#4              ;1419
000046  f8cd9000          STR      r9,[sp,#0]            ;1419
00004a  e88000b0          STM      r0,{r4,r5,r7}         ;1419
00004e  4643              MOV      r3,r8                 ;1419
000050  465a              MOV      r2,r11                ;1419
000052  4651              MOV      r1,r10                ;1419
000054  9809              LDR      r0,[sp,#0x24]         ;1419
000056  f7fffffe          BL       __compare_addr
00005a  b190              CBZ      r0,|L8.130|
00005c  7ab0              LDRB     r0,[r6,#0xa]          ;1423  ; device_info
00005e  06c0              LSLS     r0,r0,#27             ;1423
000060  d407              BMI      |L8.114|
000062  ea5f70cb          LSLS     r0,r11,#31            ;1424
000066  ea4f70c5          LSL      r0,r5,#31             ;1426
00006a  d001              BEQ      |L8.112|
00006c  b148              CBZ      r0,|L8.130|
00006e  e000              B        |L8.114|
                  |L8.112|
000070  b938              CBNZ     r0,|L8.130|
                  |L8.114|
000072  ea5f70ca          LSLS     r0,r10,#31            ;1431
000076  ea4f70c4          LSL      r0,r4,#31             ;1433
00007a  d001              BEQ      |L8.128|
00007c  b108              CBZ      r0,|L8.130|
00007e  e002              B        |L8.134|
                  |L8.128|
000080  b108              CBZ      r0,|L8.134|
                  |L8.130|
000082  2030              MOVS     r0,#0x30              ;1434
000084  e7d0              B        |L8.40|
                  |L8.134|
000086  f04f0800          MOV      r8,#0                 ;1437
00008a  af04              ADD      r7,sp,#0x10           ;1441
00008c  4643              MOV      r3,r8                 ;1441
00008e  465a              MOV      r2,r11                ;1441
000090  4651              MOV      r1,r10                ;1441
000092  9700              STR      r7,[sp,#0]            ;1441
000094  9809              LDR      r0,[sp,#0x24]         ;1441
000096  f7fffffe          BL       __build_cycle_addr
00009a  ae06              ADD      r6,sp,#0x18           ;1442
00009c  4643              MOV      r3,r8                 ;1442
00009e  462a              MOV      r2,r5                 ;1442
0000a0  4621              MOV      r1,r4                 ;1442
0000a2  4648              MOV      r0,r9                 ;1442
0000a4  9600              STR      r6,[sp,#0]            ;1442
0000a6  f7fffffe          BL       __build_cycle_addr
0000aa  4c18              LDR      r4,|L8.268|
0000ac  f8848000          STRB     r8,[r4,#0]            ;1442
0000b0  4d17              LDR      r5,|L8.272|
0000b2  2000              MOVS     r0,#0                 ;1451
                  |L8.180|
0000b4  5c39              LDRB     r1,[r7,r0]            ;1452
0000b6  7029              STRB     r1,[r5,#0]            ;1452
0000b8  1c40              ADDS     r0,r0,#1              ;1452
0000ba  2805              CMP      r0,#5                 ;1451
0000bc  dbfa              BLT      |L8.180|
0000be  2035              MOVS     r0,#0x35              ;1457
0000c0  7020              STRB     r0,[r4,#0]            ;1457
0000c2  2064              MOVS     r0,#0x64              ;1460
0000c4  f7fffffe          BL       PLATFORM_Wait
0000c8  f7fffffe          BL       __wait_for_ready
0000cc  2800              CMP      r0,#0                 ;1464
0000ce  d1ab              BNE      |L8.40|
0000d0  2085              MOVS     r0,#0x85              ;1470
0000d2  7020              STRB     r0,[r4,#0]            ;1470
0000d4  2000              MOVS     r0,#0                 ;1473
                  |L8.214|
0000d6  5c31              LDRB     r1,[r6,r0]            ;1474
0000d8  7029              STRB     r1,[r5,#0]            ;1474
0000da  1c40              ADDS     r0,r0,#1              ;1474
0000dc  2805              CMP      r0,#5                 ;1473
0000de  dbfa              BLT      |L8.214|
0000e0  2010              MOVS     r0,#0x10              ;1476
0000e2  7020              STRB     r0,[r4,#0]            ;1476
0000e4  2064              MOVS     r0,#0x64              ;1479
0000e6  f7fffffe          BL       PLATFORM_Wait
0000ea  f7fffffe          BL       __wait_for_ready
0000ee  0004              MOVS     r4,r0                 ;1480
0000f0  d19a              BNE      |L8.40|
0000f2  f7fffffe          BL       NAND_Read_Status
0000f6  0600              LSLS     r0,r0,#24             ;1492
0000f8  d401              BMI      |L8.254|
0000fa  2051              MOVS     r0,#0x51              ;1493
0000fc  e794              B        |L8.40|
                  |L8.254|
0000fe  4620              MOV      r0,r4                 ;1498
000100  e792              B        |L8.40|
;;;1500   
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      ||.data||
                  |L8.264|
                          DCD      ||.bss||+0x38
                  |L8.268|
                          DCD      0x70010000
                  |L8.272|
                          DCD      0x70020000

                          AREA ||i.NAND_Get_Feature||, CODE, READONLY, ALIGN=2

                  NAND_Get_Feature PROC
;;;716    
;;;717    MT_uint8 NAND_Get_Feature(flash_width feature_address, flash_width *subfeature)
000000  b510              PUSH     {r4,lr}
;;;718    	{
000002  460c              MOV      r4,r1
;;;719    	flash_width ret;
;;;720    
;;;721    	/* verify if driver is initialized */
;;;722    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  490d              LDR      r1,|L9.60|
000006  7809              LDRB     r1,[r1,#0]  ; driver_status
000008  b109              CBZ      r1,|L9.14|
;;;723    		return DRIVER_STATUS_NOT_INITIALIZED;
00000a  2001              MOVS     r0,#1
;;;724    
;;;725    	/* check if this feature/command is supported */
;;;726    	if ((device_info.command & OPTIONAL_CMD_GET_FEATURES_AND_SET_FEATURES) == 0)
;;;727    		return NAND_UNSUPPORTED;
;;;728    
;;;729    	/* init board transfer */
;;;730    	PLATFORM_Open();
;;;731    
;;;732    	/* send command and/or address */
;;;733    	PLATFORM_SendCmd(CMD_GET_FEATURE);
;;;734    	PLATFORM_SendAddr(feature_address);
;;;735    
;;;736    	/* wait (see datasheet for details) */
;;;737    	PLATFORM_Wait(TIME_WB);
;;;738    	ret = __wait_for_ready();
;;;739    
;;;740    	/* return if timeout */
;;;741    	if (NAND_SUCCESS != ret)
;;;742    		return ret;
;;;743    
;;;744    	/* send sub-feature parameter */
;;;745    	*subfeature = PLATFORM_ReadData(); /* p0 */
;;;746    	/*
;;;747    	 * skip p1, p2 and p3 because they are reserved and their value are 00h
;;;748    	 */
;;;749    
;;;750    	/* close board transfer */
;;;751    	PLATFORM_Close();
;;;752    
;;;753    	return ret;
;;;754    	}
00000c  bd10              POP      {r4,pc}
                  |L9.14|
00000e  490c              LDR      r1,|L9.64|
000010  7a89              LDRB     r1,[r1,#0xa]          ;726  ; device_info
000012  0749              LSLS     r1,r1,#29             ;726
000014  d401              BMI      |L9.26|
000016  20fd              MOVS     r0,#0xfd              ;727
                  |L9.24|
000018  bd10              POP      {r4,pc}
                  |L9.26|
00001a  4a0a              LDR      r2,|L9.68|
00001c  21ee              MOVS     r1,#0xee              ;733
00001e  7011              STRB     r1,[r2,#0]            ;733
000020  4909              LDR      r1,|L9.72|
000022  7008              STRB     r0,[r1,#0]            ;733
000024  2064              MOVS     r0,#0x64              ;737
000026  f7fffffe          BL       PLATFORM_Wait
00002a  f7fffffe          BL       __wait_for_ready
00002e  2800              CMP      r0,#0                 ;741
000030  d1f2              BNE      |L9.24|
000032  f04f41e0          MOV      r1,#0x70000000        ;741
000036  7809              LDRB     r1,[r1,#0]            ;741
000038  7021              STRB     r1,[r4,#0]            ;745
00003a  bd10              POP      {r4,pc}
;;;755    
                          ENDP

                  |L9.60|
                          DCD      ||.data||
                  |L9.64|
                          DCD      ||.bss||+0x38
                  |L9.68|
                          DCD      0x70010000
                  |L9.72|
                          DCD      0x70020000

                          AREA ||i.NAND_Lock||, CODE, READONLY, ALIGN=2

                  NAND_Lock PROC
;;;1588   
;;;1589   MT_uint8 NAND_Lock(void) {
000000  4804              LDR      r0,|L10.20|
;;;1590   
;;;1591   	/* verify if driver is initialized */
;;;1592   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000002  7800              LDRB     r0,[r0,#0]  ; driver_status
000004  b108              CBZ      r0,|L10.10|
;;;1593   		return DRIVER_STATUS_NOT_INITIALIZED;
000006  2001              MOVS     r0,#1
;;;1594   
;;;1595   	/* init board transfer */
;;;1596   	PLATFORM_Open();
;;;1597   
;;;1598   	/* send command */
;;;1599   	PLATFORM_SendCmd(CMD_LOCK);
;;;1600   
;;;1601   	/* close board transfer */
;;;1602   	PLATFORM_Close();
;;;1603   
;;;1604   	return NAND_SUCCESS;
;;;1605   }
000008  4770              BX       lr
                  |L10.10|
00000a  4903              LDR      r1,|L10.24|
00000c  202a              MOVS     r0,#0x2a              ;1599
00000e  7008              STRB     r0,[r1,#0]            ;1599
000010  2000              MOVS     r0,#0                 ;1604
000012  4770              BX       lr
;;;1606   
                          ENDP

                  |L10.20|
                          DCD      ||.data||
                  |L10.24|
                          DCD      0x70010000

                          AREA ||i.NAND_Lock_Down||, CODE, READONLY, ALIGN=1

                  NAND_Lock_Down PROC
;;;1727    */
;;;1728   MT_uint8 NAND_Lock_Down(void) {
000000  20ff              MOVS     r0,#0xff
;;;1729   
;;;1730   	/*
;;;1731   	 * TO BE IMPLEMENTED
;;;1732   	 *
;;;1733   	 * Please contact Micron support for any request
;;;1734   	 */
;;;1735   
;;;1736   	return NAND_UNIMPLEMENTED;
;;;1737   
;;;1738   }
000002  4770              BX       lr
;;;1739   
                          ENDP


                          AREA ||i.NAND_Multiplane_Block_Erase||, CODE, READONLY, ALIGN=1

                  NAND_Multiplane_Block_Erase PROC
;;;1563    */
;;;1564   MT_uint8 NAND_Multiplane_Block_Erase(void) {
000000  20ff              MOVS     r0,#0xff
;;;1565   
;;;1566   	/*
;;;1567   	 * TO BE IMPLEMENTED
;;;1568   	 *
;;;1569   	 * Please contact Micron support for any request
;;;1570   	 */
;;;1571   
;;;1572   	return NAND_UNIMPLEMENTED;
;;;1573   
;;;1574   }
000002  4770              BX       lr
;;;1575   
                          ENDP


                          AREA ||i.NAND_Multiplane_Copy_Back||, CODE, READONLY, ALIGN=1

                  NAND_Multiplane_Copy_Back PROC
;;;1503    */
;;;1504   MT_uint8 NAND_Multiplane_Copy_Back(void) {
000000  20ff              MOVS     r0,#0xff
;;;1505   
;;;1506   	/*
;;;1507   	 * TO BE IMPLEMENTED
;;;1508   	 *
;;;1509   	 * Please contact Micron support for any request
;;;1510   	 */
;;;1511   
;;;1512   	return NAND_UNIMPLEMENTED;
;;;1513   
;;;1514   }
000002  4770              BX       lr
;;;1515   
                          ENDP


                          AREA ||i.NAND_Multiplane_Page_Program||, CODE, READONLY, ALIGN=1

                  NAND_Multiplane_Page_Program PROC
;;;1548    */
;;;1549   MT_uint8 NAND_Multiplane_Page_Program(void) {
000000  20ff              MOVS     r0,#0xff
;;;1550   
;;;1551   	/*
;;;1552   	 * TO BE IMPLEMENTED
;;;1553   	 *
;;;1554   	 * Please contact Micron support for any request
;;;1555   	 */
;;;1556   
;;;1557   	return NAND_UNIMPLEMENTED;
;;;1558   
;;;1559   }
000002  4770              BX       lr
;;;1560   
                          ENDP


                          AREA ||i.NAND_OTP_Mode_Enter||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Mode_Enter PROC
;;;1777    */
;;;1778   MT_uint8 NAND_OTP_Mode_Enter(void) {
000000  4811              LDR      r0,|L15.72|
000002  b508              PUSH     {r3,lr}
;;;1779   	MT_uint8 ret;
;;;1780   	flash_width subfeature;
;;;1781   
;;;1782   	/* check if driver is in a valid state */
;;;1783   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  7800              LDRB     r0,[r0,#0]  ; driver_status
000006  b108              CBZ      r0,|L15.12|
;;;1784   		return DRIVER_STATUS_NOT_INITIALIZED;
000008  2001              MOVS     r0,#1
                  |L15.10|
;;;1785   
;;;1786   	/* check if device is NOT in OTP status */
;;;1787   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1788   
;;;1789   	if((FEATURE_ARRAY_NORMAL != subfeature) && (FEATURE_ARRAY_OTP_PROTECTION != subfeature))
;;;1790   		return NAND_GENERIC_FAIL;
;;;1791   
;;;1792   	/* set OTP status */
;;;1793   	ret = NAND_Set_Feature(ADDR_FEATURE_ARRAY_OPMODE, FEATURE_ARRAY_OTP_OPERATION);
;;;1794   
;;;1795   	/* return with error if a fail occurs */
;;;1796   	if(NAND_SUCCESS != ret)
;;;1797   		return ret;
;;;1798   
;;;1799   	/* check if device is in OTP status */
;;;1800   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1801   
;;;1802   	/* return with error if a fail occurs */
;;;1803   	if(NAND_SUCCESS != ret)
;;;1804   		return ret;
;;;1805   
;;;1806   	if(FEATURE_ARRAY_OTP_OPERATION != subfeature)
;;;1807   		return NAND_GENERIC_FAIL;
;;;1808   
;;;1809   	return NAND_SUCCESS;
;;;1810   }
00000a  bd08              POP      {r3,pc}
                  |L15.12|
00000c  4669              MOV      r1,sp                 ;1787
00000e  2090              MOVS     r0,#0x90              ;1787
000010  f7fffffe          BL       NAND_Get_Feature
000014  f89d0000          LDRB     r0,[sp,#0]            ;1789
000018  b108              CBZ      r0,|L15.30|
00001a  2803              CMP      r0,#3                 ;1789
00001c  d10f              BNE      |L15.62|
                  |L15.30|
00001e  2101              MOVS     r1,#1                 ;1793
000020  2090              MOVS     r0,#0x90              ;1793
000022  f7fffffe          BL       NAND_Set_Feature
000026  2800              CMP      r0,#0                 ;1796
000028  d1ef              BNE      |L15.10|
00002a  4669              MOV      r1,sp                 ;1800
00002c  2090              MOVS     r0,#0x90              ;1800
00002e  f7fffffe          BL       NAND_Get_Feature
000032  2800              CMP      r0,#0                 ;1803
000034  d1e9              BNE      |L15.10|
000036  f89d0000          LDRB     r0,[sp,#0]            ;1806
00003a  2801              CMP      r0,#1                 ;1806
00003c  d001              BEQ      |L15.66|
                  |L15.62|
00003e  2010              MOVS     r0,#0x10              ;1807
000040  bd08              POP      {r3,pc}
                  |L15.66|
000042  2000              MOVS     r0,#0                 ;1809
000044  bd08              POP      {r3,pc}
;;;1811   
                          ENDP

000046  0000              DCW      0x0000
                  |L15.72|
                          DCD      ||.data||

                          AREA ||i.NAND_OTP_Mode_Exit||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Mode_Exit PROC
;;;1825    */
;;;1826   MT_uint8 NAND_OTP_Mode_Exit(void) {
000000  4810              LDR      r0,|L16.68|
000002  b508              PUSH     {r3,lr}
;;;1827   	MT_uint8 ret;
;;;1828   	flash_width subfeature;
;;;1829   
;;;1830   	/* check if driver is in a valid state */
;;;1831   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  7800              LDRB     r0,[r0,#0]  ; driver_status
000006  b108              CBZ      r0,|L16.12|
;;;1832   		return DRIVER_STATUS_NOT_INITIALIZED;
000008  2001              MOVS     r0,#1
                  |L16.10|
;;;1833   
;;;1834   	/* check if device is NOT in normal status */
;;;1835   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1836   
;;;1837   	if((FEATURE_ARRAY_OTP_OPERATION != subfeature) && (FEATURE_ARRAY_OTP_PROTECTION != subfeature))
;;;1838   		return NAND_GENERIC_FAIL;
;;;1839   
;;;1840   	/* exit OTP status */
;;;1841   	ret = NAND_Set_Feature(ADDR_FEATURE_ARRAY_OPMODE, FEATURE_ARRAY_NORMAL);
;;;1842   
;;;1843   	/* return with error if a fail occurs */
;;;1844   	if(NAND_SUCCESS != ret)
;;;1845   		return ret;
;;;1846   
;;;1847   	/* check if device is in normal status */
;;;1848   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1849   
;;;1850   	/* return with error if a fail occurs */
;;;1851   	if(NAND_SUCCESS != ret)
;;;1852   		return ret;
;;;1853   
;;;1854   	if(FEATURE_ARRAY_NORMAL != subfeature)
;;;1855   		return NAND_GENERIC_FAIL;
;;;1856   
;;;1857   	return NAND_SUCCESS;
;;;1858   }
00000a  bd08              POP      {r3,pc}
                  |L16.12|
00000c  4669              MOV      r1,sp                 ;1835
00000e  2090              MOVS     r0,#0x90              ;1835
000010  f7fffffe          BL       NAND_Get_Feature
000014  f89d0000          LDRB     r0,[sp,#0]            ;1837
000018  2801              CMP      r0,#1                 ;1837
00001a  d001              BEQ      |L16.32|
00001c  2803              CMP      r0,#3                 ;1837
00001e  d10f              BNE      |L16.64|
                  |L16.32|
000020  2100              MOVS     r1,#0                 ;1841
000022  2090              MOVS     r0,#0x90              ;1841
000024  f7fffffe          BL       NAND_Set_Feature
000028  2800              CMP      r0,#0                 ;1844
00002a  d1ee              BNE      |L16.10|
00002c  4669              MOV      r1,sp                 ;1848
00002e  2090              MOVS     r0,#0x90              ;1848
000030  f7fffffe          BL       NAND_Get_Feature
000034  2800              CMP      r0,#0                 ;1851
000036  d1e8              BNE      |L16.10|
000038  f89d0000          LDRB     r0,[sp,#0]            ;1854
00003c  2800              CMP      r0,#0                 ;1854
00003e  d0e4              BEQ      |L16.10|
                  |L16.64|
000040  2010              MOVS     r0,#0x10              ;1855
000042  bd08              POP      {r3,pc}
;;;1859   
                          ENDP

                  |L16.68|
                          DCD      ||.data||

                          AREA ||i.NAND_OTP_Mode_Protect||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Mode_Protect PROC
;;;1959    */
;;;1960   MT_uint8 NAND_OTP_Mode_Protect(nand_addr_t addr) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
;;;1961   	MT_uint8 ret;
;;;1962   	flash_width subfeature;
;;;1963   	flash_width write_buf[4096+224];
;;;1964   
;;;1965   	/* check if driver is in a valid state */
;;;1966   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000006  4821              LDR      r0,|L17.140|
000008  f5ad5d88          SUB      sp,sp,#0x1100         ;1960
00000c  460c              MOV      r4,r1                 ;1960
00000e  7800              LDRB     r0,[r0,#0]  ; driver_status
000010  4615              MOV      r5,r2                 ;1960
000012  4698              MOV      r8,r3                 ;1960
000014  b120              CBZ      r0,|L17.32|
;;;1967   		return DRIVER_STATUS_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L17.24|
;;;1968   
;;;1969   	/* check if device is NOT in normal status */
;;;1970   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1971   
;;;1972   	if(FEATURE_ARRAY_OTP_OPERATION != subfeature)
;;;1973   		return NAND_GENERIC_FAIL;
;;;1974   
;;;1975   	/* issue protect OTP area command */
;;;1976   	ret = NAND_Set_Feature(ADDR_FEATURE_ARRAY_OPMODE, FEATURE_ARRAY_OTP_PROTECTION);
;;;1977   
;;;1978   	/* return with error if a fail occurs */
;;;1979   	if(NAND_SUCCESS != ret)
;;;1980   		return ret;
;;;1981   
;;;1982   	/* check if device is in normal status */
;;;1983   	ret = NAND_Get_Feature(ADDR_FEATURE_ARRAY_OPMODE, &subfeature);
;;;1984   
;;;1985   	/* return with error if a fail occurs */
;;;1986   	if(NAND_SUCCESS != ret)
;;;1987   		return ret;
;;;1988   
;;;1989   	if(FEATURE_ARRAY_OTP_PROTECTION != subfeature)
;;;1990   		return NAND_GENERIC_FAIL;
;;;1991   
;;;1992   	/* issue the PROGRAM command to lock permanently the page */
;;;1993   
;;;1994   	/* data buffer is filled with 0x00 */
;;;1995   	memset(write_buf, 0x00, device_info.data_bytes_per_page);
;;;1996   
;;;1997   	/* x8 */
;;;1998   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) == 0)
;;;1999   		ret = NAND_OTP_Page_Program(addr, write_buf, device_info.data_bytes_per_page);
;;;2000   	/* x16 */
;;;2001   	else
;;;2002   		ret = NAND_OTP_Page_Program(addr, write_buf, (device_info.data_bytes_per_page>>2));
;;;2003   
;;;2004   	if(NAND_SUCCESS != ret) {
;;;2005   		/* in case of program error, exit in OTP mode */
;;;2006   		NAND_OTP_Mode_Enter();
;;;2007   		return NAND_GENERIC_FAIL;
;;;2008   	}
;;;2009   
;;;2010   	/* restore OTP mode before return */
;;;2011   	ret = NAND_OTP_Mode_Enter();
;;;2012   
;;;2013   	if(NAND_SUCCESS != ret)
;;;2014   		return NAND_GENERIC_FAIL;
;;;2015   
;;;2016   	return NAND_SUCCESS;
;;;2017   }
000018  f50d5d88          ADD      sp,sp,#0x1100
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L17.32|
000020  ae02              ADD      r6,sp,#8              ;1970
000022  4631              MOV      r1,r6                 ;1970
000024  2090              MOVS     r0,#0x90              ;1970
000026  f7fffffe          BL       NAND_Get_Feature
00002a  f89d0008          LDRB     r0,[sp,#8]            ;1972
00002e  2801              CMP      r0,#1                 ;1972
000030  d12a              BNE      |L17.136|
000032  2103              MOVS     r1,#3                 ;1976
000034  2090              MOVS     r0,#0x90              ;1976
000036  f7fffffe          BL       NAND_Set_Feature
00003a  2800              CMP      r0,#0                 ;1979
00003c  d1ec              BNE      |L17.24|
00003e  4631              MOV      r1,r6                 ;1983
000040  2090              MOVS     r0,#0x90              ;1983
000042  f7fffffe          BL       NAND_Get_Feature
000046  2800              CMP      r0,#0                 ;1986
000048  d1e6              BNE      |L17.24|
00004a  f89d0008          LDRB     r0,[sp,#8]            ;1989
00004e  2803              CMP      r0,#3                 ;1989
000050  d11a              BNE      |L17.136|
000052  4e0f              LDR      r6,|L17.144|
000054  af03              ADD      r7,sp,#0xc            ;1995
000056  4638              MOV      r0,r7                 ;1995
000058  6b71              LDR      r1,[r6,#0x34]         ;1995  ; device_info
00005a  f7fffffe          BL       __aeabi_memclr4
00005e  7a30              LDRB     r0,[r6,#8]            ;1998  ; device_info
000060  07c0              LSLS     r0,r0,#31             ;1998
000062  6b70              LDR      r0,[r6,#0x34]         ;1998  ; device_info
000064  d000              BEQ      |L17.104|
000066  0880              LSRS     r0,r0,#2              ;2002
                  |L17.104|
000068  e9cd7000          STRD     r7,r0,[sp,#0]         ;2002
00006c  4643              MOV      r3,r8                 ;2002
00006e  462a              MOV      r2,r5                 ;2002
000070  4621              MOV      r1,r4                 ;2002
000072  4648              MOV      r0,r9                 ;2002
000074  f7fffffe          BL       NAND_OTP_Page_Program
000078  b110              CBZ      r0,|L17.128|
00007a  f7fffffe          BL       NAND_OTP_Mode_Enter
00007e  e003              B        |L17.136|
                  |L17.128|
000080  f7fffffe          BL       NAND_OTP_Mode_Enter
000084  2800              CMP      r0,#0                 ;2013
000086  d0c7              BEQ      |L17.24|
                  |L17.136|
000088  2010              MOVS     r0,#0x10              ;2014
00008a  e7c5              B        |L17.24|
;;;2018   
                          ENDP

                  |L17.140|
                          DCD      ||.data||
                  |L17.144|
                          DCD      ||.bss||+0x38

                          AREA ||i.NAND_OTP_Page_Program||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Page_Program PROC
;;;1888   
;;;1889   MT_uint8 NAND_OTP_Page_Program(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4607              MOV      r7,r0
;;;1890   	MT_uint8 address[5];
;;;1891   	MT_uint8 status_reg;
;;;1892   	MT_uint32 k;
;;;1893   	int i;
;;;1894   
;;;1895   	/* verify if driver is initialized */
;;;1896   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000006  481f              LDR      r0,|L18.132|
000008  e9dd540c          LDRD     r5,r4,[sp,#0x30]      ;1889
00000c  7800              LDRB     r0,[r0,#0]  ; driver_status
00000e  4688              MOV      r8,r1                 ;1889
000010  4691              MOV      r9,r2                 ;1889
000012  469a              MOV      r10,r3                ;1889
000014  b110              CBZ      r0,|L18.28|
;;;1897   		return DRIVER_STATUS_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L18.24|
;;;1898   
;;;1899   	/* check input parameters */
;;;1900   	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;1901   		return NAND_INVALID_NAND_ADDRESS;
;;;1902   
;;;1903   	/* x16 */
;;;1904   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0) {
;;;1905   		if(lenght > (device_info.data_bytes_per_page >> 1) )
;;;1906   			return NAND_INVALID_LENGHT;
;;;1907   	}
;;;1908   
;;;1909   	/* x8 */
;;;1910   	if(lenght > device_info.data_bytes_per_page)
;;;1911   		return NAND_INVALID_LENGHT;
;;;1912   
;;;1913   	__build_cycle_addr(addr, address);
;;;1914   
;;;1915   	/* init board transfer */
;;;1916   	PLATFORM_Open();
;;;1917   
;;;1918   	/* send command */
;;;1919   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM);
;;;1920   
;;;1921   	/* send address */
;;;1922   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;1923   		PLATFORM_SendAddr(address[i]);
;;;1924   
;;;1925   	/* send data */
;;;1926   	for(k=0; k<lenght; k++)
;;;1927   		PLATFORM_SendData(buffer[k]);
;;;1928   
;;;1929   	/* send command */
;;;1930   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM_CONFIRM);
;;;1931   
;;;1932   	status_reg = NAND_Read_Status();
;;;1933   
;;;1934   	/* close board transfer */
;;;1935   	PLATFORM_Close();
;;;1936   	
;;;1937   	if(status_reg & STATUS_FAIL)
;;;1938   		return NAND_PROGRAM_FAILED;
;;;1939   
;;;1940   	return NAND_SUCCESS;
;;;1941   }
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L18.28|
00001c  4638              MOV      r0,r7                 ;1900
00001e  f7fffffe          BL       __is_valid_addr
000022  b108              CBZ      r0,|L18.40|
000024  2030              MOVS     r0,#0x30              ;1901
000026  e7f7              B        |L18.24|
                  |L18.40|
000028  4817              LDR      r0,|L18.136|
00002a  7a01              LDRB     r1,[r0,#8]            ;1904  ; device_info
00002c  07c9              LSLS     r1,r1,#31             ;1904
00002e  d003              BEQ      |L18.56|
000030  6b41              LDR      r1,[r0,#0x34]         ;1905  ; device_info
000032  ebb40f51          CMP      r4,r1,LSR #1          ;1905
000036  d802              BHI      |L18.62|
                  |L18.56|
000038  6b40              LDR      r0,[r0,#0x34]         ;1910  ; device_info
00003a  42a0              CMP      r0,r4                 ;1910
00003c  d201              BCS      |L18.66|
                  |L18.62|
00003e  2031              MOVS     r0,#0x31              ;1911
000040  e7ea              B        |L18.24|
                  |L18.66|
000042  ae01              ADD      r6,sp,#4              ;1913
000044  4653              MOV      r3,r10                ;1913
000046  464a              MOV      r2,r9                 ;1913
000048  4641              MOV      r1,r8                 ;1913
00004a  4638              MOV      r0,r7                 ;1913
00004c  9600              STR      r6,[sp,#0]            ;1913
00004e  f7fffffe          BL       __build_cycle_addr
000052  490e              LDR      r1,|L18.140|
000054  2080              MOVS     r0,#0x80              ;1919
000056  7008              STRB     r0,[r1,#0]            ;1919
000058  4b0d              LDR      r3,|L18.144|
00005a  2000              MOVS     r0,#0                 ;1922
                  |L18.92|
00005c  5c32              LDRB     r2,[r6,r0]            ;1923
00005e  701a              STRB     r2,[r3,#0]            ;1923
000060  1c40              ADDS     r0,r0,#1              ;1923
000062  2805              CMP      r0,#5                 ;1922
000064  dbfa              BLT      |L18.92|
000066  2000              MOVS     r0,#0                 ;1926
000068  f04f43e0          MOV      r3,#0x70000000        ;1926
00006c  e002              B        |L18.116|
                  |L18.110|
00006e  5c2a              LDRB     r2,[r5,r0]            ;1927
000070  701a              STRB     r2,[r3,#0]            ;1927
000072  1c40              ADDS     r0,r0,#1              ;1927
                  |L18.116|
000074  42a0              CMP      r0,r4                 ;1926
000076  d3fa              BCC      |L18.110|
000078  2010              MOVS     r0,#0x10              ;1930
00007a  7008              STRB     r0,[r1,#0]            ;1930
00007c  f7fffffe          BL       NAND_Read_Status
000080  2000              MOVS     r0,#0                 ;1940
000082  e7c9              B        |L18.24|
;;;1942   
                          ENDP

                  |L18.132|
                          DCD      ||.data||
                  |L18.136|
                          DCD      ||.bss||+0x38
                  |L18.140|
                          DCD      0x70010000
                  |L18.144|
                          DCD      0x70020000

                          AREA ||i.NAND_OTP_Page_Read||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Page_Read PROC
;;;2136   
;;;2137   MT_uint8 NAND_OTP_Page_Read(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4607              MOV      r7,r0
;;;2138   	MT_uint8 row_address[5];
;;;2139   	MT_uint8 status_reg;
;;;2140   	MT_uint8 ret;
;;;2141   	int i;
;;;2142   
;;;2143   	/* verify if driver is initialized */
;;;2144   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000006  4821              LDR      r0,|L19.140|
000008  e9dd540c          LDRD     r5,r4,[sp,#0x30]      ;2137
00000c  7800              LDRB     r0,[r0,#0]  ; driver_status
00000e  4688              MOV      r8,r1                 ;2137
000010  4691              MOV      r9,r2                 ;2137
000012  469a              MOV      r10,r3                ;2137
000014  b110              CBZ      r0,|L19.28|
;;;2145   		return DRIVER_STATUS_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L19.24|
;;;2146   
;;;2147   	/* check input parameters */
;;;2148   	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;2149   		return NAND_INVALID_NAND_ADDRESS;
;;;2150   
;;;2151   	/* x16 */
;;;2152   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0) {
;;;2153   		if(lenght > (device_info.data_bytes_per_page >> 1) )
;;;2154   			return NAND_INVALID_LENGHT;
;;;2155   	}
;;;2156   
;;;2157   	/* x8 */
;;;2158   	if(lenght > device_info.data_bytes_per_page)
;;;2159   		return NAND_INVALID_LENGHT;
;;;2160   
;;;2161   	__build_cycle_addr(addr, row_address);
;;;2162   
;;;2163   	/* init board transfer */
;;;2164   	PLATFORM_Open();
;;;2165   
;;;2166   	/* send command  */
;;;2167   	PLATFORM_SendCmd(CMD_READ_MODE);
;;;2168   
;;;2169   	/* send address */
;;;2170   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;2171   		PLATFORM_SendAddr(row_address[i]);
;;;2172   
;;;2173   	/* return to read mode */
;;;2174   	PLATFORM_SendCmd(CMD_READ_CONFIRM);
;;;2175   
;;;2176   	/* wait */
;;;2177   	ret = __wait_for_ready();
;;;2178   
;;;2179       /* return if timeout */
;;;2180       if (NAND_SUCCESS != ret)
;;;2181       	return ret;
;;;2182   
;;;2183   	/* read data */
;;;2184   	for(i=0; i<lenght; i++)
;;;2185   		buffer[i] = PLATFORM_ReadData();
;;;2186   
;;;2187   	/* read status register on exit */
;;;2188   	status_reg = NAND_Read_Status();
;;;2189   
;;;2190   	/* close board transfer */
;;;2191   	PLATFORM_Close();
;;;2192   
;;;2193   	if(status_reg & STATUS_FAIL)
;;;2194   		return NAND_READ_FAILED;
;;;2195   
;;;2196   	return ret;
;;;2197   }
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L19.28|
00001c  4638              MOV      r0,r7                 ;2148
00001e  f7fffffe          BL       __is_valid_addr
000022  b108              CBZ      r0,|L19.40|
000024  2030              MOVS     r0,#0x30              ;2149
000026  e7f7              B        |L19.24|
                  |L19.40|
000028  4819              LDR      r0,|L19.144|
00002a  7a01              LDRB     r1,[r0,#8]            ;2152  ; device_info
00002c  07c9              LSLS     r1,r1,#31             ;2152
00002e  d003              BEQ      |L19.56|
000030  6b41              LDR      r1,[r0,#0x34]         ;2153  ; device_info
000032  ebb40f51          CMP      r4,r1,LSR #1          ;2153
000036  d802              BHI      |L19.62|
                  |L19.56|
000038  6b40              LDR      r0,[r0,#0x34]         ;2158  ; device_info
00003a  42a0              CMP      r0,r4                 ;2158
00003c  d201              BCS      |L19.66|
                  |L19.62|
00003e  2031              MOVS     r0,#0x31              ;2159
000040  e7ea              B        |L19.24|
                  |L19.66|
000042  ae01              ADD      r6,sp,#4              ;2161
000044  4653              MOV      r3,r10                ;2161
000046  464a              MOV      r2,r9                 ;2161
000048  4641              MOV      r1,r8                 ;2161
00004a  4638              MOV      r0,r7                 ;2161
00004c  9600              STR      r6,[sp,#0]            ;2161
00004e  f7fffffe          BL       __build_cycle_addr
000052  4910              LDR      r1,|L19.148|
000054  2000              MOVS     r0,#0                 ;2167
000056  7008              STRB     r0,[r1,#0]            ;2167
000058  4b0f              LDR      r3,|L19.152|
                  |L19.90|
00005a  5c32              LDRB     r2,[r6,r0]            ;2171
00005c  701a              STRB     r2,[r3,#0]            ;2171
00005e  1c40              ADDS     r0,r0,#1              ;2171
000060  2805              CMP      r0,#5                 ;2170
000062  dbfa              BLT      |L19.90|
000064  2030              MOVS     r0,#0x30              ;2174
000066  7008              STRB     r0,[r1,#0]            ;2174
000068  f7fffffe          BL       __wait_for_ready
00006c  0006              MOVS     r6,r0                 ;2177
00006e  d1d3              BNE      |L19.24|
000070  2100              MOVS     r1,#0                 ;2184
000072  f04f42e0          MOV      r2,#0x70000000        ;2184
000076  e002              B        |L19.126|
                  |L19.120|
000078  7810              LDRB     r0,[r2,#0]            ;2184
00007a  5468              STRB     r0,[r5,r1]            ;2185
00007c  1c49              ADDS     r1,r1,#1              ;2185
                  |L19.126|
00007e  42a1              CMP      r1,r4                 ;2184
000080  d3fa              BCC      |L19.120|
000082  f7fffffe          BL       NAND_Read_Status
000086  4630              MOV      r0,r6                 ;2196
000088  e7c6              B        |L19.24|
;;;2198   
                          ENDP

00008a  0000              DCW      0x0000
                  |L19.140|
                          DCD      ||.data||
                  |L19.144|
                          DCD      ||.bss||+0x38
                  |L19.148|
                          DCD      0x70010000
                  |L19.152|
                          DCD      0x70020000

                          AREA ||i.NAND_OTP_Spare_Program||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Spare_Program PROC
;;;2046   
;;;2047   MT_uint8 NAND_OTP_Spare_Program(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4607              MOV      r7,r0
;;;2048   	MT_uint8 address[5];
;;;2049   	MT_uint8 status_reg;
;;;2050   	MT_uint32 k;
;;;2051   	int i;
;;;2052   
;;;2053   	/* verify if driver is initialized */
;;;2054   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000006  4821              LDR      r0,|L20.140|
000008  e9dd540a          LDRD     r5,r4,[sp,#0x28]      ;2047
00000c  7800              LDRB     r0,[r0,#0]  ; driver_status
00000e  4688              MOV      r8,r1                 ;2047
000010  4691              MOV      r9,r2                 ;2047
000012  b110              CBZ      r0,|L20.26|
;;;2055   		return DRIVER_STATUS_NOT_INITIALIZED;
000014  2001              MOVS     r0,#1
                  |L20.22|
;;;2056   
;;;2057   	/* check input parameters */
;;;2058   	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;2059   		return NAND_INVALID_NAND_ADDRESS;
;;;2060   
;;;2061   	/* x16 */
;;;2062   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0) {
;;;2063   		if(lenght > (device_info.spare_bytes_per_page >> 1) )
;;;2064   			return NAND_INVALID_LENGHT;
;;;2065   	}
;;;2066   
;;;2067   	/* x8 */
;;;2068   	if(lenght > device_info.spare_bytes_per_page)
;;;2069   		return NAND_INVALID_LENGHT;
;;;2070   
;;;2071   	/* spare area starts after last main area byte */
;;;2072   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) == 0)
;;;2073   		/* x8 bus width */
;;;2074   		addr.column=device_info.data_bytes_per_page;
;;;2075   	else
;;;2076   		/* x16 bus width */
;;;2077   		addr.column=device_info.data_bytes_per_page >> 1;
;;;2078   
;;;2079   	__build_cycle_addr(addr, address);
;;;2080   
;;;2081   	/* init board transfer */
;;;2082   	PLATFORM_Open();
;;;2083   
;;;2084   	/* send command */
;;;2085   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM);
;;;2086   
;;;2087   	/* send address */
;;;2088   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;2089   		PLATFORM_SendAddr(address[i]);
;;;2090   
;;;2091   	/* send data */
;;;2092   	for(k=0; k<lenght; k++)
;;;2093   		PLATFORM_SendData(buffer[k]);
;;;2094   
;;;2095   	/* send command */
;;;2096   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM_CONFIRM);
;;;2097   
;;;2098   	status_reg = NAND_Read_Status();
;;;2099   
;;;2100   	/* close board transfer */
;;;2101   	PLATFORM_Close();
;;;2102   
;;;2103   	/* check if program is good */
;;;2104   	if(status_reg & STATUS_FAIL)
;;;2105   		return NAND_PROGRAM_FAILED;
;;;2106   
;;;2107   	return NAND_SUCCESS;
;;;2108   }
000016  e8bd83fe          POP      {r1-r9,pc}
                  |L20.26|
00001a  4638              MOV      r0,r7                 ;2058
00001c  f7fffffe          BL       __is_valid_addr
000020  b108              CBZ      r0,|L20.38|
000022  2030              MOVS     r0,#0x30              ;2059
000024  e7f7              B        |L20.22|
                  |L20.38|
000026  481a              LDR      r0,|L20.144|
000028  8901              LDRH     r1,[r0,#8]            ;2062  ; device_info
00002a  07ca              LSLS     r2,r1,#31             ;2062
00002c  d003              BEQ      |L20.54|
00002e  8f02              LDRH     r2,[r0,#0x38]         ;2063  ; device_info
000030  ebb40f52          CMP      r4,r2,LSR #1          ;2063
000034  d802              BHI      |L20.60|
                  |L20.54|
000036  8f02              LDRH     r2,[r0,#0x38]         ;2068  ; device_info
000038  42a2              CMP      r2,r4                 ;2068
00003a  d201              BCS      |L20.64|
                  |L20.60|
00003c  2031              MOVS     r0,#0x31              ;2069
00003e  e7ea              B        |L20.22|
                  |L20.64|
000040  07c9              LSLS     r1,r1,#31             ;2072
000042  d016              BEQ      |L20.114|
000044  6b40              LDR      r0,[r0,#0x34]         ;2077  ; device_info
000046  0843              LSRS     r3,r0,#1              ;2077
                  |L20.72|
000048  ae01              ADD      r6,sp,#4              ;2079
00004a  464a              MOV      r2,r9                 ;2079
00004c  4641              MOV      r1,r8                 ;2079
00004e  4638              MOV      r0,r7                 ;2079
000050  9600              STR      r6,[sp,#0]            ;2079
000052  f7fffffe          BL       __build_cycle_addr
000056  490f              LDR      r1,|L20.148|
000058  2080              MOVS     r0,#0x80              ;2085
00005a  7008              STRB     r0,[r1,#0]            ;2085
00005c  4b0e              LDR      r3,|L20.152|
00005e  2000              MOVS     r0,#0                 ;2088
                  |L20.96|
000060  5c32              LDRB     r2,[r6,r0]            ;2089
000062  701a              STRB     r2,[r3,#0]            ;2089
000064  1c40              ADDS     r0,r0,#1              ;2089
000066  2805              CMP      r0,#5                 ;2088
000068  dbfa              BLT      |L20.96|
00006a  2000              MOVS     r0,#0                 ;2092
00006c  f04f43e0          MOV      r3,#0x70000000        ;2092
000070  e004              B        |L20.124|
                  |L20.114|
000072  6b43              LDR      r3,[r0,#0x34]         ;2074  ; device_info
000074  e7e8              B        |L20.72|
                  |L20.118|
000076  5c2a              LDRB     r2,[r5,r0]            ;2093
000078  701a              STRB     r2,[r3,#0]            ;2093
00007a  1c40              ADDS     r0,r0,#1              ;2093
                  |L20.124|
00007c  42a0              CMP      r0,r4                 ;2092
00007e  d3fa              BCC      |L20.118|
000080  2010              MOVS     r0,#0x10              ;2096
000082  7008              STRB     r0,[r1,#0]            ;2096
000084  f7fffffe          BL       NAND_Read_Status
000088  2000              MOVS     r0,#0                 ;2107
00008a  e7c4              B        |L20.22|
;;;2109   
                          ENDP

                  |L20.140|
                          DCD      ||.data||
                  |L20.144|
                          DCD      ||.bss||+0x38
                  |L20.148|
                          DCD      0x70010000
                  |L20.152|
                          DCD      0x70020000

                          AREA ||i.NAND_OTP_Spare_Read||, CODE, READONLY, ALIGN=2

                  NAND_OTP_Spare_Read PROC
;;;2226   
;;;2227   MT_uint8 NAND_OTP_Spare_Read(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4607              MOV      r7,r0
;;;2228   	MT_uint8 row_address[5];
;;;2229   	MT_uint8 status_reg;
;;;2230   	MT_uint8 ret;
;;;2231   	MT_uint32 k;
;;;2232   	int i;
;;;2233   
;;;2234   	/* verify if driver is initialized */
;;;2235   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000006  4823              LDR      r0,|L21.148|
000008  e9dd540a          LDRD     r5,r4,[sp,#0x28]      ;2227
00000c  7800              LDRB     r0,[r0,#0]  ; driver_status
00000e  4688              MOV      r8,r1                 ;2227
000010  4691              MOV      r9,r2                 ;2227
000012  b110              CBZ      r0,|L21.26|
;;;2236   		return DRIVER_STATUS_NOT_INITIALIZED;
000014  2001              MOVS     r0,#1
                  |L21.22|
;;;2237   
;;;2238   	/* check input parameters */
;;;2239   	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;2240   		return NAND_INVALID_NAND_ADDRESS;
;;;2241   
;;;2242   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0) {
;;;2243   		/* x16 */
;;;2244   		if(lenght > (device_info.spare_bytes_per_page >> 1) )
;;;2245   			return NAND_INVALID_LENGHT;
;;;2246   	}
;;;2247   
;;;2248   	/* x8 */
;;;2249   	if(lenght > device_info.spare_bytes_per_page)
;;;2250   		return NAND_INVALID_LENGHT;
;;;2251   
;;;2252   	/* spare area starts after last main area byte */
;;;2253   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) == 0)
;;;2254   		/* x8 bus width */
;;;2255   		addr.column=device_info.data_bytes_per_page;
;;;2256   	else
;;;2257   		/* x16 bus width */
;;;2258   		addr.column=device_info.data_bytes_per_page >> 1;
;;;2259   
;;;2260   	__build_cycle_addr(addr, row_address);
;;;2261   
;;;2262   	/* init board transfer */
;;;2263   	PLATFORM_Open();
;;;2264   
;;;2265   	/* send command */
;;;2266   	PLATFORM_SendCmd(CMD_READ_MODE);
;;;2267   
;;;2268   	/* send address */
;;;2269   	for(i=0; i<NUM_OF_ADDR_CYCLE; i++)
;;;2270   		PLATFORM_SendAddr(row_address[i]);
;;;2271   
;;;2272   	/* return to read mode */
;;;2273   	PLATFORM_SendCmd(CMD_READ_CONFIRM);
;;;2274   
;;;2275   	/* wait */
;;;2276   	ret = __wait_for_ready();
;;;2277   
;;;2278       /* return if timeout */
;;;2279       if (NAND_SUCCESS != ret)
;;;2280       	return ret;
;;;2281   
;;;2282   	/* read data */
;;;2283   	for(k=0; k<lenght; k++)
;;;2284   		buffer[k] = PLATFORM_ReadData();
;;;2285   
;;;2286   	/* read status register on exit */
;;;2287   	status_reg = NAND_Read_Status();
;;;2288   
;;;2289   	/* close board transfer */
;;;2290   	PLATFORM_Close();
;;;2291   
;;;2292   	if(status_reg & STATUS_FAIL)
;;;2293   		return NAND_READ_FAILED;
;;;2294   
;;;2295   	return ret;
;;;2296   }
000016  e8bd83fe          POP      {r1-r9,pc}
                  |L21.26|
00001a  4638              MOV      r0,r7                 ;2239
00001c  f7fffffe          BL       __is_valid_addr
000020  b108              CBZ      r0,|L21.38|
000022  2030              MOVS     r0,#0x30              ;2240
000024  e7f7              B        |L21.22|
                  |L21.38|
000026  481c              LDR      r0,|L21.152|
000028  8901              LDRH     r1,[r0,#8]            ;2242  ; device_info
00002a  07ca              LSLS     r2,r1,#31             ;2242
00002c  d003              BEQ      |L21.54|
00002e  8f02              LDRH     r2,[r0,#0x38]         ;2244  ; device_info
000030  ebb40f52          CMP      r4,r2,LSR #1          ;2244
000034  d802              BHI      |L21.60|
                  |L21.54|
000036  8f02              LDRH     r2,[r0,#0x38]         ;2249  ; device_info
000038  42a2              CMP      r2,r4                 ;2249
00003a  d201              BCS      |L21.64|
                  |L21.60|
00003c  2031              MOVS     r0,#0x31              ;2250
00003e  e7ea              B        |L21.22|
                  |L21.64|
000040  07c9              LSLS     r1,r1,#31             ;2253
000042  d01b              BEQ      |L21.124|
000044  6b40              LDR      r0,[r0,#0x34]         ;2258  ; device_info
000046  0843              LSRS     r3,r0,#1              ;2258
                  |L21.72|
000048  ae01              ADD      r6,sp,#4              ;2260
00004a  464a              MOV      r2,r9                 ;2260
00004c  4641              MOV      r1,r8                 ;2260
00004e  4638              MOV      r0,r7                 ;2260
000050  9600              STR      r6,[sp,#0]            ;2260
000052  f7fffffe          BL       __build_cycle_addr
000056  4911              LDR      r1,|L21.156|
000058  2000              MOVS     r0,#0                 ;2266
00005a  7008              STRB     r0,[r1,#0]            ;2266
00005c  4b10              LDR      r3,|L21.160|
                  |L21.94|
00005e  5c32              LDRB     r2,[r6,r0]            ;2270
000060  701a              STRB     r2,[r3,#0]            ;2270
000062  1c40              ADDS     r0,r0,#1              ;2270
000064  2805              CMP      r0,#5                 ;2269
000066  dbfa              BLT      |L21.94|
000068  2030              MOVS     r0,#0x30              ;2273
00006a  7008              STRB     r0,[r1,#0]            ;2273
00006c  f7fffffe          BL       __wait_for_ready
000070  0006              MOVS     r6,r0                 ;2276
000072  d1d0              BNE      |L21.22|
000074  2100              MOVS     r1,#0                 ;2283
000076  f04f42e0          MOV      r2,#0x70000000        ;2283
00007a  e004              B        |L21.134|
                  |L21.124|
00007c  6b43              LDR      r3,[r0,#0x34]         ;2255  ; device_info
00007e  e7e3              B        |L21.72|
                  |L21.128|
000080  7810              LDRB     r0,[r2,#0]            ;2255
000082  5468              STRB     r0,[r5,r1]            ;2284
000084  1c49              ADDS     r1,r1,#1              ;2284
                  |L21.134|
000086  42a1              CMP      r1,r4                 ;2283
000088  d3fa              BCC      |L21.128|
00008a  f7fffffe          BL       NAND_Read_Status
00008e  4630              MOV      r0,r6                 ;2295
000090  e7c1              B        |L21.22|
;;;2297   
                          ENDP

000092  0000              DCW      0x0000
                  |L21.148|
                          DCD      ||.data||
                  |L21.152|
                          DCD      ||.bss||+0x38
                  |L21.156|
                          DCD      0x70010000
                  |L21.160|
                          DCD      0x70020000

                          AREA ||i.NAND_Page_Program||, CODE, READONLY, ALIGN=2

                  NAND_Page_Program PROC
;;;1053   extern void CORE_threadGetData(void);
;;;1054   MT_uint8 NAND_Page_Program(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1055   	{
000004  4607              MOV      r7,r0
;;;1056   	MT_uint8 address[ 5 ];
;;;1057   	MT_uint8 status_reg;
;;;1058   	MT_uint32 k;
;;;1059   	int i;
;;;1060   	flash_width *pData;
;;;1061   
;;;1062   	/* verify if driver is initialized */
;;;1063   	if( DRIVER_STATUS_INITIALIZED != driver_status )
000006  4825              LDR      r0,|L22.156|
000008  e9dd560c          LDRD     r5,r6,[sp,#0x30]      ;1055
00000c  7800              LDRB     r0,[r0,#0]  ; driver_status
00000e  4688              MOV      r8,r1                 ;1055
000010  4691              MOV      r9,r2                 ;1055
000012  469a              MOV      r10,r3                ;1055
000014  b110              CBZ      r0,|L22.28|
;;;1064   		return DRIVER_STATUS_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L22.24|
;;;1065   
;;;1066   	/* check input parameters */
;;;1067   	if( NAND_SUCCESS != __is_valid_addr(addr) )
;;;1068   		return NAND_INVALID_NAND_ADDRESS;
;;;1069   
;;;1070   	/* x16 */
;;;1071   	if( (device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0 )
;;;1072   		{
;;;1073   		if( lenght > (device_info.data_bytes_per_page >> 1) )
;;;1074   			return NAND_INVALID_LENGHT;
;;;1075   		}
;;;1076   	/* x8 */
;;;1077   	else if( lenght > device_info.data_bytes_per_page )
;;;1078   		return NAND_INVALID_LENGHT;
;;;1079   
;;;1080   	__build_cycle_addr(addr, address);
;;;1081   
;;;1082   	/* init board transfer */
;;;1083   	PLATFORM_Open();
;;;1084   
;;;1085   	/* send command */
;;;1086   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM);
;;;1087   
;;;1088   	/* send address */
;;;1089   	for( i = 0; i < NUM_OF_ADDR_CYCLE; i++)
;;;1090   		{
;;;1091   		PLATFORM_SendAddr( address[ i ] );
;;;1092   		}
;;;1093   
;;;1094   	/* send data */
;;;1095   	pData = buffer;
;;;1096   	for( k = 0; k < lenght; k++ )
;;;1097   		{
;;;1098   		//PLATFORM_SendData( buffer[ k ] );
;;;1099   		PLATFORM_SendData( *pData );
;;;1100   		pData++;
;;;1101   		#warning: "KOCTUJIb"
;;;1102   		if( k % 128 == 0 )
;;;1103   			CORE_threadGetData();
;;;1104   		}
;;;1105   
;;;1106   	/* send command */
;;;1107   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM_CONFIRM);
;;;1108   
;;;1109   	status_reg = NAND_Read_Status();
;;;1110   
;;;1111   	/* close board transfer */
;;;1112   	PLATFORM_Close();
;;;1113   
;;;1114   	/* check if program is good */
;;;1115   	if( !(status_reg & STATUS_WRITE_PROTECTED) )
;;;1116   		return NAND_PROGRAM_FAILED_WRITE_PROTECT;
;;;1117   
;;;1118   	if( status_reg & STATUS_FAIL )
;;;1119   		return NAND_PROGRAM_FAILED;
;;;1120   
;;;1121   	return NAND_SUCCESS;
;;;1122   	}
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L22.28|
00001c  4638              MOV      r0,r7                 ;1067
00001e  f7fffffe          BL       __is_valid_addr
000022  b108              CBZ      r0,|L22.40|
000024  2030              MOVS     r0,#0x30              ;1068
000026  e7f7              B        |L22.24|
                  |L22.40|
000028  481d              LDR      r0,|L22.160|
00002a  7a01              LDRB     r1,[r0,#8]            ;1071  ; device_info
00002c  6b40              LDR      r0,[r0,#0x34]         ;1077  ; device_info
00002e  07c9              LSLS     r1,r1,#31             ;1071
000030  d003              BEQ      |L22.58|
000032  ebb60f50          CMP      r6,r0,LSR #1          ;1073
000036  d802              BHI      |L22.62|
000038  e003              B        |L22.66|
                  |L22.58|
00003a  42b0              CMP      r0,r6                 ;1077
00003c  d201              BCS      |L22.66|
                  |L22.62|
00003e  2031              MOVS     r0,#0x31              ;1078
000040  e7ea              B        |L22.24|
                  |L22.66|
000042  ac01              ADD      r4,sp,#4              ;1080
000044  4653              MOV      r3,r10                ;1080
000046  464a              MOV      r2,r9                 ;1080
000048  4641              MOV      r1,r8                 ;1080
00004a  4638              MOV      r0,r7                 ;1080
00004c  9400              STR      r4,[sp,#0]            ;1080
00004e  f7fffffe          BL       __build_cycle_addr
000052  4f14              LDR      r7,|L22.164|
000054  2080              MOVS     r0,#0x80              ;1086
000056  7038              STRB     r0,[r7,#0]            ;1086
000058  4a13              LDR      r2,|L22.168|
00005a  2000              MOVS     r0,#0                 ;1089
                  |L22.92|
00005c  5c21              LDRB     r1,[r4,r0]            ;1091
00005e  7011              STRB     r1,[r2,#0]            ;1091
000060  1c40              ADDS     r0,r0,#1              ;1091
000062  2805              CMP      r0,#5                 ;1089
000064  dbfa              BLT      |L22.92|
000066  2400              MOVS     r4,#0                 ;1096
000068  f04f48e0          MOV      r8,#0x70000000        ;1096
00006c  e009              B        |L22.130|
00006e  bf00              NOP                            ;1099
                  |L22.112|
000070  f8150b01          LDRB     r0,[r5],#1            ;1099
000074  f8880000          STRB     r0,[r8,#0]            ;1099
000078  0660              LSLS     r0,r4,#25             ;1102
00007a  d101              BNE      |L22.128|
00007c  f7fffffe          BL       CORE_threadGetData
                  |L22.128|
000080  1c64              ADDS     r4,r4,#1              ;1103
                  |L22.130|
000082  42b4              CMP      r4,r6                 ;1096
000084  d3f4              BCC      |L22.112|
000086  2010              MOVS     r0,#0x10              ;1107
000088  7038              STRB     r0,[r7,#0]            ;1107
00008a  f7fffffe          BL       NAND_Read_Status
00008e  0600              LSLS     r0,r0,#24             ;1115
000090  d401              BMI      |L22.150|
000092  2051              MOVS     r0,#0x51              ;1116
000094  e7c0              B        |L22.24|
                  |L22.150|
000096  2000              MOVS     r0,#0                 ;1121
000098  e7be              B        |L22.24|
;;;1123   
                          ENDP

00009a  0000              DCW      0x0000
                  |L22.156|
                          DCD      ||.data||
                  |L22.160|
                          DCD      ||.bss||+0x38
                  |L22.164|
                          DCD      0x70010000
                  |L22.168|
                          DCD      0x70020000

                          AREA ||i.NAND_Page_Read||, CODE, READONLY, ALIGN=2

                  NAND_Page_Read PROC
;;;958    
;;;959    MT_uint8 NAND_Page_Read(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;960    	{
000004  4607              MOV      r7,r0
000006  e9dd450c          LDRD     r4,r5,[sp,#0x30]
;;;961    	MT_uint8 row_address[5];
;;;962    	MT_uint8 status_reg;
;;;963    	MT_uint8 ret;
;;;964    	int i;
;;;965    	flash_width *pData;
;;;966    
;;;967    	/* verify if driver is initialized */
;;;968    	if( DRIVER_STATUS_INITIALIZED != driver_status )
00000a  4820              LDR      r0,|L23.140|
00000c  4688              MOV      r8,r1                 ;960
00000e  4691              MOV      r9,r2                 ;960
000010  7800              LDRB     r0,[r0,#0]  ; driver_status
000012  469a              MOV      r10,r3                ;960
000014  b110              CBZ      r0,|L23.28|
;;;969    		return DRIVER_STATUS_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L23.24|
;;;970    
;;;971    	/* check input parameters */
;;;972    	if( NAND_SUCCESS != __is_valid_addr(addr) )
;;;973    		return NAND_INVALID_NAND_ADDRESS;
;;;974    
;;;975    	/* x16 */
;;;976    	if( (device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0 )
;;;977    		{
;;;978    			if( lenght > (device_info.data_bytes_per_page >> 1) )
;;;979    				return NAND_INVALID_LENGHT;
;;;980    		}
;;;981    	/* x8 */
;;;982    	else if( lenght > device_info.data_bytes_per_page )
;;;983    		return NAND_INVALID_LENGHT;
;;;984    
;;;985    	__build_cycle_addr(addr, row_address);
;;;986    
;;;987    	/* init board transfer */
;;;988    	PLATFORM_Open();
;;;989    
;;;990    	/* send command  */
;;;991    	PLATFORM_SendCmd(CMD_READ_MODE);
;;;992    
;;;993    	/* send address */
;;;994    	for( i = 0; i < NUM_OF_ADDR_CYCLE; i++ )
;;;995    		PLATFORM_SendAddr( row_address[i] );
;;;996    
;;;997    	/* return to read mode */
;;;998    	PLATFORM_SendCmd(CMD_READ_CONFIRM);
;;;999    
;;;1000   	/* wait */
;;;1001   	ret = __wait_for_ready();
;;;1002   
;;;1003   	/* return if timeout */
;;;1004   	if (NAND_SUCCESS != ret)
;;;1005   		return ret;
;;;1006   
;;;1007   	/* read data */
;;;1008   	pData = buffer;
;;;1009   	for( i = 0; i < lenght; i++ )
;;;1010   		*pData++ = PLATFORM_ReadData();
;;;1011   		//buffer[i] = PLATFORM_ReadData();
;;;1012   
;;;1013   	/* read status register on exit */
;;;1014   	status_reg = NAND_Read_Status();
;;;1015   
;;;1016   	/* close board transfer */
;;;1017   	PLATFORM_Close();
;;;1018   
;;;1019   	if( status_reg & STATUS_FAIL )
;;;1020   		return NAND_READ_FAILED;
;;;1021   
;;;1022   	return ret;
;;;1023   	}
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L23.28|
00001c  4638              MOV      r0,r7                 ;972
00001e  f7fffffe          BL       __is_valid_addr
000022  b108              CBZ      r0,|L23.40|
000024  2030              MOVS     r0,#0x30              ;973
000026  e7f7              B        |L23.24|
                  |L23.40|
000028  4819              LDR      r0,|L23.144|
00002a  7a01              LDRB     r1,[r0,#8]            ;976  ; device_info
00002c  6b40              LDR      r0,[r0,#0x34]         ;982  ; device_info
00002e  07c9              LSLS     r1,r1,#31             ;976
000030  d003              BEQ      |L23.58|
000032  ebb50f50          CMP      r5,r0,LSR #1          ;978
000036  d802              BHI      |L23.62|
000038  e003              B        |L23.66|
                  |L23.58|
00003a  42a8              CMP      r0,r5                 ;982
00003c  d201              BCS      |L23.66|
                  |L23.62|
00003e  2031              MOVS     r0,#0x31              ;983
000040  e7ea              B        |L23.24|
                  |L23.66|
000042  ae01              ADD      r6,sp,#4              ;985
000044  4653              MOV      r3,r10                ;985
000046  464a              MOV      r2,r9                 ;985
000048  4641              MOV      r1,r8                 ;985
00004a  4638              MOV      r0,r7                 ;985
00004c  9600              STR      r6,[sp,#0]            ;985
00004e  f7fffffe          BL       __build_cycle_addr
000052  4910              LDR      r1,|L23.148|
000054  2000              MOVS     r0,#0                 ;991
000056  7008              STRB     r0,[r1,#0]            ;991
000058  4b0f              LDR      r3,|L23.152|
                  |L23.90|
00005a  5c32              LDRB     r2,[r6,r0]            ;995
00005c  701a              STRB     r2,[r3,#0]            ;995
00005e  1c40              ADDS     r0,r0,#1              ;995
000060  2805              CMP      r0,#5                 ;994
000062  dbfa              BLT      |L23.90|
000064  2030              MOVS     r0,#0x30              ;998
000066  7008              STRB     r0,[r1,#0]            ;998
000068  f7fffffe          BL       __wait_for_ready
00006c  0006              MOVS     r6,r0                 ;1001
00006e  d1d3              BNE      |L23.24|
000070  2100              MOVS     r1,#0                 ;1009
000072  f04f42e0          MOV      r2,#0x70000000        ;1009
000076  e003              B        |L23.128|
                  |L23.120|
000078  7810              LDRB     r0,[r2,#0]            ;1009
00007a  f8040b01          STRB     r0,[r4],#1            ;1010
00007e  1c49              ADDS     r1,r1,#1              ;1010
                  |L23.128|
000080  42a9              CMP      r1,r5                 ;1009
000082  d3f9              BCC      |L23.120|
000084  f7fffffe          BL       NAND_Read_Status
000088  4630              MOV      r0,r6                 ;1022
00008a  e7c5              B        |L23.24|
;;;1024   
                          ENDP

                  |L23.140|
                          DCD      ||.data||
                  |L23.144|
                          DCD      ||.bss||+0x38
                  |L23.148|
                          DCD      0x70010000
                  |L23.152|
                          DCD      0x70020000

                          AREA ||i.NAND_Read_ID||, CODE, READONLY, ALIGN=2

                  NAND_Read_ID PROC
;;;424    
;;;425    MT_uint8 NAND_Read_ID(flash_width *buffer)
000000  b510              PUSH     {r4,lr}
;;;426    	{
000002  4604              MOV      r4,r0
;;;427    	int i;
;;;428    
;;;429    	/* verify if driver is initialized */
;;;430    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  480b              LDR      r0,|L24.52|
000006  7800              LDRB     r0,[r0,#0]  ; driver_status
000008  b108              CBZ      r0,|L24.14|
;;;431    		return DRIVER_STATUS_NOT_INITIALIZED;
00000a  2001              MOVS     r0,#1
;;;432    
;;;433    	/* init board transfer */
;;;434    	PLATFORM_Open();
;;;435    
;;;436    	/* send command and/or address */
;;;437    	PLATFORM_SendCmd(CMD_READID);
;;;438    	PLATFORM_SendAddr(ADDR_READ_ID);
;;;439    
;;;440    	/* wait (see datasheet for details) */
;;;441    	PLATFORM_Wait(TIME_WHR);
;;;442    
;;;443    	/* read output */
;;;444    	for( i = 0; i < NUM_OF_READID_BYTES; i++)
;;;445    		buffer[i] = PLATFORM_ReadData();
;;;446    
;;;447    	/* close board transfer */
;;;448    	PLATFORM_Close();
;;;449    
;;;450    	return NAND_SUCCESS;
;;;451    	}
00000c  bd10              POP      {r4,pc}
                  |L24.14|
00000e  490a              LDR      r1,|L24.56|
000010  2090              MOVS     r0,#0x90              ;437
000012  7008              STRB     r0,[r1,#0]            ;437
000014  4909              LDR      r1,|L24.60|
000016  2000              MOVS     r0,#0                 ;438
000018  7008              STRB     r0,[r1,#0]            ;438
00001a  203c              MOVS     r0,#0x3c              ;441
00001c  f7fffffe          BL       PLATFORM_Wait
000020  2100              MOVS     r1,#0                 ;444
000022  f04f42e0          MOV      r2,#0x70000000        ;444
                  |L24.38|
000026  7810              LDRB     r0,[r2,#0]            ;444
000028  5460              STRB     r0,[r4,r1]            ;445
00002a  1c49              ADDS     r1,r1,#1              ;445
00002c  2905              CMP      r1,#5                 ;444
00002e  dbfa              BLT      |L24.38|
000030  2000              MOVS     r0,#0                 ;450
000032  bd10              POP      {r4,pc}
;;;452    
                          ENDP

                  |L24.52|
                          DCD      ||.data||
                  |L24.56|
                          DCD      0x70010000
                  |L24.60|
                          DCD      0x70020000

                          AREA ||i.NAND_Read_ID_ONFI||, CODE, READONLY, ALIGN=2

                  NAND_Read_ID_ONFI PROC
;;;470    
;;;471    MT_uint8 NAND_Read_ID_ONFI(flash_width *buffer)
000000  b510              PUSH     {r4,lr}
000002  490a              LDR      r1,|L25.44|
;;;472    	{
000004  4604              MOV      r4,r0
;;;473    	MT_uint32 i;
;;;474    
;;;475    	/* init board transfer */
;;;476    	PLATFORM_Open();
;;;477    
;;;478    	/* send command and/or address */
;;;479    	PLATFORM_SendCmd(CMD_READID);
000006  2090              MOVS     r0,#0x90
000008  7008              STRB     r0,[r1,#0]
00000a  4909              LDR      r1,|L25.48|
;;;480    	PLATFORM_SendAddr(ADDR_READ_ID_ONFI);
00000c  2020              MOVS     r0,#0x20
00000e  7008              STRB     r0,[r1,#0]
;;;481    
;;;482    	/* wait (see datasheet for details) */
;;;483    	PLATFORM_Wait(TIME_WHR);
000010  203c              MOVS     r0,#0x3c
000012  f7fffffe          BL       PLATFORM_Wait
;;;484    
;;;485    	/* read output */
;;;486    	for( i = 0; i < NUM_OF_READIDONFI_BYTES; i++)
000016  2100              MOVS     r1,#0
000018  f04f42e0          MOV      r2,#0x70000000
                  |L25.28|
00001c  7810              LDRB     r0,[r2,#0]
;;;487    		buffer[i] = PLATFORM_ReadData();
00001e  5460              STRB     r0,[r4,r1]
000020  1c49              ADDS     r1,r1,#1
000022  2904              CMP      r1,#4                 ;486
000024  d3fa              BCC      |L25.28|
;;;488    
;;;489    	/* close board transfer */
;;;490    	PLATFORM_Close();
;;;491    
;;;492    	return NAND_SUCCESS;
000026  2000              MOVS     r0,#0
;;;493    	}
000028  bd10              POP      {r4,pc}
;;;494    
                          ENDP

00002a  0000              DCW      0x0000
                  |L25.44|
                          DCD      0x70010000
                  |L25.48|
                          DCD      0x70020000

                          AREA ||i.NAND_Read_Lock_Status||, CODE, READONLY, ALIGN=2

                  NAND_Read_Lock_Status PROC
;;;1688   
;;;1689   MT_uint8 NAND_Read_Lock_Status(nand_addr_t block_addr) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
;;;1690   	MT_uint8 block_addr_stream[NUM_OF_ADDR_CYCLE];
;;;1691   	MT_uint8 block_lock_status_reg;
;;;1692   
;;;1693   	/* verify if driver is initialized */
;;;1694   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  4813              LDR      r0,|L26.84|
000006  460d              MOV      r5,r1                 ;1689
000008  4616              MOV      r6,r2                 ;1689
00000a  7800              LDRB     r0,[r0,#0]  ; driver_status
00000c  461f              MOV      r7,r3                 ;1689
00000e  b108              CBZ      r0,|L26.20|
;;;1695   		return DRIVER_STATUS_NOT_INITIALIZED;
000010  2001              MOVS     r0,#1
;;;1696   
;;;1697   	/* check input parameters */
;;;1698   	if(NAND_SUCCESS != __is_valid_addr(block_addr))
;;;1699   		return NAND_INVALID_NAND_ADDRESS;
;;;1700   
;;;1701   	/* build address cycles for block address */
;;;1702   	__build_cycle_addr(block_addr, block_addr_stream);
;;;1703   
;;;1704   	/* init board transfer */
;;;1705   	PLATFORM_Open();
;;;1706   
;;;1707   	/* send command*/
;;;1708   	PLATFORM_SendCmd(CMD_BLOCK_LOCK_READ_STATUS);
;;;1709   
;;;1710   	/* send row address (3rd, 4th, 5th cycle) */
;;;1711   	PLATFORM_SendAddr(block_addr_stream[2]);
;;;1712   	PLATFORM_SendAddr(block_addr_stream[3]);
;;;1713   	PLATFORM_SendAddr(block_addr_stream[4]);
;;;1714   
;;;1715   	block_lock_status_reg = PLATFORM_ReadData();
;;;1716   
;;;1717   	/* close board transfer */
;;;1718   	PLATFORM_Close();
;;;1719   
;;;1720   	/* return the value of block status register */
;;;1721   	return block_lock_status_reg;
;;;1722   
;;;1723   }
000012  bdfe              POP      {r1-r7,pc}
                  |L26.20|
000014  4620              MOV      r0,r4                 ;1698
000016  f7fffffe          BL       __is_valid_addr
00001a  b108              CBZ      r0,|L26.32|
00001c  2030              MOVS     r0,#0x30              ;1699
00001e  bdfe              POP      {r1-r7,pc}
                  |L26.32|
000020  a801              ADD      r0,sp,#4              ;1702
000022  9000              STR      r0,[sp,#0]            ;1702
000024  463b              MOV      r3,r7                 ;1702
000026  4632              MOV      r2,r6                 ;1702
000028  4629              MOV      r1,r5                 ;1702
00002a  4620              MOV      r0,r4                 ;1702
00002c  f7fffffe          BL       __build_cycle_addr
000030  4909              LDR      r1,|L26.88|
000032  207a              MOVS     r0,#0x7a              ;1708
000034  7008              STRB     r0,[r1,#0]            ;1708
000036  4809              LDR      r0,|L26.92|
000038  f89d1006          LDRB     r1,[sp,#6]            ;1711
00003c  7001              STRB     r1,[r0,#0]            ;1711
00003e  f89d1007          LDRB     r1,[sp,#7]            ;1712
000042  7001              STRB     r1,[r0,#0]            ;1712
000044  f89d1008          LDRB     r1,[sp,#8]            ;1713
000048  7001              STRB     r1,[r0,#0]            ;1713
00004a  f04f40e0          MOV      r0,#0x70000000        ;1713
00004e  7800              LDRB     r0,[r0,#0]            ;1713
000050  bdfe              POP      {r1-r7,pc}
;;;1724   
                          ENDP

000052  0000              DCW      0x0000
                  |L26.84|
                          DCD      ||.data||
                  |L26.88|
                          DCD      0x70010000
                  |L26.92|
                          DCD      0x70020000

                          AREA ||i.NAND_Read_Param_Page||, CODE, READONLY, ALIGN=2

                  NAND_Read_Param_Page PROC
;;;515    
;;;516    MT_uint8 NAND_Read_Param_Page(param_page_t *ppage)
000000  b530              PUSH     {r4,r5,lr}
000002  4961              LDR      r1,|L27.392|
;;;517    	{
000004  4604              MOV      r4,r0
000006  b0a1              SUB      sp,sp,#0x84
;;;518    	MT_uint8 rbuf[NUM_OF_PPAGE_BYTES];
;;;519    	MT_uint8 ret;
;;;520    	MT_uint32 i;
;;;521    
;;;522    	/* init board transfer */
;;;523    	PLATFORM_Open();
;;;524    
;;;525    	/* send command and/or address */
;;;526    	PLATFORM_SendCmd(CMD_READ_PARAM_PAGE);
000008  20ec              MOVS     r0,#0xec
00000a  7008              STRB     r0,[r1,#0]
00000c  495f              LDR      r1,|L27.396|
;;;527    	PLATFORM_SendAddr(ADDR_PARAM_PAGE);
00000e  2000              MOVS     r0,#0
000010  7008              STRB     r0,[r1,#0]
;;;528    
;;;529    	/* wait (see datasheet for details) */
;;;530    	PLATFORM_Wait(TIME_WB);
000012  2064              MOVS     r0,#0x64
000014  f7fffffe          BL       PLATFORM_Wait
;;;531    	ret = __wait_for_ready();
000018  f7fffffe          BL       __wait_for_ready
00001c  0005              MOVS     r5,r0
;;;532    
;;;533    	/* return if timeout */
;;;534    	if( NAND_SUCCESS != ret )
00001e  d113              BNE      |L27.72|
000020  466a              MOV      r2,sp                 ;518
000022  f04f43e0          MOV      r3,#0x70000000        ;518
                  |L27.38|
000026  7819              LDRB     r1,[r3,#0]            ;518
;;;535    		return ret;
;;;536    
;;;537    	/* read output */
;;;538    	for( i = 0; i < NUM_OF_PPAGE_BYTES; i++)
;;;539    		rbuf[ i ] = PLATFORM_ReadData();
000028  5411              STRB     r1,[r2,r0]
00002a  1c40              ADDS     r0,r0,#1
00002c  2881              CMP      r0,#0x81              ;538
00002e  d3fa              BCC      |L27.38|
;;;540    
;;;541    	/* close board transfer */
;;;542    	PLATFORM_Close();
;;;543    
;;;544    	/*
;;;545    	* Fill the parameter page data structure in the right way
;;;546    	*/
;;;547    
;;;548    	/* Parameter page signature (ONFI) */
;;;549    	__as_string(rbuf, ppage->signature, 0, 3);
000030  2303              MOVS     r3,#3
000032  2200              MOVS     r2,#0
000034  4621              MOV      r1,r4
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       __as_string
;;;550    
;;;551    	/* check if the buffer contains a valid ONFI parameter page */
;;;552    	if (strcmp(ppage->signature, "ONFI"))
00003c  a154              ADR      r1,|L27.400|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcmp
000044  b110              CBZ      r0,|L27.76|
;;;553    		return NAND_BAD_PARAMETER_PAGE;
000046  2020              MOVS     r0,#0x20
                  |L27.72|
;;;554    
;;;555    	/* Revision number */
;;;556    	ppage->rev_num = __as_uint16(rbuf[4], rbuf[5]);
;;;557    
;;;558    	/* Features supported */
;;;559    	ppage->feature = __as_uint16(rbuf[6], rbuf[7]);
;;;560    
;;;561    	/* Optional commands supported */
;;;562    	ppage->command = __as_uint16(rbuf[8], rbuf[9]);
;;;563    
;;;564    	/* Device manufacturer */
;;;565    	__as_string(rbuf, ppage->manufacturer, 32, 43);
;;;566    
;;;567    	/* Device part number */
;;;568    	__as_string(rbuf, ppage->model, 44, 63);
;;;569    
;;;570    	/* Manufacturer ID (Micron = 2Ch) */
;;;571    	ppage->jedec_id = rbuf[64];
;;;572    
;;;573    	/* Date code */
;;;574    	ppage->date_code = __as_uint16(rbuf[65], rbuf[66]);
;;;575    
;;;576    	/* Number of data bytes per page */
;;;577    	ppage->data_bytes_per_page = __as_uint32(rbuf[80], rbuf[81], rbuf[82], rbuf[83]);
;;;578    
;;;579    	/* Number of spare bytes per page */
;;;580    	ppage->spare_bytes_per_page = __as_uint16(rbuf[84], rbuf[85]);
;;;581    
;;;582    	/* Number of data bytes per partial page */
;;;583    	ppage->data_bytes_per_partial_page = __as_uint32(rbuf[86], rbuf[87], rbuf[88], rbuf[89]);
;;;584    
;;;585    	/* Number of spare bytes per partial page */
;;;586    	ppage->spare_bytes_per_partial_page = __as_uint16(rbuf[90], rbuf[91]);
;;;587    
;;;588    	/* Number of pages per block */
;;;589    	ppage->pages_per_block = __as_uint32(rbuf[92], rbuf[93], rbuf[94], rbuf[95]);
;;;590    
;;;591    	/* Number of blocks per unit */
;;;592    	ppage->blocks_per_lun = __as_uint32(rbuf[96], rbuf[97], rbuf[98], rbuf[99]);
;;;593    
;;;594    	/* Number of logical units (LUN) per chip enable */
;;;595    	ppage->luns_per_ce = rbuf[100];
;;;596    
;;;597    	/* Number of address cycles */
;;;598    	ppage->num_addr_cycles = rbuf[101];
;;;599    
;;;600    	/* Number of bits per cell (1 = SLC; >1= MLC) */
;;;601    	ppage->bit_per_cell = rbuf[102];
;;;602    
;;;603    	/* Bad blocks maximum per unit */
;;;604    	ppage->max_bad_blocks_per_lun = __as_uint16(rbuf[103], rbuf[104]);
;;;605    
;;;606    	/* Block endurance */
;;;607    	ppage->block_endurance = __as_uint16(rbuf[105], rbuf[106]);
;;;608    
;;;609    	/* Guaranteed valid blocks at beginning of target */
;;;610    	ppage->guarenteed_valid_blocks = rbuf[107];
;;;611    
;;;612    	/* Block endurance for guaranteed valid blocks */
;;;613    	ppage->guarenteed_valid_blocks = __as_uint16(rbuf[108], rbuf[109]);
;;;614    
;;;615    	/* Number of programs per page */
;;;616    	ppage->num_programs_per_page = rbuf[110];
;;;617    
;;;618    	/* Partial programming attributes */
;;;619    	ppage->partial_prog_attr = rbuf[111];
;;;620    
;;;621    	/* Number of bits ECC bits */
;;;622    	ppage->num_ECC_bits_correctable = rbuf[112];
;;;623    
;;;624    	/* Number of interleaved address bits */
;;;625    	ppage->num_interleaved_addr_bits = rbuf[113];
;;;626    
;;;627    	/* Interleaved operation attributes */
;;;628    	ppage->interleaved_op_attr = rbuf[114];
;;;629    
;;;630    	return ret;
;;;631    	}
000048  b021              ADD      sp,sp,#0x84
00004a  bd30              POP      {r4,r5,pc}
                  |L27.76|
00004c  f89d1004          LDRB     r1,[sp,#4]            ;556
000050  f89d0005          LDRB     r0,[sp,#5]            ;556
000054  232b              MOVS     r3,#0x2b              ;565
000056  ea412000          ORR      r0,r1,r0,LSL #8       ;565
00005a  80e0              STRH     r0,[r4,#6]            ;556
00005c  f89d1006          LDRB     r1,[sp,#6]            ;559
000060  f89d0007          LDRB     r0,[sp,#7]            ;559
000064  2220              MOVS     r2,#0x20              ;565
000066  ea412000          ORR      r0,r1,r0,LSL #8       ;565
00006a  8120              STRH     r0,[r4,#8]            ;559
00006c  f89d1008          LDRB     r1,[sp,#8]            ;562
000070  f89d0009          LDRB     r0,[sp,#9]            ;562
000074  ea412000          ORR      r0,r1,r0,LSL #8       ;562
000078  8160              STRH     r0,[r4,#0xa]          ;562
00007a  f104010c          ADD      r1,r4,#0xc            ;565
00007e  4668              MOV      r0,sp                 ;565
000080  f7fffffe          BL       __as_string
000084  233f              MOVS     r3,#0x3f              ;568
000086  222c              MOVS     r2,#0x2c              ;568
000088  f1040119          ADD      r1,r4,#0x19           ;568
00008c  4668              MOV      r0,sp                 ;568
00008e  f7fffffe          BL       __as_string
000092  f89d0040          LDRB     r0,[sp,#0x40]         ;571
000096  f884002e          STRB     r0,[r4,#0x2e]         ;571
00009a  f89d1041          LDRB     r1,[sp,#0x41]         ;574
00009e  f89d0042          LDRB     r0,[sp,#0x42]         ;574
0000a2  ea412000          ORR      r0,r1,r0,LSL #8       ;574
0000a6  8620              STRH     r0,[r4,#0x30]         ;574
0000a8  f89d3053          LDRB     r3,[sp,#0x53]         ;577
0000ac  f89d2052          LDRB     r2,[sp,#0x52]         ;577
0000b0  f89d1051          LDRB     r1,[sp,#0x51]         ;577
0000b4  f89d0050          LDRB     r0,[sp,#0x50]         ;577
0000b8  343c              ADDS     r4,r4,#0x3c           ;577
0000ba  f7fffffe          BL       __as_uint32
0000be  f8440c08          STR      r0,[r4,#-8]           ;577
0000c2  f89d1054          LDRB     r1,[sp,#0x54]         ;580
0000c6  f89d0055          LDRB     r0,[sp,#0x55]         ;580
0000ca  ea412000          ORR      r0,r1,r0,LSL #8       ;580
0000ce  f8240c04          STRH     r0,[r4,#-4]           ;580
0000d2  f89d3059          LDRB     r3,[sp,#0x59]         ;583
0000d6  f89d2058          LDRB     r2,[sp,#0x58]         ;583
0000da  f89d1057          LDRB     r1,[sp,#0x57]         ;583
0000de  f89d0056          LDRB     r0,[sp,#0x56]         ;583
0000e2  f7fffffe          BL       __as_uint32
0000e6  6020              STR      r0,[r4,#0]            ;586
0000e8  f89d005a          LDRB     r0,[sp,#0x5a]         ;586
0000ec  f89d105b          LDRB     r1,[sp,#0x5b]         ;586
0000f0  ea402001          ORR      r0,r0,r1,LSL #8       ;586
0000f4  80a0              STRH     r0,[r4,#4]            ;586
0000f6  f89d305f          LDRB     r3,[sp,#0x5f]         ;589
0000fa  f89d205e          LDRB     r2,[sp,#0x5e]         ;589
0000fe  f89d105d          LDRB     r1,[sp,#0x5d]         ;589
000102  f89d005c          LDRB     r0,[sp,#0x5c]         ;589
000106  f7fffffe          BL       __as_uint32
00010a  60a0              STR      r0,[r4,#8]            ;592
00010c  f89d3063          LDRB     r3,[sp,#0x63]         ;592
000110  f89d2062          LDRB     r2,[sp,#0x62]         ;592
000114  f89d1061          LDRB     r1,[sp,#0x61]         ;592
000118  f89d0060          LDRB     r0,[sp,#0x60]         ;592
00011c  f7fffffe          BL       __as_uint32
000120  60e0              STR      r0,[r4,#0xc]          ;595
000122  f89d0064          LDRB     r0,[sp,#0x64]         ;595
000126  7420              STRB     r0,[r4,#0x10]         ;595
000128  f89d0065          LDRB     r0,[sp,#0x65]         ;598
00012c  7460              STRB     r0,[r4,#0x11]         ;598
00012e  f89d0066          LDRB     r0,[sp,#0x66]         ;601
000132  74a0              STRB     r0,[r4,#0x12]         ;601
000134  f89d1067          LDRB     r1,[sp,#0x67]         ;604
000138  f89d0068          LDRB     r0,[sp,#0x68]         ;604
00013c  ea412000          ORR      r0,r1,r0,LSL #8       ;604
000140  82a0              STRH     r0,[r4,#0x14]         ;604
000142  f89d1069          LDRB     r1,[sp,#0x69]         ;607
000146  f89d006a          LDRB     r0,[sp,#0x6a]         ;607
00014a  ea412000          ORR      r0,r1,r0,LSL #8       ;607
00014e  82e0              STRH     r0,[r4,#0x16]         ;607
000150  f89d006b          LDRB     r0,[sp,#0x6b]         ;610
000154  7620              STRB     r0,[r4,#0x18]         ;610
000156  f89d106c          LDRB     r1,[sp,#0x6c]         ;613
00015a  f89d006d          LDRB     r0,[sp,#0x6d]         ;613
00015e  ea412000          ORR      r0,r1,r0,LSL #8       ;613
000162  7620              STRB     r0,[r4,#0x18]         ;613
000164  f89d006e          LDRB     r0,[sp,#0x6e]         ;616
000168  7720              STRB     r0,[r4,#0x1c]         ;616
00016a  f89d006f          LDRB     r0,[sp,#0x6f]         ;619
00016e  7760              STRB     r0,[r4,#0x1d]         ;619
000170  f89d0070          LDRB     r0,[sp,#0x70]         ;622
000174  77a0              STRB     r0,[r4,#0x1e]         ;622
000176  f89d0071          LDRB     r0,[sp,#0x71]         ;625
00017a  77e0              STRB     r0,[r4,#0x1f]         ;625
00017c  f89d0072          LDRB     r0,[sp,#0x72]         ;628
000180  f8840020          STRB     r0,[r4,#0x20]         ;628
000184  4628              MOV      r0,r5                 ;630
000186  e75f              B        |L27.72|
;;;632    
                          ENDP

                  |L27.392|
                          DCD      0x70010000
                  |L27.396|
                          DCD      0x70020000
                  |L27.400|
000190  4f4e4649          DCB      "ONFI",0
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0

                          AREA ||i.NAND_Read_Status||, CODE, READONLY, ALIGN=2

                  NAND_Read_Status PROC
;;;770    
;;;771    flash_width NAND_Read_Status(void)
000000  4807              LDR      r0,|L28.32|
;;;772    	{
000002  b510              PUSH     {r4,lr}
;;;773    	flash_width ret;
;;;774    
;;;775    	/* verify if driver is initialized */
;;;776    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  7800              LDRB     r0,[r0,#0]  ; driver_status
000006  b108              CBZ      r0,|L28.12|
;;;777    		return DRIVER_STATUS_NOT_INITIALIZED;
000008  2001              MOVS     r0,#1
;;;778    
;;;779    	/* init board transfer */
;;;780    	PLATFORM_Open();
;;;781    
;;;782    	/* send command and/or address */
;;;783    	PLATFORM_SendCmd(CMD_READ_STATUS);
;;;784    
;;;785    	/* wait */
;;;786    	PLATFORM_Wait(TIME_WHR);
;;;787    
;;;788    	/* read value */
;;;789    	ret = PLATFORM_ReadData();
;;;790    
;;;791    	/* close board transfer */
;;;792    	PLATFORM_Close();
;;;793    
;;;794    	return ret;
;;;795    	}
00000a  bd10              POP      {r4,pc}
                  |L28.12|
00000c  4905              LDR      r1,|L28.36|
00000e  2070              MOVS     r0,#0x70              ;783
000010  7008              STRB     r0,[r1,#0]            ;783
000012  203c              MOVS     r0,#0x3c              ;786
000014  f7fffffe          BL       PLATFORM_Wait
000018  f04f40e0          MOV      r0,#0x70000000        ;786
00001c  7800              LDRB     r0,[r0,#0]            ;786
00001e  bd10              POP      {r4,pc}
;;;796    
                          ENDP

                  |L28.32|
                          DCD      ||.data||
                  |L28.36|
                          DCD      0x70010000

                          AREA ||i.NAND_Read_Status_Enhanced||, CODE, READONLY, ALIGN=2

                  NAND_Read_Status_Enhanced PROC
;;;813    
;;;814    flash_width NAND_Read_Status_Enhanced(nand_addr_t addr)
000000  b5fe              PUSH     {r1-r7,lr}
;;;815    	{
000002  4604              MOV      r4,r0
;;;816    	flash_width ret;
;;;817    	MT_uint8 row_address[5];
;;;818    
;;;819    	/* verify if driver is initialized */
;;;820    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  4817              LDR      r0,|L29.100|
000006  460d              MOV      r5,r1                 ;815
000008  4616              MOV      r6,r2                 ;815
00000a  7800              LDRB     r0,[r0,#0]  ; driver_status
00000c  461f              MOV      r7,r3                 ;815
00000e  b108              CBZ      r0,|L29.20|
;;;821    		return DRIVER_STATUS_NOT_INITIALIZED;
000010  2001              MOVS     r0,#1
;;;822    
;;;823    	/* check input parameters */
;;;824    	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;825    		return NAND_INVALID_NAND_ADDRESS;
;;;826    
;;;827    	/* check if this feature/command is supported */
;;;828    	if ((device_info.command & OPTIONAL_CMD_READ_STATUS_ENHANCED) == 0)
;;;829    		return NAND_UNSUPPORTED;
;;;830    
;;;831    	__build_cycle_addr(addr, row_address);
;;;832    
;;;833    	/* init board transfer */
;;;834    	PLATFORM_Open();
;;;835    
;;;836    	/* send command  */
;;;837    	PLATFORM_SendCmd(CMD_READ_STATUS_ENHANCED);
;;;838    
;;;839    	/* send row address (3rd, 4th, 5th cycle) */
;;;840    	PLATFORM_SendAddr(row_address[2]);
;;;841    	PLATFORM_SendAddr(row_address[3]);
;;;842    	PLATFORM_SendAddr(row_address[4]);
;;;843    
;;;844    	/* wait */
;;;845    	PLATFORM_Wait(TIME_WHR);
;;;846    
;;;847    	/* read value */
;;;848    	ret = PLATFORM_ReadData();
;;;849    
;;;850    	/* close board transfer */
;;;851    	PLATFORM_Close();
;;;852    
;;;853    	return ret;
;;;854    	}
000012  bdfe              POP      {r1-r7,pc}
                  |L29.20|
000014  4620              MOV      r0,r4                 ;824
000016  f7fffffe          BL       __is_valid_addr
00001a  b108              CBZ      r0,|L29.32|
00001c  2030              MOVS     r0,#0x30              ;825
00001e  bdfe              POP      {r1-r7,pc}
                  |L29.32|
000020  4811              LDR      r0,|L29.104|
000022  7a80              LDRB     r0,[r0,#0xa]          ;828  ; device_info
000024  0700              LSLS     r0,r0,#28             ;828
000026  d401              BMI      |L29.44|
000028  20fd              MOVS     r0,#0xfd              ;829
00002a  bdfe              POP      {r1-r7,pc}
                  |L29.44|
00002c  a801              ADD      r0,sp,#4              ;831
00002e  9000              STR      r0,[sp,#0]            ;831
000030  463b              MOV      r3,r7                 ;831
000032  4632              MOV      r2,r6                 ;831
000034  4629              MOV      r1,r5                 ;831
000036  4620              MOV      r0,r4                 ;831
000038  f7fffffe          BL       __build_cycle_addr
00003c  490b              LDR      r1,|L29.108|
00003e  2078              MOVS     r0,#0x78              ;837
000040  7008              STRB     r0,[r1,#0]            ;837
000042  480b              LDR      r0,|L29.112|
000044  f89d1006          LDRB     r1,[sp,#6]            ;840
000048  7001              STRB     r1,[r0,#0]            ;840
00004a  f89d1007          LDRB     r1,[sp,#7]            ;841
00004e  7001              STRB     r1,[r0,#0]            ;841
000050  f89d1008          LDRB     r1,[sp,#8]            ;842
000054  7001              STRB     r1,[r0,#0]            ;842
000056  203c              MOVS     r0,#0x3c              ;845
000058  f7fffffe          BL       PLATFORM_Wait
00005c  f04f40e0          MOV      r0,#0x70000000        ;845
000060  7800              LDRB     r0,[r0,#0]            ;845
000062  bdfe              POP      {r1-r7,pc}
;;;855    
                          ENDP

                  |L29.100|
                          DCD      ||.data||
                  |L29.104|
                          DCD      ||.bss||+0x38
                  |L29.108|
                          DCD      0x70010000
                  |L29.112|
                          DCD      0x70020000

                          AREA ||i.NAND_Read_Unique_Id||, CODE, READONLY, ALIGN=2

                  NAND_Read_Unique_Id PROC
;;;1331    */
;;;1332   MT_uint8 NAND_Read_Unique_Id(flash_width *buffer)
000000  b510              PUSH     {r4,lr}
;;;1333   {
000002  4604              MOV      r4,r0
;;;1334   
;;;1335   	int i;
;;;1336   	MT_uint8 ret;
;;;1337   
;;;1338   	/* verify if driver is initialized */
;;;1339   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  480d              LDR      r0,|L30.60|
000006  7800              LDRB     r0,[r0,#0]  ; driver_status
000008  b108              CBZ      r0,|L30.14|
;;;1340   		return DRIVER_STATUS_NOT_INITIALIZED;
00000a  2001              MOVS     r0,#1
                  |L30.12|
;;;1341   
;;;1342   	/* init board transfer */
;;;1343       PLATFORM_Open();
;;;1344   
;;;1345       /* send command and/or address */
;;;1346       PLATFORM_SendCmd(CMD_READ_UNIQ_ID);
;;;1347       PLATFORM_SendAddr(ADDR_READ_UNIQ_ID);
;;;1348   
;;;1349       /* wait (see datasheet for details) */
;;;1350       PLATFORM_Wait(TIME_WB);
;;;1351   
;;;1352   	ret = __wait_for_ready();
;;;1353   
;;;1354       /* return if timeout */
;;;1355       if (NAND_SUCCESS != ret)
;;;1356       	return ret;
;;;1357   
;;;1358       /* read output */
;;;1359       for(i=0; i<NUM_OF_UNIQUEID_BYTES; i++)
;;;1360       	buffer[i] = (MT_uint8) PLATFORM_ReadData();
;;;1361   
;;;1362       /* close board transfer */
;;;1363       PLATFORM_Close();
;;;1364   
;;;1365       return NAND_SUCCESS;
;;;1366   
;;;1367   }
00000c  bd10              POP      {r4,pc}
                  |L30.14|
00000e  490c              LDR      r1,|L30.64|
000010  20ed              MOVS     r0,#0xed              ;1346
000012  7008              STRB     r0,[r1,#0]            ;1346
000014  490b              LDR      r1,|L30.68|
000016  2000              MOVS     r0,#0                 ;1347
000018  7008              STRB     r0,[r1,#0]            ;1347
00001a  2064              MOVS     r0,#0x64              ;1350
00001c  f7fffffe          BL       PLATFORM_Wait
000020  f7fffffe          BL       __wait_for_ready
000024  2800              CMP      r0,#0                 ;1355
000026  d1f1              BNE      |L30.12|
000028  f04f42e0          MOV      r2,#0x70000000        ;1355
                  |L30.44|
00002c  7811              LDRB     r1,[r2,#0]            ;1355
00002e  5421              STRB     r1,[r4,r0]            ;1360
000030  1c40              ADDS     r0,r0,#1              ;1360
000032  2820              CMP      r0,#0x20              ;1359
000034  dbfa              BLT      |L30.44|
000036  2000              MOVS     r0,#0                 ;1365
000038  bd10              POP      {r4,pc}
;;;1368   
                          ENDP

00003a  0000              DCW      0x0000
                  |L30.60|
                          DCD      ||.data||
                  |L30.64|
                          DCD      0x70010000
                  |L30.68|
                          DCD      0x70020000

                          AREA ||i.NAND_Reset||, CODE, READONLY, ALIGN=2

                  NAND_Reset PROC
;;;386    
;;;387    MT_uint8 NAND_Reset(void)
000000  4905              LDR      r1,|L31.24|
;;;388    	{
000002  b510              PUSH     {r4,lr}
;;;389    	MT_uint8 ret;
;;;390    
;;;391    	/* init board transfer */
;;;392    	PLATFORM_Open();
;;;393    
;;;394    	/* send command and/or address */
;;;395    	PLATFORM_SendCmd(CMD_RESET);
000004  20ff              MOVS     r0,#0xff
000006  7008              STRB     r0,[r1,#0]
;;;396    
;;;397    	/* wait (see datasheet for details) */
;;;398    	PLATFORM_Wait(TIME_WB);
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       PLATFORM_Wait
;;;399    	ret = __wait_for_ready();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      __wait_for_ready
;;;400    
;;;401    	/* close board transfer */
;;;402    	PLATFORM_Close();
;;;403    
;;;404    	return ret;
;;;405    	}
;;;406    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x70010000

                          AREA ||i.NAND_Set_Feature||, CODE, READONLY, ALIGN=2

                  NAND_Set_Feature PROC
;;;654    
;;;655    MT_uint8 NAND_Set_Feature(flash_width feature_address, flash_width subfeature)
000000  b510              PUSH     {r4,lr}
;;;656    	{
000002  460c              MOV      r4,r1
;;;657    	MT_uint8 ret;
;;;658    
;;;659    	/* verify if driver is initialized */
;;;660    	if(DRIVER_STATUS_INITIALIZED != driver_status)
000004  4910              LDR      r1,|L32.72|
000006  7809              LDRB     r1,[r1,#0]  ; driver_status
000008  b109              CBZ      r1,|L32.14|
;;;661    		return DRIVER_STATUS_NOT_INITIALIZED;
00000a  2001              MOVS     r0,#1
;;;662    
;;;663    	/* check if this feature/command is supported */
;;;664    	if ((device_info.command & OPTIONAL_CMD_GET_FEATURES_AND_SET_FEATURES) == 0)
;;;665    		return NAND_UNSUPPORTED;
;;;666    
;;;667    	/* init board transfer */
;;;668    	PLATFORM_Open();
;;;669    
;;;670    	/* send command and/or address */
;;;671    	PLATFORM_SendCmd(CMD_SET_FEATURE);
;;;672    	PLATFORM_SendAddr(feature_address);
;;;673    
;;;674    	/* wait (see datasheet for details) */
;;;675    	PLATFORM_Wait(TIME_ADL);
;;;676    
;;;677    	/* send sub-feature parameter */
;;;678    	PLATFORM_SendData(subfeature);	/* p0 */
;;;679    	PLATFORM_SendData(0x00);		/* p1 reserved */
;;;680    	PLATFORM_SendData(0x00);		/* p2 reserved */
;;;681    	PLATFORM_SendData(0x00);		/* p3 reserved */
;;;682    
;;;683    	PLATFORM_Wait(TIME_WB);
;;;684    	ret = __wait_for_ready();
;;;685    
;;;686        /* return if timeout */
;;;687    	if (NAND_SUCCESS != ret)
;;;688    		return ret;
;;;689    
;;;690    	/* close board transfer */
;;;691    	PLATFORM_Close();
;;;692    
;;;693    	return ret;
;;;694    	}
00000c  bd10              POP      {r4,pc}
                  |L32.14|
00000e  490f              LDR      r1,|L32.76|
000010  7a89              LDRB     r1,[r1,#0xa]          ;664  ; device_info
000012  0749              LSLS     r1,r1,#29             ;664
000014  d401              BMI      |L32.26|
000016  20fd              MOVS     r0,#0xfd              ;665
000018  bd10              POP      {r4,pc}
                  |L32.26|
00001a  4a0d              LDR      r2,|L32.80|
00001c  21ef              MOVS     r1,#0xef              ;671
00001e  7011              STRB     r1,[r2,#0]            ;671
000020  490c              LDR      r1,|L32.84|
000022  7008              STRB     r0,[r1,#0]            ;671
000024  2046              MOVS     r0,#0x46              ;675
000026  f7fffffe          BL       PLATFORM_Wait
00002a  f04f40e0          MOV      r0,#0x70000000        ;675
00002e  7004              STRB     r4,[r0,#0]            ;675
000030  2100              MOVS     r1,#0                 ;679
000032  7001              STRB     r1,[r0,#0]            ;679
000034  7001              STRB     r1,[r0,#0]            ;679
000036  7001              STRB     r1,[r0,#0]            ;679
000038  2064              MOVS     r0,#0x64              ;683
00003a  f7fffffe          BL       PLATFORM_Wait
00003e  e8bd4010          POP      {r4,lr}               ;684
000042  f7ffbffe          B.W      __wait_for_ready
;;;695    
                          ENDP

000046  0000              DCW      0x0000
                  |L32.72|
                          DCD      ||.data||
                  |L32.76|
                          DCD      ||.bss||+0x38
                  |L32.80|
                          DCD      0x70010000
                  |L32.84|
                          DCD      0x70020000

                          AREA ||i.NAND_Spare_Program||, CODE, READONLY, ALIGN=2

                  NAND_Spare_Program PROC
;;;1252   
;;;1253   MT_uint8 NAND_Spare_Program(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1254   	{
000004  4606              MOV      r6,r0
000006  e9dd450a          LDRD     r4,r5,[sp,#0x28]
;;;1255   	MT_uint8 address[5];
;;;1256   	MT_uint8 status_reg;
;;;1257   	MT_uint32 k;
;;;1258   	int i;
;;;1259   	flash_width *pData;
;;;1260   
;;;1261   	/* verify if driver is initialized */
;;;1262   	if( DRIVER_STATUS_INITIALIZED != driver_status )
00000a  4825              LDR      r0,|L33.160|
00000c  4688              MOV      r8,r1                 ;1254
00000e  4691              MOV      r9,r2                 ;1254
000010  7800              LDRB     r0,[r0,#0]  ; driver_status
000012  b110              CBZ      r0,|L33.26|
;;;1263   		return DRIVER_STATUS_NOT_INITIALIZED;
000014  2001              MOVS     r0,#1
                  |L33.22|
;;;1264   
;;;1265   	/* check input parameters */
;;;1266   	if( NAND_SUCCESS != __is_valid_addr(addr) )
;;;1267   		return NAND_INVALID_NAND_ADDRESS;
;;;1268   
;;;1269   	if( (device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0 )
;;;1270   		{
;;;1271   		/* x16 */
;;;1272   		if( lenght > (device_info.spare_bytes_per_page >> 1) )
;;;1273   			return NAND_INVALID_LENGHT;
;;;1274   		}
;;;1275   	/* x8 */
;;;1276   	else if( lenght > device_info.spare_bytes_per_page )
;;;1277   		return NAND_INVALID_LENGHT;
;;;1278   
;;;1279   	/* spare area starts after last main area byte */
;;;1280   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) == 0)
;;;1281   		/* x8 bus width */
;;;1282   		addr.column=device_info.data_bytes_per_page;
;;;1283   	else
;;;1284   		/* x16 bus width */
;;;1285   		addr.column=device_info.data_bytes_per_page >> 1;
;;;1286   
;;;1287   	__build_cycle_addr(addr, address);
;;;1288   
;;;1289   	/* init board transfer */
;;;1290   	PLATFORM_Open();
;;;1291   
;;;1292   	/* send command */
;;;1293   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM);
;;;1294   
;;;1295   	/* send address */
;;;1296   	for( i = 0; i < NUM_OF_ADDR_CYCLE; i++ )
;;;1297   		PLATFORM_SendAddr( address[ i ] );
;;;1298   
;;;1299   	/* send data */
;;;1300   	pData = buffer;
;;;1301   	for( k = 0; k < lenght; k++ )
;;;1302   		{
;;;1303   		//PLATFORM_SendData(buffer[k]);
;;;1304   		PLATFORM_SendData( *pData );
;;;1305   		pData++;
;;;1306   		#warning: "KOCTUJIb"
;;;1307   		if( k % 128 == 0 )
;;;1308   			CORE_threadGetData();
;;;1309   		}
;;;1310   
;;;1311   	/* send command */
;;;1312   	PLATFORM_SendCmd(CMD_PAGE_PROGRAM_CONFIRM);
;;;1313   
;;;1314   	status_reg = NAND_Read_Status();
;;;1315   
;;;1316   	/* close board transfer */
;;;1317   	PLATFORM_Close();
;;;1318   
;;;1319   	/* check if program is good */
;;;1320   	if( !(status_reg & STATUS_WRITE_PROTECTED) )
;;;1321   		return NAND_PROGRAM_FAILED_WRITE_PROTECT;
;;;1322   
;;;1323   	if( status_reg & STATUS_FAIL )
;;;1324   		return NAND_PROGRAM_FAILED;
;;;1325   
;;;1326   	return NAND_SUCCESS;
;;;1327   	}
000016  e8bd83fe          POP      {r1-r9,pc}
                  |L33.26|
00001a  4630              MOV      r0,r6                 ;1266
00001c  f7fffffe          BL       __is_valid_addr
000020  b108              CBZ      r0,|L33.38|
000022  2030              MOVS     r0,#0x30              ;1267
000024  e7f7              B        |L33.22|
                  |L33.38|
000026  491f              LDR      r1,|L33.164|
000028  7a08              LDRB     r0,[r1,#8]            ;1269  ; device_info
00002a  07c0              LSLS     r0,r0,#31             ;1269
00002c  8f08              LDRH     r0,[r1,#0x38]         ;1276  ; device_info
00002e  d003              BEQ      |L33.56|
000030  ebb50f50          CMP      r5,r0,LSR #1          ;1272
000034  d802              BHI      |L33.60|
000036  e005              B        |L33.68|
                  |L33.56|
000038  42a8              CMP      r0,r5                 ;1276
00003a  d201              BCS      |L33.64|
                  |L33.60|
00003c  2031              MOVS     r0,#0x31              ;1277
00003e  e7ea              B        |L33.22|
                  |L33.64|
000040  6b4b              LDR      r3,[r1,#0x34]         ;1282  ; device_info
000042  e001              B        |L33.72|
                  |L33.68|
000044  6b48              LDR      r0,[r1,#0x34]         ;1285  ; device_info
000046  0843              LSRS     r3,r0,#1              ;1285
                  |L33.72|
000048  af01              ADD      r7,sp,#4              ;1287
00004a  464a              MOV      r2,r9                 ;1287
00004c  4641              MOV      r1,r8                 ;1287
00004e  4630              MOV      r0,r6                 ;1287
000050  9700              STR      r7,[sp,#0]            ;1287
000052  f7fffffe          BL       __build_cycle_addr
000056  4e14              LDR      r6,|L33.168|
000058  2080              MOVS     r0,#0x80              ;1293
00005a  7030              STRB     r0,[r6,#0]            ;1293
00005c  4a13              LDR      r2,|L33.172|
00005e  2000              MOVS     r0,#0                 ;1296
                  |L33.96|
000060  5c39              LDRB     r1,[r7,r0]            ;1297
000062  7011              STRB     r1,[r2,#0]            ;1297
000064  1c40              ADDS     r0,r0,#1              ;1297
000066  2805              CMP      r0,#5                 ;1296
000068  dbfa              BLT      |L33.96|
00006a  2700              MOVS     r7,#0                 ;1301
00006c  f04f48e0          MOV      r8,#0x70000000        ;1301
000070  e009              B        |L33.134|
000072  bf00              NOP                            ;1304
                  |L33.116|
000074  f8140b01          LDRB     r0,[r4],#1            ;1304
000078  f8880000          STRB     r0,[r8,#0]            ;1304
00007c  0678              LSLS     r0,r7,#25             ;1307
00007e  d101              BNE      |L33.132|
000080  f7fffffe          BL       CORE_threadGetData
                  |L33.132|
000084  1c7f              ADDS     r7,r7,#1              ;1308
                  |L33.134|
000086  42af              CMP      r7,r5                 ;1301
000088  d3f4              BCC      |L33.116|
00008a  2010              MOVS     r0,#0x10              ;1312
00008c  7030              STRB     r0,[r6,#0]            ;1312
00008e  f7fffffe          BL       NAND_Read_Status
000092  0600              LSLS     r0,r0,#24             ;1320
000094  d401              BMI      |L33.154|
000096  2051              MOVS     r0,#0x51              ;1321
000098  e7bd              B        |L33.22|
                  |L33.154|
00009a  2000              MOVS     r0,#0                 ;1326
00009c  e7bb              B        |L33.22|
;;;1328   
                          ENDP

00009e  0000              DCW      0x0000
                  |L33.160|
                          DCD      ||.data||
                  |L33.164|
                          DCD      ||.bss||+0x38
                  |L33.168|
                          DCD      0x70010000
                  |L33.172|
                          DCD      0x70020000

                          AREA ||i.NAND_Spare_Read||, CODE, READONLY, ALIGN=2

                  NAND_Spare_Read PROC
;;;1150   
;;;1151   MT_uint8 NAND_Spare_Read(nand_addr_t addr, flash_width *buffer, MT_uint32 lenght) 
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1152   	{
000004  4606              MOV      r6,r0
000006  e9dd450a          LDRD     r4,r5,[sp,#0x28]
;;;1153   	MT_uint8 row_address[5];
;;;1154   	MT_uint8 status_reg;
;;;1155   	MT_uint8 ret;
;;;1156   	MT_uint32 k;
;;;1157   	int i;
;;;1158   	flash_width *pData;
;;;1159   
;;;1160   	/* verify if driver is initialized */
;;;1161   	if(DRIVER_STATUS_INITIALIZED != driver_status)
00000a  4821              LDR      r0,|L34.144|
00000c  4688              MOV      r8,r1                 ;1152
00000e  4691              MOV      r9,r2                 ;1152
000010  7800              LDRB     r0,[r0,#0]  ; driver_status
000012  b110              CBZ      r0,|L34.26|
;;;1162   		return DRIVER_STATUS_NOT_INITIALIZED;
000014  2001              MOVS     r0,#1
                  |L34.22|
;;;1163   
;;;1164   	/* check input parameters */
;;;1165   	if(NAND_SUCCESS != __is_valid_addr(addr))
;;;1166   		return NAND_INVALID_NAND_ADDRESS;
;;;1167   
;;;1168   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) != 0) {
;;;1169   		/* x16 */
;;;1170   		if(lenght > (device_info.spare_bytes_per_page >> 1) )
;;;1171   			return NAND_INVALID_LENGHT;
;;;1172   	}
;;;1173   
;;;1174   	/* x8 */
;;;1175   	else if(lenght > device_info.spare_bytes_per_page)
;;;1176   		return NAND_INVALID_LENGHT;
;;;1177   
;;;1178   	/* spare area starts after last main area byte */
;;;1179   	if((device_info.feature & SUPPORTED_16_BIT_DATA_BUS_WIDTH) == 0)
;;;1180   		/* x8 bus width */
;;;1181   		addr.column=device_info.data_bytes_per_page;
;;;1182   	else
;;;1183   		/* x16 bus width */
;;;1184   		addr.column=device_info.data_bytes_per_page >> 1;
;;;1185   
;;;1186   	__build_cycle_addr(addr, row_address);
;;;1187   
;;;1188   	/* init board transfer */
;;;1189   	PLATFORM_Open();
;;;1190   
;;;1191   	/* send command */
;;;1192   	PLATFORM_SendCmd(CMD_READ_MODE);
;;;1193   
;;;1194   	/* send address */
;;;1195   	for( i = 0; i < NUM_OF_ADDR_CYCLE; i++ )
;;;1196   		PLATFORM_SendAddr( row_address[i] );
;;;1197   
;;;1198   	/* return to read mode */
;;;1199   	PLATFORM_SendCmd(CMD_READ_CONFIRM);
;;;1200   
;;;1201   	/* wait */
;;;1202   	ret = __wait_for_ready();
;;;1203   
;;;1204   	/* return if timeout */
;;;1205   	if (NAND_SUCCESS != ret)
;;;1206   		return ret;
;;;1207   
;;;1208   	/* read data */
;;;1209   	pData = buffer;
;;;1210   	for( k = 0; k < lenght; k++ )
;;;1211   		*pData++ = PLATFORM_ReadData();
;;;1212   		//buffer[k] = PLATFORM_ReadData();
;;;1213   
;;;1214   	/* read status register on exit */
;;;1215   	status_reg = NAND_Read_Status();
;;;1216   
;;;1217   	/* close board transfer */
;;;1218   	PLATFORM_Close();
;;;1219   
;;;1220   	if(status_reg & STATUS_FAIL)
;;;1221   		return NAND_READ_FAILED;
;;;1222   
;;;1223   	return ret;
;;;1224   }
000016  e8bd83fe          POP      {r1-r9,pc}
                  |L34.26|
00001a  4630              MOV      r0,r6                 ;1165
00001c  f7fffffe          BL       __is_valid_addr
000020  b108              CBZ      r0,|L34.38|
000022  2030              MOVS     r0,#0x30              ;1166
000024  e7f7              B        |L34.22|
                  |L34.38|
000026  491b              LDR      r1,|L34.148|
000028  7a08              LDRB     r0,[r1,#8]            ;1168  ; device_info
00002a  07c0              LSLS     r0,r0,#31             ;1168
00002c  8f08              LDRH     r0,[r1,#0x38]         ;1175  ; device_info
00002e  d003              BEQ      |L34.56|
000030  ebb50f50          CMP      r5,r0,LSR #1          ;1170
000034  d802              BHI      |L34.60|
000036  e005              B        |L34.68|
                  |L34.56|
000038  42a8              CMP      r0,r5                 ;1175
00003a  d201              BCS      |L34.64|
                  |L34.60|
00003c  2031              MOVS     r0,#0x31              ;1176
00003e  e7ea              B        |L34.22|
                  |L34.64|
000040  6b4b              LDR      r3,[r1,#0x34]         ;1181  ; device_info
000042  e001              B        |L34.72|
                  |L34.68|
000044  6b48              LDR      r0,[r1,#0x34]         ;1184  ; device_info
000046  0843              LSRS     r3,r0,#1              ;1184
                  |L34.72|
000048  af01              ADD      r7,sp,#4              ;1186
00004a  464a              MOV      r2,r9                 ;1186
00004c  4641              MOV      r1,r8                 ;1186
00004e  4630              MOV      r0,r6                 ;1186
000050  9700              STR      r7,[sp,#0]            ;1186
000052  f7fffffe          BL       __build_cycle_addr
000056  4910              LDR      r1,|L34.152|
000058  2000              MOVS     r0,#0                 ;1192
00005a  7008              STRB     r0,[r1,#0]            ;1192
00005c  4b0f              LDR      r3,|L34.156|
                  |L34.94|
00005e  5c3a              LDRB     r2,[r7,r0]            ;1196
000060  701a              STRB     r2,[r3,#0]            ;1196
000062  1c40              ADDS     r0,r0,#1              ;1196
000064  2805              CMP      r0,#5                 ;1195
000066  dbfa              BLT      |L34.94|
000068  2030              MOVS     r0,#0x30              ;1199
00006a  7008              STRB     r0,[r1,#0]            ;1199
00006c  f7fffffe          BL       __wait_for_ready
000070  0006              MOVS     r6,r0                 ;1202
000072  d1d0              BNE      |L34.22|
000074  f04f42e0          MOV      r2,#0x70000000        ;1205
000078  e003              B        |L34.130|
                  |L34.122|
00007a  7811              LDRB     r1,[r2,#0]            ;1210
00007c  f8041b01          STRB     r1,[r4],#1            ;1211
000080  1c40              ADDS     r0,r0,#1              ;1211
                  |L34.130|
000082  42a8              CMP      r0,r5                 ;1210
000084  d3f9              BCC      |L34.122|
000086  f7fffffe          BL       NAND_Read_Status
00008a  4630              MOV      r0,r6                 ;1223
00008c  e7c3              B        |L34.22|
;;;1225   
                          ENDP

00008e  0000              DCW      0x0000
                  |L34.144|
                          DCD      ||.data||
                  |L34.148|
                          DCD      ||.bss||+0x38
                  |L34.152|
                          DCD      0x70010000
                  |L34.156|
                          DCD      0x70020000

                          AREA ||i.NAND_Unlock||, CODE, READONLY, ALIGN=2

                  NAND_Unlock PROC
;;;1627   
;;;1628   MT_uint8 NAND_Unlock(nand_addr_t start_block, nand_addr_t end_block) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b088              SUB      sp,sp,#0x20
000006  4680              MOV      r8,r0
000008  a811              ADD      r0,sp,#0x44
00000a  4689              MOV      r9,r1
00000c  e89000f0          LDM      r0,{r4-r7}
;;;1629   	MT_uint8 start_address_stream[NUM_OF_ADDR_CYCLE];
;;;1630   	MT_uint8 end_address_stream[NUM_OF_ADDR_CYCLE];
;;;1631   
;;;1632   	/* verify if driver is initialized */
;;;1633   	if(DRIVER_STATUS_INITIALIZED != driver_status)
000010  4825              LDR      r0,|L35.168|
000012  4692              MOV      r10,r2                ;1628
000014  469b              MOV      r11,r3                ;1628
000016  7800              LDRB     r0,[r0,#0]  ; driver_status
000018  b118              CBZ      r0,|L35.34|
;;;1634   		return DRIVER_STATUS_NOT_INITIALIZED;
00001a  2001              MOVS     r0,#1
                  |L35.28|
;;;1635   
;;;1636   	/* check input parameters */
;;;1637   	if((NAND_SUCCESS != __is_valid_addr(start_block)) || (NAND_SUCCESS != __is_valid_addr(end_block)))
;;;1638   		return NAND_INVALID_NAND_ADDRESS;
;;;1639   
;;;1640   	/* verify if start_block < end_block */
;;;1641   	if(ADDR_A_GT_B == __compare_addr(start_block, end_block) )
;;;1642   		return NAND_INVALID_NAND_ADDRESS;
;;;1643   
;;;1644   	/* build address cycles for start and end block */
;;;1645   	__build_cycle_addr(start_block, start_address_stream);
;;;1646   	__build_cycle_addr(end_block, end_address_stream);
;;;1647   
;;;1648   	/* init board transfer */
;;;1649   	PLATFORM_Open();
;;;1650   
;;;1651   	/* send command */
;;;1652   	PLATFORM_SendCmd(CMD_BLOCK_UNLOCK_LOW);
;;;1653   
;;;1654   	/* send row address (3rd, 4th, 5th cycle) */
;;;1655   	PLATFORM_SendAddr(start_address_stream[2]);
;;;1656   	PLATFORM_SendAddr(start_address_stream[3]);
;;;1657   	PLATFORM_SendAddr(start_address_stream[4]);
;;;1658   
;;;1659   	/* send command */
;;;1660   	PLATFORM_SendCmd(CMD_BLOCK_UNLOCK_HIGH);
;;;1661   
;;;1662   	/* send row address (3rd, 4th, 5th cycle) */
;;;1663   	PLATFORM_SendAddr(end_address_stream[2]);
;;;1664   	PLATFORM_SendAddr(end_address_stream[3]);
;;;1665   	PLATFORM_SendAddr(end_address_stream[4]);
;;;1666   
;;;1667   	/* close board transfer */
;;;1668   	PLATFORM_Close();
;;;1669   
;;;1670   	return NAND_SUCCESS;
;;;1671   
;;;1672   }
00001c  b008              ADD      sp,sp,#0x20
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L35.34|
000022  4640              MOV      r0,r8                 ;1637
000024  f7fffffe          BL       __is_valid_addr
000028  bbd0              CBNZ     r0,|L35.160|
00002a  463b              MOV      r3,r7                 ;1637
00002c  4632              MOV      r2,r6                 ;1637
00002e  4629              MOV      r1,r5                 ;1637
000030  4620              MOV      r0,r4                 ;1637
000032  f7fffffe          BL       __is_valid_addr
000036  bb98              CBNZ     r0,|L35.160|
000038  e88d00f0          STM      sp,{r4-r7}            ;1641
00003c  465b              MOV      r3,r11                ;1641
00003e  4652              MOV      r2,r10                ;1641
000040  4649              MOV      r1,r9                 ;1641
000042  4640              MOV      r0,r8                 ;1641
000044  f7fffffe          BL       __compare_addr
000048  2802              CMP      r0,#2                 ;1641
00004a  d02a              BEQ      |L35.162|
00004c  a804              ADD      r0,sp,#0x10           ;1645
00004e  9000              STR      r0,[sp,#0]            ;1645
000050  465b              MOV      r3,r11                ;1645
000052  4652              MOV      r2,r10                ;1645
000054  4649              MOV      r1,r9                 ;1645
000056  4640              MOV      r0,r8                 ;1645
000058  f7fffffe          BL       __build_cycle_addr
00005c  a806              ADD      r0,sp,#0x18           ;1646
00005e  9000              STR      r0,[sp,#0]            ;1646
000060  463b              MOV      r3,r7                 ;1646
000062  4632              MOV      r2,r6                 ;1646
000064  4629              MOV      r1,r5                 ;1646
000066  4620              MOV      r0,r4                 ;1646
000068  f7fffffe          BL       __build_cycle_addr
00006c  490f              LDR      r1,|L35.172|
00006e  2023              MOVS     r0,#0x23              ;1652
000070  7008              STRB     r0,[r1,#0]            ;1652
000072  480f              LDR      r0,|L35.176|
000074  f89d2012          LDRB     r2,[sp,#0x12]         ;1655
000078  7002              STRB     r2,[r0,#0]            ;1655
00007a  f89d2013          LDRB     r2,[sp,#0x13]         ;1656
00007e  7002              STRB     r2,[r0,#0]            ;1656
000080  f89d2014          LDRB     r2,[sp,#0x14]         ;1657
000084  7002              STRB     r2,[r0,#0]            ;1657
000086  2224              MOVS     r2,#0x24              ;1660
000088  700a              STRB     r2,[r1,#0]            ;1660
00008a  f89d101a          LDRB     r1,[sp,#0x1a]         ;1663
00008e  7001              STRB     r1,[r0,#0]            ;1663
000090  f89d101b          LDRB     r1,[sp,#0x1b]         ;1664
000094  7001              STRB     r1,[r0,#0]            ;1664
000096  f89d101c          LDRB     r1,[sp,#0x1c]         ;1665
00009a  7001              STRB     r1,[r0,#0]            ;1665
00009c  2000              MOVS     r0,#0                 ;1670
00009e  e7bd              B        |L35.28|
                  |L35.160|
0000a0  e7ff              B        |L35.162|
                  |L35.162|
0000a2  2030              MOVS     r0,#0x30              ;1642
0000a4  e7ba              B        |L35.28|
;;;1673   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L35.168|
                          DCD      ||.data||
                  |L35.172|
                          DCD      0x70010000
                  |L35.176|
                          DCD      0x70020000

                          AREA ||i.NAND_Unlock_Down||, CODE, READONLY, ALIGN=1

                  NAND_Unlock_Down PROC
;;;1742    */
;;;1743   MT_uint8 NAND_Unlock_Down(void) {
000000  20ff              MOVS     r0,#0xff
;;;1744   
;;;1745   	/*
;;;1746   	 * TO BE IMPLEMENTED
;;;1747   	 *
;;;1748   	 * Please contact Micron support for any request
;;;1749   	 */
;;;1750   
;;;1751   	return NAND_UNIMPLEMENTED;
;;;1752   
;;;1753   }
000002  4770              BX       lr
;;;1754   
                          ENDP


                          AREA ||i.PLATFORM_Close||, CODE, READONLY, ALIGN=1

                  PLATFORM_Close PROC
;;;341    */
;;;342    void PLATFORM_Close(void)
000000  4770              BX       lr
;;;343    	{
;;;344    	}
;;;345    
                          ENDP


                          AREA ||i.PLATFORM_Init||, CODE, READONLY, ALIGN=2

                  PLATFORM_Init PROC
;;;95     
;;;96     void PLATFORM_Init(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;97     {
;;;98     	 GPIO_InitTypeDef GPIO_InitStruct;
;;;99        FSMC_NAND_PCC_TimingTypeDef NAND_Timing;
;;;100    
;;;101    	  /* GPIO Ports Clock Enable */
;;;102      __GPIOH_CLK_ENABLE();
000004  4848              LDR      r0,|L38.296|
000006  b089              SUB      sp,sp,#0x24           ;97
000008  6801              LDR      r1,[r0,#0]
00000a  f0410180          ORR      r1,r1,#0x80
00000e  6001              STR      r1,[r0,#0]
;;;103      __GPIOE_CLK_ENABLE();
000010  6801              LDR      r1,[r0,#0]
000012  f0410110          ORR      r1,r1,#0x10
000016  6001              STR      r1,[r0,#0]
;;;104      __GPIOD_CLK_ENABLE();
000018  6801              LDR      r1,[r0,#0]
00001a  f0410108          ORR      r1,r1,#8
00001e  6001              STR      r1,[r0,#0]
;;;105      __GPIOA_CLK_ENABLE();
000020  6801              LDR      r1,[r0,#0]
000022  f0410101          ORR      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
;;;106      __GPIOG_CLK_ENABLE();
000028  6801              LDR      r1,[r0,#0]
00002a  f0410140          ORR      r1,r1,#0x40
00002e  6001              STR      r1,[r0,#0]
;;;107    
;;;108       /** FSMC GPIO Configuration
;;;109      PE7   ------> FSMC_D4
;;;110      PE8   ------> FSMC_D5
;;;111      PE9   ------> FSMC_D6
;;;112      PE10   ------> FSMC_D7
;;;113      PD11   ------> FSMC_CLE
;;;114      PD12   ------> FSMC_ALE
;;;115      PD14   ------> FSMC_D0
;;;116      PD15   ------> FSMC_D1
;;;117      PD0   ------> FSMC_D2
;;;118      PD1   ------> FSMC_D3
;;;119      PD4   ------> FSMC_NOE
;;;120      PD5   ------> FSMC_NWE
;;;121      PD6   ------> FSMC_NWAIT
;;;122      PD7   ------> FSMC_NCE2
;;;123      PG9   ------> FSMC_NCE3
;;;124      */
;;;125      GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
000030  f44f60f0          MOV      r0,#0x780
;;;126      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
000034  2402              MOVS     r4,#2
;;;127      GPIO_InitStruct.Pull = GPIO_NOPULL;
000036  2600              MOVS     r6,#0
;;;128      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;129      GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;130      HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
000038  e88d0051          STM      sp,{r0,r4,r6}
00003c  2503              MOVS     r5,#3                 ;128
00003e  270c              MOVS     r7,#0xc               ;129
000040  e9cd5703          STRD     r5,r7,[sp,#0xc]
000044  4669              MOV      r1,sp
000046  4839              LDR      r0,|L38.300|
000048  f7fffffe          BL       HAL_GPIO_Init
;;;131    
;;;132      GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
00004c  f24c0003          MOV      r0,#0xc003
;;;133      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;134      GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;135      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;136      GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;137      HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
000050  e88d0051          STM      sp,{r0,r4,r6}
000054  f8dfb0d8          LDR      r11,|L38.304|
000058  e9cd5703          STRD     r5,r7,[sp,#0xc]
00005c  4669              MOV      r1,sp
00005e  4658              MOV      r0,r11
000060  f7fffffe          BL       HAL_GPIO_Init
;;;138    
;;;139    
;;;140      GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_4|GPIO_PIN_5;
000064  f6410030          MOV      r0,#0x1830
;;;141      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;142      GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;143      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;144      GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;145      HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
000068  e88d0051          STM      sp,{r0,r4,r6}
00006c  e9cd5703          STRD     r5,r7,[sp,#0xc]
000070  4669              MOV      r1,sp
000072  4658              MOV      r0,r11
000074  f7fffffe          BL       HAL_GPIO_Init
;;;146    
;;;147      GPIO_InitStruct.Pin = GPIO_PIN_6;
000078  f04f0940          MOV      r9,#0x40
;;;148      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;149      GPIO_InitStruct.Pull = GPIO_PULLUP;
00007c  f04f0801          MOV      r8,#1
;;;150      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;151    	GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;152      HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
000080  f8cd9000          STR      r9,[sp,#0]
000084  e9cd4801          STRD     r4,r8,[sp,#4]
000088  e9cd5703          STRD     r5,r7,[sp,#0xc]
00008c  4669              MOV      r1,sp
00008e  4658              MOV      r0,r11
000090  f7fffffe          BL       HAL_GPIO_Init
;;;153    
;;;154    #if !defined( USB_HARDWARE_FS	)
;;;155    	// Some engineer thinks that it's wery cool and usefull
;;;156    	// to change pins with out reasone.
;;;157    	// So, in new hardware R/B pin migrate from PortD to PortG.
;;;158    	// Also there is a bug. I don't know exactly were. It might be nand_mt29F_lld or MC core...
;;;159    	// Anyway we must to configurate PortD Pin6, and if we need other Pin to detect R/B
;;;160    	// we must to configurate it additionaly.
;;;161    	// Like here.
;;;162      GPIO_InitStruct.Pin = GPIO_PIN_6;
;;;163      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;164      GPIO_InitStruct.Pull = GPIO_PULLUP;
;;;165      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;166    	GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;167      HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
000094  f8cd9000          STR      r9,[sp,#0]
000098  e9cd4801          STRD     r4,r8,[sp,#4]
00009c  e9cd5703          STRD     r5,r7,[sp,#0xc]
0000a0  4669              MOV      r1,sp
0000a2  4824              LDR      r0,|L38.308|
0000a4  f7fffffe          BL       HAL_GPIO_Init
;;;168    #endif
;;;169    
;;;170      GPIO_InitStruct.Pin = GPIO_PIN_7;
0000a8  f04f0a80          MOV      r10,#0x80
;;;171      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;172      GPIO_InitStruct.Pull = GPIO_NOPULL ;
;;;173      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;174    	GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;175      HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
0000ac  f8cda000          STR      r10,[sp,#0]
0000b0  e9cd4601          STRD     r4,r6,[sp,#4]
0000b4  e9cd5703          STRD     r5,r7,[sp,#0xc]
0000b8  4669              MOV      r1,sp
0000ba  4658              MOV      r0,r11
0000bc  f7fffffe          BL       HAL_GPIO_Init
;;;176    
;;;177    //	GPIO_InitStruct.Pin = GPIO_PIN_9;
;;;178    //  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;179    //  GPIO_InitStruct.Pull = GPIO_NOPULL ;
;;;180    //  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;181    //	GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
;;;182    //  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
;;;183    
;;;184    	GPIO_InitStruct.Pin = GPIO_PIN_3;
0000c0  2008              MOVS     r0,#8
0000c2  e9cd0800          STRD     r0,r8,[sp,#0]
;;;185      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
;;;186      GPIO_InitStruct.Pull = GPIO_PULLUP;
;;;187      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;188      HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
0000c6  e9cd8502          STRD     r8,r5,[sp,#8]
0000ca  4669              MOV      r1,sp
0000cc  4658              MOV      r0,r11
0000ce  f7fffffe          BL       HAL_GPIO_Init
;;;189    
;;;190    	HAL_GPIO_WritePin(GPIOD,GPIO_PIN_3,GPIO_PIN_SET);
0000d2  2201              MOVS     r2,#1
0000d4  2108              MOVS     r1,#8
0000d6  4658              MOV      r0,r11
0000d8  f7fffffe          BL       HAL_GPIO_WritePin
;;;191    
;;;192    	__FSMC_CLK_ENABLE();
0000dc  4812              LDR      r0,|L38.296|
0000de  3008              ADDS     r0,r0,#8
0000e0  6801              LDR      r1,[r0,#0]
0000e2  f0410101          ORR      r1,r1,#1
0000e6  6001              STR      r1,[r0,#0]
;;;193    
;;;194    	nandHandle.Instance  = FSMC_NAND_DEVICE;
0000e8  4814              LDR      r0,|L38.316|
0000ea  4913              LDR      r1,|L38.312|
;;;195      /*NAND Configuration */
;;;196      NAND_Timing.SetupTime     = 0x01;
;;;197      NAND_Timing.WaitSetupTime = 0x03;
;;;198      NAND_Timing.HoldSetupTime = 0x02;
;;;199      NAND_Timing.HiZSetupTime  = 0x01;
;;;200    
;;;201      nandHandle.Init.NandBank        = FSMC_NAND_BANK2;
;;;202      nandHandle.Init.Waitfeature     = FSMC_NAND_PCC_WAIT_FEATURE_ENABLE;
;;;203      nandHandle.Init.MemoryDataWidth = FSMC_NAND_PCC_MEM_BUS_WIDTH_8;
;;;204      nandHandle.Init.EccComputation  = FSMC_NAND_ECC_ENABLE;
;;;205      nandHandle.Init.ECCPageSize     = FSMC_NAND_ECC_PAGE_SIZE_4096BYTE;
;;;206      nandHandle.Init.TCLRSetupTime   = 0;
;;;207      nandHandle.Init.TARSetupTime    = 0;
;;;208    
;;;209      nandHandle.Info.PageSize=4096;       /*!< NAND memory page (without spare area) size measured in K. bytes */
;;;210      nandHandle.Info.SpareAreaSize=224;  /*!< NAND memory spare area size measured in K. bytes                */
0000ec  22e0              MOVS     r2,#0xe0
0000ee  c002              STM      r0!,{r1}              ;194  ; nandHandle
0000f0  e9cd8505          STRD     r8,r5,[sp,#0x14]      ;194
0000f4  e9cd4807          STRD     r4,r8,[sp,#0x1c]      ;194
0000f8  2110              MOVS     r1,#0x10              ;201
0000fa  e8a00252          STM      r0!,{r1,r4,r6,r9}     ;201
0000fe  03c9              LSLS     r1,r1,#15             ;205
000100  e8601605          STRD     r1,r6,[r0],#-0x14     ;205
000104  f1000324          ADD      r3,r0,#0x24
000108  11c9              ASRS     r1,r1,#7              ;209
00010a  61c6              STR      r6,[r0,#0x1c]  ; nandHandle
00010c  e8830406          STM      r3,{r1,r2,r10}
;;;211      nandHandle.Info.BlockSize=128;      /*!< NAND memory block size number of pages                          */
;;;212      nandHandle.Info.BlockNbr=2048;       /*!< NAND memory number of blocks                                    */
000110  104a              ASRS     r2,r1,#1
000112  e9c0210c          STRD     r2,r1,[r0,#0x30]
;;;213      nandHandle.Info.ZoneSize=4096;       /*!< NAND memory zone size measured in number of blocks              */
;;;214    
;;;215    	HAL_NAND_Init(&nandHandle, &NAND_Timing, &NAND_Timing);
000116  aa05              ADD      r2,sp,#0x14
000118  4611              MOV      r1,r2
00011a  4808              LDR      r0,|L38.316|
00011c  f7fffffe          BL       HAL_NAND_Init
;;;216    }
000120  b009              ADD      sp,sp,#0x24
000122  e8bd8ff0          POP      {r4-r11,pc}
;;;217    
                          ENDP

000126  0000              DCW      0x0000
                  |L38.296|
                          DCD      0x40023830
                  |L38.300|
                          DCD      0x40021000
                  |L38.304|
                          DCD      0x40020c00
                  |L38.308|
                          DCD      0x40021800
                  |L38.312|
                          DCD      0xa0000060
                  |L38.316|
                          DCD      ||.bss||

                          AREA ||i.PLATFORM_Open||, CODE, READONLY, ALIGN=1

                  PLATFORM_Open PROC
;;;221    */
;;;222    void PLATFORM_Open(void)
000000  4770              BX       lr
;;;223    	{
;;;224    	//HAL_GPIO_WritePin(GPIOD,GPIO_PIN_7,GPIO_PIN_SET);
;;;225    	}
;;;226    
                          ENDP


                          AREA ||i.PLATFORM_ReadData||, CODE, READONLY, ALIGN=1

                  PLATFORM_ReadData PROC
;;;256    */
;;;257    bus_t PLATFORM_ReadData(void)
000000  f04f40e0          MOV      r0,#0x70000000
;;;258    	{
;;;259    	uint8_t Data;
;;;260    
;;;261    	Data = *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
000004  7800              LDRB     r0,[r0,#0]
;;;262    	return Data;
;;;263    	}
000006  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.PLATFORM_SendAddr||, CODE, READONLY, ALIGN=2

                  PLATFORM_SendAddr PROC
;;;238    */
;;;239    void PLATFORM_SendAddr(bus_t ubAddress)
000000  4901              LDR      r1,|L41.8|
;;;240    	{
;;;241    	*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ubAddress;
000002  7008              STRB     r0,[r1,#0]
;;;242    	}
000004  4770              BX       lr
;;;243    
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x70020000

                          AREA ||i.PLATFORM_SendCmd||, CODE, READONLY, ALIGN=2

                  PLATFORM_SendCmd PROC
;;;230    */
;;;231    void PLATFORM_SendCmd(bus_t ubCommand)
000000  4901              LDR      r1,|L42.8|
;;;232    	{
;;;233    	*(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = ubCommand;
000002  7008              STRB     r0,[r1,#0]
;;;234    	}
000004  4770              BX       lr
;;;235    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      0x70010000

                          AREA ||i.PLATFORM_SendData||, CODE, READONLY, ALIGN=1

                  PLATFORM_SendData PROC
;;;247    */
;;;248    void PLATFORM_SendData(bus_t data)
000000  f04f41e0          MOV      r1,#0x70000000
;;;249    	{
;;;250    	*(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = data;
000004  7008              STRB     r0,[r1,#0]
;;;251    	}
000006  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.PLATFORM_Wait||, CODE, READONLY, ALIGN=2

                  PLATFORM_Wait PROC
;;;327    
;;;328    void PLATFORM_Wait(int microseconds)
000000  b510              PUSH     {r4,lr}
;;;329    	{
;;;330    	//DWT_Delay(microseconds);
;;;331    #ifdef USB_HARDWARE_FS		
;;;332    	while( HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_6) == GPIO_PIN_RESET ){}
;;;333    #else
;;;334    	while( HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_6) == GPIO_PIN_RESET ){}
000002  4c04              LDR      r4,|L44.20|
                  |L44.4|
000004  2140              MOVS     r1,#0x40
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       HAL_GPIO_ReadPin
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L44.4|
;;;335    #endif
;;;336    	}
000010  bd10              POP      {r4,pc}
;;;337    
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40021800

                          AREA ||i.__as_string||, CODE, READONLY, ALIGN=1

                  __as_string PROC
;;;2411    */
;;;2412   void __as_string(MT_uint8 *src_ptr, char *dest_ptr, int start, int stop) {
000000  b570              PUSH     {r4-r6,lr}
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
;;;2413   	#ifdef LITTLE_ENDIAN
;;;2414   		strncpy((char *)dest_ptr, (const char *)src_ptr+start, stop-start+1);
000006  1b5e              SUBS     r6,r3,r5
000008  1941              ADDS     r1,r0,r5
00000a  1c72              ADDS     r2,r6,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       strncpy
;;;2415   		dest_ptr[stop-start+1] = '\0';
000012  2000              MOVS     r0,#0
000014  1931              ADDS     r1,r6,r4
000016  7048              STRB     r0,[r1,#1]
;;;2416   	#endif
;;;2417   	#ifdef BIG_ENDIAN
;;;2418   		strncpy((char *)dest_ptr, (const char *)src_ptr+start, stop-start+1);
;;;2419   		dest_ptr[stop-start+1] = '\0';
;;;2420   	#endif
;;;2421   }
000018  bd70              POP      {r4-r6,pc}
;;;2422   
                          ENDP


                          AREA ||i.__as_uint16||, CODE, READONLY, ALIGN=1

                  __as_uint16 PROC
;;;2388    */
;;;2389   MT_uint16 __as_uint16(MT_uint8 byte1, MT_uint8 byte0) {
000000  ea402001          ORR      r0,r0,r1,LSL #8
;;;2390   	#ifdef LITTLE_ENDIAN
;;;2391   		return ((MT_uint16) ((byte0 << 8) | byte1));
;;;2392   	#endif
;;;2393   	#ifdef BIG_ENDIAN
;;;2394   		return ((MT_uint16) ((byte1 << 8) | byte0));
;;;2395   	#endif
;;;2396   }
000004  4770              BX       lr
;;;2397   
                          ENDP


                          AREA ||i.__as_uint32||, CODE, READONLY, ALIGN=1

                  __as_uint32 PROC
;;;2400    */
;;;2401   MT_uint32 __as_uint32(MT_uint8 byte3, MT_uint8 byte2, MT_uint8 byte1, MT_uint8 byte0) {
000000  061b              LSLS     r3,r3,#24
;;;2402   	#ifdef LITTLE_ENDIAN
;;;2403   		return ((MT_uint32) ((byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3));
000002  ea434202          ORR      r2,r3,r2,LSL #16
000006  ea422101          ORR      r1,r2,r1,LSL #8
00000a  4308              ORRS     r0,r0,r1
;;;2404   	#endif
;;;2405   	#ifdef BIG_ENDIAN
;;;2406   		return ((MT_uint32) ((byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0));
;;;2407   	#endif
;;;2408   }
00000c  4770              BX       lr
;;;2409   /*
                          ENDP


                          AREA ||i.__build_cycle_addr||, CODE, READONLY, ALIGN=2

                  __build_cycle_addr PROC
;;;2425    */
;;;2426   void __build_cycle_addr(nand_addr_t addr, MT_uint8 *addr_cycle_stream) {
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2427   	#define LOW				0
;;;2428   	#define HIGH			1
;;;2429   
;;;2430   	/* extract n-th bit from a value */
;;;2431   	#define CHECK_BIT(val, n) ((val & (1 << n)) >> n)
;;;2432   
;;;2433   	/* extract from column address */
;;;2434   	#define COL(n) 			CHECK_BIT(addr.column, n)
;;;2435   
;;;2436   	/* extract from page address */
;;;2437   	#define PAGE(n) 		CHECK_BIT(addr.page, n)
;;;2438   
;;;2439   	/* extract from block address */
;;;2440   	#define BLOCK(n) 		CHECK_BIT(addr.block, n)
;;;2441   
;;;2442   	/* extract from lun number */
;;;2443   	#define LUN(n) 			CHECK_BIT(addr.lun, n)
;;;2444   
;;;2445   	/* build a single row of address cycle */
;;;2446   	#define BUILD_ADDR_ROW(i_07, i_06, i_05, i_04, i_03, i_02, i_01, i_00) (\
;;;2447   		 ((i_07) << 7) \
;;;2448   	   | ((i_06) << 6) \
;;;2449   	   | ((i_05) << 5) \
;;;2450   	   | ((i_04) << 4) \
;;;2451   	   | ((i_03) << 3) \
;;;2452   	   | ((i_02) << 2) \
;;;2453   	   | ((i_01) << 1) \
;;;2454   	   | ((i_00) << 0) \
;;;2455   	);
;;;2456   
;;;2457   	//int cycle;
;;;2458   
;;;2459   	/* build the address cycle stream (64 pages per block) */
;;;2460   	if (64 == device_info.pages_per_block) {
000004  4a3e              LDR      r2,|L48.256|
;;;2461   
;;;2462   		/* Col 1 - I cycle */
;;;2463   		addr_cycle_stream[0] =
;;;2464   				(MT_uint8) BUILD_ADDR_ROW(COL(7), COL(6), COL(5), COL(4), COL(3), COL(2), COL(1), COL(0));
;;;2465   
;;;2466   		/* Col 2 - II cycle */
;;;2467   		addr_cycle_stream[1] =
000006  f04f0e04          MOV      lr,#4
00000a  b2dc              UXTB     r4,r3                 ;2463
00000c  6c55              LDR      r5,[r2,#0x44]  ; device_info
00000e  2210              MOVS     r2,#0x10
000010  ea022613          AND      r6,r2,r3,LSR #8
000014  f3c33240          UBFX     r2,r3,#13,#1
000018  ea461242          ORR      r2,r6,r2,LSL #5
00001c  2608              MOVS     r6,#8
00001e  ea062613          AND      r6,r6,r3,LSR #8
000022  4332              ORRS     r2,r2,r6
000024  ea0e2613          AND      r6,lr,r3,LSR #8
000028  4332              ORRS     r2,r2,r6
00002a  2602              MOVS     r6,#2
00002c  ea062613          AND      r6,r6,r3,LSR #8
000030  4332              ORRS     r2,r2,r6
000032  f3c32300          UBFX     r3,r3,#8,#1
000036  431a              ORRS     r2,r2,r3
;;;2468   				(MT_uint8) BUILD_ADDR_ROW(LOW, LOW, COL(13), COL(12), COL(11), COL(10),COL(9),COL(8));
;;;2469   
;;;2470   		/* Row 1 - III cycle */
;;;2471   		addr_cycle_stream[2] =
000038  9b02              LDR      r3,[sp,#8]
00003a  4680              MOV      r8,r0                 ;2426
00003c  980d              LDR      r0,[sp,#0x34]         ;2460
00003e  f0030b20          AND      r11,r3,#0x20
000042  f0030a10          AND      r10,r3,#0x10
000046  f0030908          AND      r9,r3,#8
00004a  f0030704          AND      r7,r3,#4
00004e  f0030602          AND      r6,r3,#2
000052  f0030c01          AND      r12,r3,#1
;;;2472   				(MT_uint8) BUILD_ADDR_ROW(BLOCK(1), BLOCK(0), PAGE(5), PAGE(4), PAGE(3), PAGE(2), PAGE(1), PAGE(0));
;;;2473   
;;;2474   		/* Row 2 - IV cycle */
;;;2475   		addr_cycle_stream[3] =
;;;2476   				(MT_uint8) BUILD_ADDR_ROW(BLOCK(9), BLOCK(8), BLOCK(7), BLOCK(6), BLOCK(5), BLOCK(4), BLOCK(3), BLOCK(2));
;;;2477   
;;;2478   		/* Row 3 - V cycle */
;;;2479   		addr_cycle_stream[4] =
000056  f0080301          AND      r3,r8,#1
00005a  2d40              CMP      r5,#0x40              ;2460
00005c  d123              BNE      |L48.166|
00005e  ea4b1581          ORR      r5,r11,r1,LSL #6      ;2471
000062  ea45050a          ORR      r5,r5,r10             ;2471
000066  ea450509          ORR      r5,r5,r9              ;2471
00006a  433d              ORRS     r5,r5,r7              ;2471
00006c  7004              STRB     r4,[r0,#0]            ;2463
00006e  4335              ORRS     r5,r5,r6              ;2471
000070  7042              STRB     r2,[r0,#1]            ;2467
000072  ea45050c          ORR      r5,r5,r12             ;2471
000076  7085              STRB     r5,[r0,#2]            ;2471
000078  25fe              MOVS     r5,#0xfe              ;2475
00007a  ea050591          AND      r5,r5,r1,LSR #2       ;2475
00007e  f3c10880          UBFX     r8,r1,#2,#1           ;2475
000082  ea450508          ORR      r5,r5,r8              ;2475
000086  70c5              STRB     r5,[r0,#3]            ;2475
000088  ea0e2591          AND      r5,lr,r1,LSR #10
00008c  f04f0802          MOV      r8,#2
000090  ea4505c3          ORR      r5,r5,r3,LSL #3
000094  ea082891          AND      r8,r8,r1,LSR #10
000098  ea450508          ORR      r5,r5,r8
00009c  f3c12880          UBFX     r8,r1,#10,#1
0000a0  ea450508          ORR      r5,r5,r8
0000a4  7105              STRB     r5,[r0,#4]
                  |L48.166|
;;;2480   				(MT_uint8) BUILD_ADDR_ROW(LOW, LOW, LOW, LOW, LUN(0), BLOCK(12), BLOCK(11), BLOCK(10));
;;;2481   
;;;2482   	}
;;;2483   
;;;2484   	/* build the address cycle stream (128 pages per block) */
;;;2485   	if (128 == device_info.pages_per_block) {
0000a6  4d16              LDR      r5,|L48.256|
0000a8  6c6d              LDR      r5,[r5,#0x44]  ; device_info
0000aa  2d80              CMP      r5,#0x80
0000ac  d125              BNE      |L48.250|
;;;2486   
;;;2487   		/* Col 1 - I cycle */
;;;2488   		addr_cycle_stream[0] =
0000ae  7004              STRB     r4,[r0,#0]
;;;2489   				(MT_uint8) BUILD_ADDR_ROW(COL(7), COL(6), COL(5), COL(4), COL(3), COL(2), COL(1), COL(0));
;;;2490   
;;;2491   		/* Col 2 - II cycle */
;;;2492   		addr_cycle_stream[1] =
0000b0  7042              STRB     r2,[r0,#1]
;;;2493   				(MT_uint8) BUILD_ADDR_ROW(LOW, LOW, COL(13), COL(12), COL(11), COL(10),COL(9),COL(8));
;;;2494   
;;;2495   		/* Row 1 - III cycle */
;;;2496   		addr_cycle_stream[2] =
0000b2  9a02              LDR      r2,[sp,#8]
;;;2497   				(MT_uint8) BUILD_ADDR_ROW(BLOCK(0), PAGE(6), PAGE(5), PAGE(4), PAGE(3), PAGE(2), PAGE(1), PAGE(0));
;;;2498   
;;;2499   		/* Row 2 - IV cycle */
;;;2500   		addr_cycle_stream[3] =
0000b4  f3c10540          UBFX     r5,r1,#1,#1
0000b8  f0020240          AND      r2,r2,#0x40           ;2496
0000bc  ea4212c1          ORR      r2,r2,r1,LSL #7       ;2496
0000c0  ea42020b          ORR      r2,r2,r11             ;2496
0000c4  ea42020a          ORR      r2,r2,r10             ;2496
0000c8  ea420209          ORR      r2,r2,r9              ;2496
0000cc  433a              ORRS     r2,r2,r7              ;2496
0000ce  4332              ORRS     r2,r2,r6              ;2496
0000d0  ea42020c          ORR      r2,r2,r12             ;2496
0000d4  7082              STRB     r2,[r0,#2]            ;2496
0000d6  22fe              MOVS     r2,#0xfe
0000d8  ea020251          AND      r2,r2,r1,LSR #1
0000dc  432a              ORRS     r2,r2,r5
0000de  70c2              STRB     r2,[r0,#3]
;;;2501   				(MT_uint8) BUILD_ADDR_ROW(BLOCK(8), BLOCK(7), BLOCK(6), BLOCK(5), BLOCK(4), BLOCK(3), BLOCK(2), BLOCK(1));
;;;2502   
;;;2503   		/* Row 3 - V cycle */
;;;2504   		addr_cycle_stream[4] =
0000e0  ea0e2251          AND      r2,lr,r1,LSR #9
0000e4  f04f0802          MOV      r8,#2                 ;2492
0000e8  ea4202c3          ORR      r2,r2,r3,LSL #3
0000ec  ea082351          AND      r3,r8,r1,LSR #9
0000f0  431a              ORRS     r2,r2,r3
0000f2  f3c12140          UBFX     r1,r1,#9,#1
0000f6  430a              ORRS     r2,r2,r1
0000f8  7102              STRB     r2,[r0,#4]
                  |L48.250|
;;;2505   				(MT_uint8) BUILD_ADDR_ROW(LOW, LOW, LOW, LOW, LUN(0), BLOCK(11), BLOCK(10), BLOCK(9));
;;;2506   
;;;2507   	}
;;;2508   
;;;2509   	#ifdef DEBUG_PRINT_ADDRESS
;;;2510   	printf("DEBUG: addr: LUN=%x, BLOCK=%x, PAGE=%x, COL=%x\n", \
;;;2511   			addr.lun, addr.block, addr.page, addr.column);
;;;2512   	printf("DEBUG: addr_cycl = I=%x II=%x III=%x IV=%x V=%x\n", \
;;;2513   			addr_cycle_stream[0], addr_cycle_stream[1], addr_cycle_stream[2], addr_cycle_stream[3], addr_cycle_stream[4]);
;;;2514   	#endif
;;;2515   }
0000fa  e8bd8fff          POP      {r0-r11,pc}
                          ENDP

0000fe  0000              DCW      0x0000
                  |L48.256|
                          DCD      ||.bss||+0x38

                          AREA ||i.__compare_addr||, CODE, READONLY, ALIGN=1

                  __compare_addr PROC
;;;2365    */
;;;2366   MT_uint8 __compare_addr(nand_addr_t first_addr, nand_addr_t second_addr) {
000000  b530              PUSH     {r4,r5,lr}
000002  e9dd3404          LDRD     r3,r4,[sp,#0x10]
;;;2367   
;;;2368   	/* first_addr = second_addr */
;;;2369   	if((first_addr.lun == second_addr.lun) && \
000006  9d03              LDR      r5,[sp,#0xc]
000008  42a8              CMP      r0,r5
00000a  d105              BNE      |L49.24|
;;;2370   		(first_addr.block == second_addr.block) && \
00000c  4299              CMP      r1,r3
00000e  d103              BNE      |L49.24|
;;;2371   		(first_addr.page == second_addr.page) && \
000010  42a2              CMP      r2,r4
000012  d101              BNE      |L49.24|
;;;2372   		(first_addr.column == first_addr.column))
;;;2373   			return ADDR_A_EQ_B;
000014  2000              MOVS     r0,#0
;;;2374   
;;;2375   	/* first_addr > second_addr */
;;;2376   	if((first_addr.lun > second_addr.lun) && \
;;;2377   		(first_addr.block > second_addr.block) && \
;;;2378   		(first_addr.page > second_addr.page) && \
;;;2379   		(first_addr.column > first_addr.column))
;;;2380   			return ADDR_A_GT_B;
;;;2381   
;;;2382   	/* first_addr < second_addr */
;;;2383   	return ADDR_A_LT_B;
;;;2384   }
000016  bd30              POP      {r4,r5,pc}
                  |L49.24|
000018  2001              MOVS     r0,#1                 ;2383
00001a  bd30              POP      {r4,r5,pc}
;;;2385   
                          ENDP


                          AREA ||i.__is_valid_addr||, CODE, READONLY, ALIGN=2

                  __is_valid_addr PROC
;;;2353    */
;;;2354   MT_uint8 __is_valid_addr(nand_addr_t addr) {
000000  b530              PUSH     {r4,r5,lr}
;;;2355   	if((addr.column < device_info.data_bytes_per_page) &&
000002  4c09              LDR      r4,|L50.40|
000004  6b65              LDR      r5,[r4,#0x34]  ; device_info
000006  42ab              CMP      r3,r5
000008  d20b              BCS      |L50.34|
;;;2356   			(addr.page < device_info.pages_per_block) &&
00000a  6c63              LDR      r3,[r4,#0x44]  ; device_info
00000c  429a              CMP      r2,r3
00000e  d208              BCS      |L50.34|
;;;2357   			(addr.block < device_info.blocks_per_lun) &&
000010  6ca2              LDR      r2,[r4,#0x48]  ; device_info
000012  4291              CMP      r1,r2
000014  d205              BCS      |L50.34|
;;;2358   			(addr.lun < device_info.luns_per_ce))
000016  f894104c          LDRB     r1,[r4,#0x4c]  ; device_info
00001a  4288              CMP      r0,r1
00001c  d201              BCS      |L50.34|
;;;2359   		return NAND_SUCCESS;
00001e  2000              MOVS     r0,#0
;;;2360   	return NAND_INVALID_NAND_ADDRESS;
;;;2361   }
000020  bd30              POP      {r4,r5,pc}
                  |L50.34|
000022  2030              MOVS     r0,#0x30              ;2360
000024  bd30              POP      {r4,r5,pc}
;;;2362   
                          ENDP

000026  0000              DCW      0x0000
                  |L50.40|
                          DCD      ||.bss||+0x38

                          AREA ||i.__wait_for_ready||, CODE, READONLY, ALIGN=2

                  __wait_for_ready PROC
;;;2312   
;;;2313   MT_uint8 __wait_for_ready() 
000000  b570              PUSH     {r4-r6,lr}
;;;2314   	{
;;;2315   	MT_uint8 ret;
;;;2316   
;;;2317   #ifdef TIMEOUT_SUPPORT
;;;2318   	MT_uint32 clock_start = (MT_uint32) HAL_GetTick();
000002  f7fffffe          BL       HAL_GetTick
000006  4d0b              LDR      r5,|L51.52|
;;;2319   #endif
;;;2320   
;;;2321   	PLATFORM_SendCmd(CMD_READ_STATUS);
000008  2170              MOVS     r1,#0x70
00000a  7029              STRB     r1,[r5,#0]
00000c  060e              LSLS     r6,r1,#24
00000e  f50064fa          ADD      r4,r0,#0x7d0
                  |L51.18|
000012  7830              LDRB     r0,[r6,#0]
;;;2322   
;;;2323   	#ifndef TIMEOUT_SUPPORT
;;;2324   
;;;2325   	while (BIT_USED_TO_POLL != (BIT_USED_TO_POLL & PLATFORM_ReadData()))
;;;2326   		{ /* do nothing */ 	}
;;;2327   
;;;2328   	PLATFORM_SendCmd(CMD_READ_MODE);
;;;2329   	return SUCCESS;
;;;2330   
;;;2331   	#else
;;;2332   
;;;2333   	while( (BIT_USED_TO_POLL != (BIT_USED_TO_POLL & PLATFORM_ReadData())) \
000014  0640              LSLS     r0,r0,#25
000016  d403              BMI      |L51.32|
;;;2334   					&& ((MT_uint32) HAL_GetTick() < (MT_uint32) (clock_start + NUM_OF_TICKS_TO_TIMEOUT)) )
000018  f7fffffe          BL       HAL_GetTick
00001c  42a0              CMP      r0,r4
00001e  d3f8              BCC      |L51.18|
                  |L51.32|
;;;2335   		{  /* do nothing */ }
;;;2336   
;;;2337   	/* check exit condition */
;;;2338   	if(HAL_GetTick() >= clock_start + NUM_OF_TICKS_TO_TIMEOUT)
000020  f7fffffe          BL       HAL_GetTick
000024  42a0              CMP      r0,r4
000026  d301              BCC      |L51.44|
;;;2339   		ret = NAND_TIMEOUT;
000028  20fe              MOVS     r0,#0xfe
00002a  e000              B        |L51.46|
                  |L51.44|
;;;2340   	else
;;;2341   		ret = NAND_SUCCESS;
00002c  2000              MOVS     r0,#0
                  |L51.46|
;;;2342   
;;;2343   	PLATFORM_SendCmd(CMD_READ_MODE);
00002e  2100              MOVS     r1,#0
000030  7029              STRB     r1,[r5,#0]
;;;2344   	return ret;
;;;2345   
;;;2346   	#endif
;;;2347   
;;;2348   	}
000032  bd70              POP      {r4-r6,pc}
;;;2349   
                          ENDP

                  |L51.52|
                          DCD      0x70010000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  nandHandle
                          %        56
                  device_info
                          %        96

                          AREA ||.data||, DATA, ALIGN=0

                  driver_status
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\Src\\core\\nand_MT29F_lld.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_nand_MT29F_lld_c_3e5fbba4____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_nand_MT29F_lld_c_3e5fbba4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_nand_MT29F_lld_c_3e5fbba4____REVSH|
#line 144
|__asm___16_nand_MT29F_lld_c_3e5fbba4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
