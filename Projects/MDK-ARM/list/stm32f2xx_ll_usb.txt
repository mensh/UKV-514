; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_ll_usb.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_ll_usb.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_ll_usb.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_ll_usb.c]
                          THUMB

                          AREA ||i.USB_ActivateDedicatedEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateDedicatedEndpoint PROC
;;;454      */
;;;455    HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b5f0              PUSH     {r4-r7,lr}
;;;456    {
;;;457      static __IO uint32_t debug = 0;
;;;458      
;;;459      /* Read DEPCTLn register */
;;;460      if (ep->is_in == 1)
000002  784e              LDRB     r6,[r1,#1]
;;;461      {
;;;462        if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
;;;463        {
;;;464          USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
;;;465            ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
;;;466        } 
;;;467        
;;;468        
;;;469        debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
000004  4a32              LDR      r2,|L1.208|
000006  2401              MOVS     r4,#1                 ;460
000008  780d              LDRB     r5,[r1,#0]            ;462
00000a  eb001345          ADD      r3,r0,r5,LSL #5       ;462
00000e  2e01              CMP      r6,#1                 ;460
000010  d032              BEQ      |L1.120|
;;;470            ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
;;;471        
;;;472       USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
;;;473      }
;;;474      else
;;;475      {
;;;476        if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
000012  f8d36b00          LDR      r6,[r3,#0xb00]
000016  0436              LSLS     r6,r6,#16
000018  d424              BMI      |L1.100|
;;;477        {
;;;478          USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
00001a  f8d36b00          LDR      r6,[r3,#0xb00]
00001e  890f              LDRH     r7,[r1,#8]
000020  f3c7070a          UBFX     r7,r7,#0,#11
000024  433e              ORRS     r6,r6,r7
000026  78cf              LDRB     r7,[r1,#3]
000028  04bf              LSLS     r7,r7,#18
00002a  ea475585          ORR      r5,r7,r5,LSL #22
00002e  432e              ORRS     r6,r6,r5
000030  f4464500          ORR      r5,r6,#0x8000
000034  f8c35b00          STR      r5,[r3,#0xb00]
;;;479            ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
;;;480          
;;;481          debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
000038  f5006330          ADD      r3,r0,#0xb00
00003c  6013              STR      r3,[r2,#0]  ; debug
;;;482          debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
00003e  780b              LDRB     r3,[r1,#0]
000040  eb001543          ADD      r5,r0,r3,LSL #5
000044  f5056530          ADD      r5,r5,#0xb00
000048  6015              STR      r5,[r2,#0]  ; debug
;;;483          debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
00004a  890d              LDRH     r5,[r1,#8]
00004c  f3c5050a          UBFX     r5,r5,#0,#11
000050  78ce              LDRB     r6,[r1,#3]
000052  ea454586          ORR      r5,r5,r6,LSL #18
000056  ea455383          ORR      r3,r5,r3,LSL #22
00005a  6815              LDR      r5,[r2,#0]  ; debug
00005c  432b              ORRS     r3,r3,r5
00005e  f4434300          ORR      r3,r3,#0x8000
000062  6013              STR      r3,[r2,#0]  ; debug
                  |L1.100|
;;;484            ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP)); 
;;;485        } 
;;;486        
;;;487         USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
000064  f8d0283c          LDR      r2,[r0,#0x83c]
000068  7809              LDRB     r1,[r1,#0]
00006a  408c              LSLS     r4,r4,r1
00006c  ea424104          ORR      r1,r2,r4,LSL #16
000070  f8c0183c          STR      r1,[r0,#0x83c]
                  |L1.116|
;;;488      }
;;;489    
;;;490      return HAL_OK;
000074  2000              MOVS     r0,#0
;;;491    }
000076  bdf0              POP      {r4-r7,pc}
                  |L1.120|
000078  f8d36900          LDR      r6,[r3,#0x900]        ;462
00007c  0436              LSLS     r6,r6,#16             ;462
00007e  4f15              LDR      r7,|L1.212|
000080  d411              BMI      |L1.166|
000082  f8d36900          LDR      r6,[r3,#0x900]        ;464
000086  f8b1c008          LDRH     r12,[r1,#8]           ;464
00008a  f3cc0c0a          UBFX     r12,r12,#0,#11        ;464
00008e  ea46060c          ORR      r6,r6,r12             ;464
000092  f891c003          LDRB     r12,[r1,#3]           ;464
000096  ea4f4c8c          LSL      r12,r12,#18           ;464
00009a  ea4c5585          ORR      r5,r12,r5,LSL #22     ;464
00009e  432e              ORRS     r6,r6,r5              ;464
0000a0  433e              ORRS     r6,r6,r7              ;464
0000a2  f8c36900          STR      r6,[r3,#0x900]        ;464
                  |L1.166|
0000a6  890b              LDRH     r3,[r1,#8]            ;469
0000a8  f3c3030a          UBFX     r3,r3,#0,#11          ;469
0000ac  78cd              LDRB     r5,[r1,#3]            ;469
0000ae  ea434385          ORR      r3,r3,r5,LSL #18      ;469
0000b2  7809              LDRB     r1,[r1,#0]            ;469
0000b4  ea435381          ORR      r3,r3,r1,LSL #22      ;469
0000b8  6815              LDR      r5,[r2,#0]            ;469  ; debug
0000ba  432b              ORRS     r3,r3,r5              ;469
0000bc  433b              ORRS     r3,r3,r7              ;469
0000be  6013              STR      r3,[r2,#0]            ;469  ; debug
0000c0  f8d0283c          LDR      r2,[r0,#0x83c]        ;472
0000c4  408c              LSLS     r4,r4,r1              ;472
0000c6  b2a1              UXTH     r1,r4                 ;472
0000c8  430a              ORRS     r2,r2,r1              ;472
0000ca  f8c0283c          STR      r2,[r0,#0x83c]        ;472
0000ce  e7d1              B        |L1.116|
;;;492    /**
                          ENDP

                  |L1.208|
                          DCD      ||.data||
                  |L1.212|
                          DCD      0x10008000

                          AREA ||i.USB_ActivateEndpoint||, CODE, READONLY, ALIGN=2

                  USB_ActivateEndpoint PROC
;;;424      */
;;;425    HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;426    {
;;;427      if (ep->is_in == 1)
000002  784c              LDRB     r4,[r1,#1]
;;;428      {
;;;429       USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
;;;430       
;;;431        if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
;;;432        {
;;;433          USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
000004  4b1d              LDR      r3,|L2.124|
000006  2201              MOVS     r2,#1                 ;427
000008  780d              LDRB     r5,[r1,#0]            ;429
00000a  40aa              LSLS     r2,r2,r5              ;429
00000c  2c01              CMP      r4,#1                 ;427
;;;434            ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
;;;435        } 
;;;436      }
;;;437      else
;;;438      {
;;;439         USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
00000e  f8d0481c          LDR      r4,[r0,#0x81c]
000012  d018              BEQ      |L2.70|
000014  ea444202          ORR      r2,r4,r2,LSL #16
000018  f8c0281c          STR      r2,[r0,#0x81c]
;;;440         
;;;441        if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
00001c  780a              LDRB     r2,[r1,#0]
00001e  eb001042          ADD      r0,r0,r2,LSL #5
000022  f8d02b00          LDR      r2,[r0,#0xb00]
000026  0412              LSLS     r2,r2,#16
000028  d40b              BMI      |L2.66|
;;;442        {
;;;443          USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
00002a  f8d02b00          LDR      r2,[r0,#0xb00]
00002e  890c              LDRH     r4,[r1,#8]
000030  f3c4040a          UBFX     r4,r4,#0,#11
000034  4322              ORRS     r2,r2,r4
000036  78c9              LDRB     r1,[r1,#3]
000038  ea434181          ORR      r1,r3,r1,LSL #18
00003c  430a              ORRS     r2,r2,r1
00003e  f8c02b00          STR      r2,[r0,#0xb00]
                  |L2.66|
;;;444           (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
;;;445        } 
;;;446      }
;;;447      return HAL_OK;
000042  2000              MOVS     r0,#0
;;;448    }
000044  bd30              POP      {r4,r5,pc}
                  |L2.70|
000046  b292              UXTH     r2,r2                 ;429
000048  4314              ORRS     r4,r4,r2              ;429
00004a  f8c0481c          STR      r4,[r0,#0x81c]        ;429
00004e  780c              LDRB     r4,[r1,#0]            ;431
000050  eb001044          ADD      r0,r0,r4,LSL #5       ;431
000054  f8d02900          LDR      r2,[r0,#0x900]        ;431
000058  0412              LSLS     r2,r2,#16             ;431
00005a  d4f2              BMI      |L2.66|
00005c  f8d02900          LDR      r2,[r0,#0x900]        ;433
000060  890d              LDRH     r5,[r1,#8]            ;433
000062  f3c5050a          UBFX     r5,r5,#0,#11          ;433
000066  432a              ORRS     r2,r2,r5              ;433
000068  78c9              LDRB     r1,[r1,#3]            ;433
00006a  0489              LSLS     r1,r1,#18             ;433
00006c  ea415184          ORR      r1,r1,r4,LSL #22      ;433
000070  430a              ORRS     r2,r2,r1              ;433
000072  431a              ORRS     r2,r2,r3              ;433
000074  f8c02900          STR      r2,[r0,#0x900]        ;433
000078  e7e3              B        |L2.66|
;;;449    /**
                          ENDP

00007a  0000              DCW      0x0000
                  |L2.124|
                          DCD      0x10008000

                          AREA ||i.USB_ActivateSetup||, CODE, READONLY, ALIGN=1

                  USB_ActivateSetup PROC
;;;1027     */
;;;1028   HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
000000  f8d01900          LDR      r1,[r0,#0x900]
;;;1029   {
;;;1030     /* Set the MPS of the IN EP based on the enumeration speed */
;;;1031     USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
000004  f36f010a          BFC      r1,#0,#11
000008  f8c01900          STR      r1,[r0,#0x900]
;;;1032     
;;;1033     if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
00000c  f8d01808          LDR      r1,[r0,#0x808]
000010  f3c10141          UBFX     r1,r1,#1,#2
000014  2902              CMP      r1,#2
000016  d105              BNE      |L3.36|
;;;1034     {
;;;1035       USBx_INEP(0)->DIEPCTL |= 3;
000018  f8d01900          LDR      r1,[r0,#0x900]
00001c  f0410103          ORR      r1,r1,#3
000020  f8c01900          STR      r1,[r0,#0x900]
                  |L3.36|
;;;1036     }
;;;1037     USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
000024  f8d01804          LDR      r1,[r0,#0x804]
000028  f4417180          ORR      r1,r1,#0x100
00002c  f8c01804          STR      r1,[r0,#0x804]
;;;1038   
;;;1039     return HAL_OK;
000030  2000              MOVS     r0,#0
;;;1040   }
000032  4770              BX       lr
;;;1041   
                          ENDP


                          AREA ||i.USB_ClearInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ClearInterrupts PROC
;;;1003     */
;;;1004   void  USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
000000  6942              LDR      r2,[r0,#0x14]
;;;1005   {
;;;1006     USBx->GINTSTS |= interrupt; 
000002  430a              ORRS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;1007   }
000006  4770              BX       lr
;;;1008   
                          ENDP


                          AREA ||i.USB_CoreInit||, CODE, READONLY, ALIGN=2

                  USB_CoreInit PROC
;;;98       */
;;;99     HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  4604              MOV      r4,r0
;;;101      if (cfg.phy_itface == USB_OTG_ULPI_PHY)
000004  9d04              LDR      r5,[sp,#0x10]
000006  9906              LDR      r1,[sp,#0x18]
000008  980b              LDR      r0,[sp,#0x2c]
00000a  2901              CMP      r1,#1
00000c  d00c              BEQ      |L5.40|
;;;102      {
;;;103        
;;;104        USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
;;;105    
;;;106        /* Init The ULPI Interface */
;;;107        USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
;;;108       
;;;109        /* Select vbus source */
;;;110        USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
;;;111        if(cfg.use_external_vbus == 1)
;;;112        {
;;;113          USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
;;;114        }
;;;115        /* Reset after a PHY select  */
;;;116        USB_CoreReset(USBx); 
;;;117      }
;;;118      else /* FS interface (embedded Phy) */
;;;119      {
;;;120        
;;;121        /* Select FS Embedded PHY */
;;;122        USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
00000e  68e0              LDR      r0,[r4,#0xc]
000010  f0400040          ORR      r0,r0,#0x40
000014  60e0              STR      r0,[r4,#0xc]
;;;123        
;;;124        /* Reset after a PHY select and set Host mode */
;;;125        USB_CoreReset(USBx);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_CoreReset
;;;126        
;;;127        /* Deactivate the power down*/
;;;128        USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
00001c  f44f3080          MOV      r0,#0x10000
000020  63a0              STR      r0,[r4,#0x38]
                  |L5.34|
;;;129      }
;;;130     
;;;131      if(cfg.dma_enable == ENABLE)
000022  2d01              CMP      r5,#1
000024  d016              BEQ      |L5.84|
000026  e01d              B        |L5.100|
                  |L5.40|
000028  6ba1              LDR      r1,[r4,#0x38]         ;104
00002a  f4213180          BIC      r1,r1,#0x10000        ;104
00002e  63a1              STR      r1,[r4,#0x38]         ;104
000030  68e1              LDR      r1,[r4,#0xc]          ;107
000032  4a0d              LDR      r2,|L5.104|
000034  4011              ANDS     r1,r1,r2              ;107
000036  60e1              STR      r1,[r4,#0xc]          ;107
000038  68e1              LDR      r1,[r4,#0xc]          ;110
00003a  f4211140          BIC      r1,r1,#0x300000       ;110
00003e  60e1              STR      r1,[r4,#0xc]          ;110
000040  2801              CMP      r0,#1                 ;111
000042  d103              BNE      |L5.76|
000044  68e0              LDR      r0,[r4,#0xc]          ;113
000046  f4401080          ORR      r0,r0,#0x100000       ;113
00004a  60e0              STR      r0,[r4,#0xc]          ;113
                  |L5.76|
00004c  4620              MOV      r0,r4                 ;116
00004e  f7fffffe          BL       USB_CoreReset
000052  e7e6              B        |L5.34|
                  |L5.84|
;;;132      {
;;;133        USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
000054  68a0              LDR      r0,[r4,#8]
000056  f040000c          ORR      r0,r0,#0xc
00005a  60a0              STR      r0,[r4,#8]
;;;134        USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
00005c  68a0              LDR      r0,[r4,#8]
00005e  f0400020          ORR      r0,r0,#0x20
000062  60a0              STR      r0,[r4,#8]
                  |L5.100|
;;;135      }  
;;;136    
;;;137      return HAL_OK;
000064  2000              MOVS     r0,#0
;;;138    }
000066  bd70              POP      {r4-r6,pc}
;;;139    
                          ENDP

                  |L5.104|
                          DCD      0xffbdffbf

                          AREA ||i.USB_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_CoreReset PROC
;;;1075     */
;;;1076   static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
000000  2201              MOVS     r2,#1
;;;1077   {
;;;1078     uint32_t count = 0;
;;;1079   
;;;1080     /* Wait for AHB master IDLE state. */
;;;1081     do
;;;1082     {
;;;1083       if (++count > 200000)
000002  490c              LDR      r1,|L6.52|
000004  e002              B        |L6.12|
                  |L6.6|
000006  1c52              ADDS     r2,r2,#1              ;1077
000008  428a              CMP      r2,r1
00000a  d80b              BHI      |L6.36|
                  |L6.12|
;;;1084       {
;;;1085         return HAL_TIMEOUT;
;;;1086       }
;;;1087     }
;;;1088     while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
00000c  6903              LDR      r3,[r0,#0x10]
00000e  2b00              CMP      r3,#0
000010  daf9              BGE      |L6.6|
;;;1089     
;;;1090     /* Core Soft Reset */
;;;1091     count = 0;
;;;1092     USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
000012  6902              LDR      r2,[r0,#0x10]
000014  f0420201          ORR      r2,r2,#1
000018  6102              STR      r2,[r0,#0x10]
;;;1093   
;;;1094     do
;;;1095     {
;;;1096       if (++count > 200000)
00001a  2201              MOVS     r2,#1
00001c  e004              B        |L6.40|
                  |L6.30|
00001e  1c52              ADDS     r2,r2,#1              ;1094
000020  428a              CMP      r2,r1
000022  d901              BLS      |L6.40|
                  |L6.36|
;;;1097       {
;;;1098         return HAL_TIMEOUT;
000024  2003              MOVS     r0,#3
;;;1099       }
;;;1100     }
;;;1101     while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
;;;1102     
;;;1103     return HAL_OK;
;;;1104   }
000026  4770              BX       lr
                  |L6.40|
000028  6903              LDR      r3,[r0,#0x10]         ;1101
00002a  07db              LSLS     r3,r3,#31             ;1101
00002c  d1f7              BNE      |L6.30|
00002e  2000              MOVS     r0,#0                 ;1103
000030  4770              BX       lr
;;;1105   
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x00030d40

                          AREA ||i.USB_DeactivateDedicatedEndpoint||, CODE, READONLY, ALIGN=1

                  USB_DeactivateDedicatedEndpoint PROC
;;;521      */
;;;522    HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b510              PUSH     {r4,lr}
;;;523    {
;;;524      /* Read DEPCTLn register */
;;;525      if (ep->is_in == 1)
000002  784c              LDRB     r4,[r1,#1]
000004  2301              MOVS     r3,#1
;;;526      {
;;;527       USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
000006  780a              LDRB     r2,[r1,#0]
000008  eb001242          ADD      r2,r0,r2,LSL #5
00000c  2c01              CMP      r4,#1                 ;525
00000e  d00f              BEQ      |L7.48|
;;;528       USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
;;;529      }
;;;530      else
;;;531      {
;;;532         USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
000010  f8d24b00          LDR      r4,[r2,#0xb00]
000014  f4244400          BIC      r4,r4,#0x8000
000018  f8c24b00          STR      r4,[r2,#0xb00]
;;;533         USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
00001c  f8d0281c          LDR      r2,[r0,#0x81c]
000020  7809              LDRB     r1,[r1,#0]
000022  408b              LSLS     r3,r3,r1
000024  ea224103          BIC      r1,r2,r3,LSL #16
000028  f8c0181c          STR      r1,[r0,#0x81c]
                  |L7.44|
;;;534      }
;;;535      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;536    }
00002e  bd10              POP      {r4,pc}
                  |L7.48|
000030  f8d24900          LDR      r4,[r2,#0x900]        ;527
000034  f4244400          BIC      r4,r4,#0x8000         ;527
000038  f8c24900          STR      r4,[r2,#0x900]        ;527
00003c  f8d0281c          LDR      r2,[r0,#0x81c]        ;528
000040  7809              LDRB     r1,[r1,#0]            ;528
000042  408b              LSLS     r3,r3,r1              ;528
000044  b299              UXTH     r1,r3                 ;528
000046  438a              BICS     r2,r2,r1              ;528
000048  f8c0281c          STR      r2,[r0,#0x81c]        ;528
00004c  e7ee              B        |L7.44|
;;;537    
                          ENDP


                          AREA ||i.USB_DeactivateEndpoint||, CODE, READONLY, ALIGN=1

                  USB_DeactivateEndpoint PROC
;;;497      */
;;;498    HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  b530              PUSH     {r4,r5,lr}
;;;499    {
;;;500      /* Read DEPCTLn register */
;;;501      if (ep->is_in == 1)
000002  784d              LDRB     r5,[r1,#1]
000004  2201              MOVS     r2,#1
;;;502      {
;;;503        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
000006  780c              LDRB     r4,[r1,#0]
000008  fa02f304          LSL      r3,r2,r4
00000c  2d01              CMP      r5,#1                 ;501
;;;504        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
;;;505        USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
;;;506      }
;;;507      else
;;;508      {
;;;509        USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
00000e  f8d0483c          LDR      r4,[r0,#0x83c]
000012  d016              BEQ      |L8.66|
000014  ea244303          BIC      r3,r4,r3,LSL #16
000018  f8c0383c          STR      r3,[r0,#0x83c]
;;;510        USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
00001c  f8d0381c          LDR      r3,[r0,#0x81c]
000020  780c              LDRB     r4,[r1,#0]
000022  40a2              LSLS     r2,r2,r4
000024  ea234202          BIC      r2,r3,r2,LSL #16
000028  f8c0281c          STR      r2,[r0,#0x81c]
;;;511        USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;
00002c  7809              LDRB     r1,[r1,#0]
00002e  eb001041          ADD      r0,r0,r1,LSL #5
000032  f8d01b00          LDR      r1,[r0,#0xb00]
000036  f4214100          BIC      r1,r1,#0x8000
00003a  f8c01b00          STR      r1,[r0,#0xb00]
                  |L8.62|
;;;512      }
;;;513      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;514    }
000040  bd30              POP      {r4,r5,pc}
                  |L8.66|
000042  b29b              UXTH     r3,r3                 ;503
000044  439c              BICS     r4,r4,r3              ;503
000046  f8c0483c          STR      r4,[r0,#0x83c]        ;503
00004a  f8d0381c          LDR      r3,[r0,#0x81c]        ;504
00004e  780c              LDRB     r4,[r1,#0]            ;504
000050  40a2              LSLS     r2,r2,r4              ;504
000052  b292              UXTH     r2,r2                 ;504
000054  4393              BICS     r3,r3,r2              ;504
000056  f8c0381c          STR      r3,[r0,#0x81c]        ;504
00005a  7809              LDRB     r1,[r1,#0]            ;505
00005c  eb001041          ADD      r0,r0,r1,LSL #5       ;505
000060  f8d01900          LDR      r1,[r0,#0x900]        ;505
000064  f4214100          BIC      r1,r1,#0x8000         ;505
000068  f8c01900          STR      r1,[r0,#0x900]        ;505
00006c  e7e7              B        |L8.62|
;;;515    
                          ENDP


                          AREA ||i.USB_DevConnect||, CODE, READONLY, ALIGN=1

                  USB_DevConnect PROC
;;;903      */
;;;904    HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
000000  b510              PUSH     {r4,lr}
;;;905    {
;;;906      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
000002  f8d01804          LDR      r1,[r0,#0x804]
000006  f0210102          BIC      r1,r1,#2
00000a  f8c01804          STR      r1,[r0,#0x804]
;;;907      HAL_Delay(3);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       HAL_Delay
;;;908      
;;;909      return HAL_OK;  
000014  2000              MOVS     r0,#0
;;;910    }
000016  bd10              POP      {r4,pc}
;;;911    
                          ENDP


                          AREA ||i.USB_DevDisconnect||, CODE, READONLY, ALIGN=1

                  USB_DevDisconnect PROC
;;;916      */
;;;917    HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
000000  b510              PUSH     {r4,lr}
;;;918    {
;;;919      USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
000002  f8d01804          LDR      r1,[r0,#0x804]
000006  f0410102          ORR      r1,r1,#2
00000a  f8c01804          STR      r1,[r0,#0x804]
;;;920      HAL_Delay(3);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       HAL_Delay
;;;921      
;;;922      return HAL_OK;  
000014  2000              MOVS     r0,#0
;;;923    }
000016  bd10              POP      {r4,pc}
;;;924    
                          ENDP


                          AREA ||i.USB_DevInit||, CODE, READONLY, ALIGN=2

                  USB_DevInit PROC
;;;199      */
;;;200    HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;201    {
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
000008  e9dd0a0a          LDRD     r0,r10,[sp,#0x28]
;;;202      uint32_t i = 0;
00000c  2500              MOVS     r5,#0
;;;203    
;;;204      /*Activate VBUS Sensing B */
;;;205      USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
00000e  f8dd8034          LDR      r8,[sp,#0x34]
000012  9f08              LDR      r7,[sp,#0x20]
000014  6ba1              LDR      r1,[r4,#0x38]
000016  f4412100          ORR      r1,r1,#0x80000
00001a  63a1              STR      r1,[r4,#0x38]
;;;206      
;;;207      if (cfg.vbus_sensing_enable == 0)
00001c  f1b80f00          CMP      r8,#0
000020  d103              BNE      |L11.42|
;;;208      {
;;;209        USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
000022  6ba1              LDR      r1,[r4,#0x38]
000024  f4411100          ORR      r1,r1,#0x200000
000028  63a1              STR      r1,[r4,#0x38]
                  |L11.42|
;;;210      }
;;;211       
;;;212      /* Restart the Phy Clock */
;;;213      USBx_PCGCCTL = 0;
00002a  f04f0900          MOV      r9,#0
00002e  f8c49e00          STR      r9,[r4,#0xe00]
;;;214    
;;;215      /* Device mode configuration */
;;;216      USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
000032  f8d41800          LDR      r1,[r4,#0x800]
000036  f8c41800          STR      r1,[r4,#0x800]
;;;217    
;;;218      if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
00003a  2801              CMP      r0,#1
00003c  d004              BEQ      |L11.72|
00003e  f8d40800          LDR      r0,[r4,#0x800]
000042  f0400003          ORR      r0,r0,#3
;;;219      {
;;;220        if(cfg.speed == USB_OTG_SPEED_HIGH)
;;;221        {      
;;;222          /* Set High speed phy */
;;;223          USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
;;;224        }
;;;225        else 
;;;226        {
;;;227          /* set High speed phy in Full speed mode */
;;;228          USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
;;;229        }
;;;230      }
;;;231      else
;;;232      {
;;;233        /* Set Full speed phy */
;;;234        USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
000046  e004              B        |L11.82|
                  |L11.72|
000048  f8d40800          LDR      r0,[r4,#0x800]
00004c  b10b              CBZ      r3,|L11.82|
00004e  f0400001          ORR      r0,r0,#1              ;220
                  |L11.82|
000052  f8c40800          STR      r0,[r4,#0x800]        ;220
;;;235      }
;;;236    
;;;237      /* Flush the FIFOs */
;;;238      USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
000056  2110              MOVS     r1,#0x10
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       USB_FlushTxFifo
;;;239      USB_FlushRxFifo(USBx);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       USB_FlushRxFifo
;;;240    
;;;241      
;;;242      /* Clear all pending Device Interrupts */
;;;243      USBx_DEVICE->DIEPMSK = 0;
000064  4648              MOV      r0,r9
000066  f8c49810          STR      r9,[r4,#0x810]
;;;244      USBx_DEVICE->DOEPMSK = 0;
00006a  f8c49814          STR      r9,[r4,#0x814]
;;;245      USBx_DEVICE->DAINT = 0xFFFFFFFF;
00006e  f04f31ff          MOV      r1,#0xffffffff
000072  f8c41818          STR      r1,[r4,#0x818]
;;;246      USBx_DEVICE->DAINTMSK = 0;
000076  f8c4981c          STR      r9,[r4,#0x81c]
;;;247      
;;;248      for (i = 0; i < cfg.dev_endpoints; i++)
;;;249      {
;;;250        if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
;;;251        {
;;;252          USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
00007a  f04f4c90          MOV      r12,#0x48000000
;;;253        }
;;;254        else
;;;255        {
;;;256          USBx_INEP(i)->DIEPCTL = 0;
;;;257        }
;;;258        
;;;259        USBx_INEP(i)->DIEPTSIZ = 0;
;;;260        USBx_INEP(i)->DIEPINT  = 0xFF;
00007e  23ff              MOVS     r3,#0xff
000080  e010              B        |L11.164|
000082  bf00              NOP                            ;250
                  |L11.132|
000084  eb041145          ADD      r1,r4,r5,LSL #5       ;250
000088  f8d12900          LDR      r2,[r1,#0x900]        ;250
00008c  2a00              CMP      r2,#0                 ;250
00008e  da02              BGE      |L11.150|
000090  f8c1c900          STR      r12,[r1,#0x900]       ;252
000094  e001              B        |L11.154|
                  |L11.150|
000096  f8c10900          STR      r0,[r1,#0x900]        ;256
                  |L11.154|
00009a  f8c10910          STR      r0,[r1,#0x910]        ;259
00009e  f8c13908          STR      r3,[r1,#0x908]
0000a2  1c6d              ADDS     r5,r5,#1
                  |L11.164|
0000a4  42ae              CMP      r6,r5                 ;248
0000a6  d8ed              BHI      |L11.132|
;;;261      }
;;;262      
;;;263      for (i = 0; i < cfg.dev_endpoints; i++)
0000a8  2100              MOVS     r1,#0
0000aa  e00f              B        |L11.204|
                  |L11.172|
;;;264      {
;;;265        if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
0000ac  eb041241          ADD      r2,r4,r1,LSL #5
0000b0  f8d25b00          LDR      r5,[r2,#0xb00]
0000b4  2d00              CMP      r5,#0
0000b6  da02              BGE      |L11.190|
;;;266        {
;;;267          USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
0000b8  f8c2cb00          STR      r12,[r2,#0xb00]
0000bc  e001              B        |L11.194|
                  |L11.190|
;;;268        }
;;;269        else
;;;270        {
;;;271          USBx_OUTEP(i)->DOEPCTL = 0;
0000be  f8c20b00          STR      r0,[r2,#0xb00]
                  |L11.194|
;;;272        }
;;;273        
;;;274        USBx_OUTEP(i)->DOEPTSIZ = 0;
0000c2  f8c20b10          STR      r0,[r2,#0xb10]
;;;275        USBx_OUTEP(i)->DOEPINT  = 0xFF;
0000c6  f8c23b08          STR      r3,[r2,#0xb08]
0000ca  1c49              ADDS     r1,r1,#1
                  |L11.204|
0000cc  428e              CMP      r6,r1                 ;263
0000ce  d8ed              BHI      |L11.172|
;;;276      }
;;;277      
;;;278      USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
0000d0  f8d41810          LDR      r1,[r4,#0x810]
0000d4  f4217180          BIC      r1,r1,#0x100
0000d8  f8c41810          STR      r1,[r4,#0x810]
;;;279      
;;;280      if (cfg.dma_enable == 1)
0000dc  2f01              CMP      r7,#1
0000de  d10a              BNE      |L11.246|
;;;281      {
;;;282        /*Set threshold parameters */
;;;283        USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
0000e0  4914              LDR      r1,|L11.308|
0000e2  f8c41830          STR      r1,[r4,#0x830]
;;;284        USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
0000e6  f8d41830          LDR      r1,[r4,#0x830]
0000ea  4a13              LDR      r2,|L11.312|
0000ec  4311              ORRS     r1,r1,r2
0000ee  f8c41830          STR      r1,[r4,#0x830]
;;;285        
;;;286        i= USBx_DEVICE->DTHRCTL;
0000f2  f8d41830          LDR      r1,[r4,#0x830]
                  |L11.246|
;;;287      }
;;;288      
;;;289      /* Disable all interrupts. */
;;;290      USBx->GINTMSK = 0;
0000f6  61a0              STR      r0,[r4,#0x18]
;;;291      
;;;292      /* Clear any pending interrupts */
;;;293      USBx->GINTSTS = 0xBFFFFFFF;
0000f8  f06f4080          MVN      r0,#0x40000000
0000fc  6160              STR      r0,[r4,#0x14]
;;;294    
;;;295      /* Enable the common interrupts */
;;;296      if (cfg.dma_enable == DISABLE)
0000fe  b91f              CBNZ     r7,|L11.264|
;;;297      {
;;;298        USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
000100  69a0              LDR      r0,[r4,#0x18]
000102  f0400010          ORR      r0,r0,#0x10
000106  61a0              STR      r0,[r4,#0x18]
                  |L11.264|
;;;299      }
;;;300      
;;;301      /* Enable interrupts matching to the Device mode ONLY */
;;;302      USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
000108  69a0              LDR      r0,[r4,#0x18]
00010a  490c              LDR      r1,|L11.316|
00010c  4308              ORRS     r0,r0,r1
00010e  61a0              STR      r0,[r4,#0x18]
;;;303                        USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
;;;304                        USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
;;;305                        USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
;;;306      
;;;307      if(cfg.Sof_enable)
000110  f1ba0f00          CMP      r10,#0
000114  d003              BEQ      |L11.286|
;;;308      {
;;;309        USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
000116  69a0              LDR      r0,[r4,#0x18]
000118  f0400008          ORR      r0,r0,#8
00011c  61a0              STR      r0,[r4,#0x18]
                  |L11.286|
;;;310      }
;;;311    
;;;312      if (cfg.vbus_sensing_enable == ENABLE)
00011e  f1b80f01          CMP      r8,#1
000122  d103              BNE      |L11.300|
;;;313      {
;;;314        USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
000124  69a0              LDR      r0,[r4,#0x18]
000126  4906              LDR      r1,|L11.320|
000128  4308              ORRS     r0,r0,r1
00012a  61a0              STR      r0,[r4,#0x18]
                  |L11.300|
;;;315      }
;;;316      
;;;317      return HAL_OK;
00012c  2000              MOVS     r0,#0
;;;318    }
00012e  e8bd87f0          POP      {r4-r10,pc}
;;;319    
                          ENDP

000132  0000              DCW      0x0000
                  |L11.308|
                          DCD      0x00800100
                  |L11.312|
                          DCD      0x00010003
                  |L11.316|
                          DCD      0x803c3800
                  |L11.320|
                          DCD      0x40000004

                          AREA ||i.USB_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_DisableGlobalInt PROC
;;;158    */
;;;159    HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  6881              LDR      r1,[r0,#8]
;;;160    {
;;;161      USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
000002  f0210101          BIC      r1,r1,#1
000006  6081              STR      r1,[r0,#8]
;;;162      return HAL_OK;
000008  2000              MOVS     r0,#0
;;;163    }
00000a  4770              BX       lr
;;;164       
                          ENDP


                          AREA ||i.USB_DoPing||, CODE, READONLY, ALIGN=2

                  USB_DoPing PROC
;;;1608     */
;;;1609   HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)
000000  b510              PUSH     {r4,lr}
;;;1610   {
000002  4602              MOV      r2,r0
;;;1611     uint8_t  num_packets = 1;
000004  2301              MOVS     r3,#1
;;;1612   
;;;1613     USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
000006  4812              LDR      r0,|L13.80|
000008  ea0040c3          AND      r0,r0,r3,LSL #19
00000c  f0404400          ORR      r4,r0,#0x80000000
000010  f50260a0          ADD      r0,r2,#0x500
000014  eb001041          ADD      r0,r0,r1,LSL #5
000018  6104              STR      r4,[r0,#0x10]
;;;1614                                   USB_OTG_HCTSIZ_DOPING;
;;;1615     
;;;1616     /* Set host channel enable */
;;;1617     USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;
00001a  f50260a0          ADD      r0,r2,#0x500
00001e  eb001041          ADD      r0,r0,r1,LSL #5
000022  6800              LDR      r0,[r0,#0]
000024  f0204480          BIC      r4,r0,#0x40000000
000028  f50260a0          ADD      r0,r2,#0x500
00002c  eb001041          ADD      r0,r0,r1,LSL #5
000030  6004              STR      r4,[r0,#0]
;;;1618     USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
000032  f50260a0          ADD      r0,r2,#0x500
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6800              LDR      r0,[r0,#0]
00003c  f0404400          ORR      r4,r0,#0x80000000
000040  f50260a0          ADD      r0,r2,#0x500
000044  eb001041          ADD      r0,r0,r1,LSL #5
000048  6004              STR      r4,[r0,#0]
;;;1619     
;;;1620     return HAL_OK;  
00004a  2000              MOVS     r0,#0
;;;1621   }
00004c  bd10              POP      {r4,pc}
;;;1622   
                          ENDP

00004e  0000              DCW      0x0000
                  |L13.80|
                          DCD      0x1ff80000

                          AREA ||i.USB_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_DriveVbus PROC
;;;1248   */
;;;1249   HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)
000000  b508              PUSH     {r3,lr}
;;;1250   {
;;;1251     __IO uint32_t hprt0;
;;;1252   
;;;1253     hprt0 = USBx_HPRT0;
000002  f8d02440          LDR      r2,[r0,#0x440]
;;;1254     hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
000006  f022022e          BIC      r2,r2,#0x2e
;;;1255                            USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
;;;1256     
;;;1257     if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
00000a  9200              STR      r2,[sp,#0]
00000c  04d2              LSLS     r2,r2,#19
00000e  d405              BMI      |L14.28|
000010  2901              CMP      r1,#1
000012  d109              BNE      |L14.40|
;;;1258     {
;;;1259       USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
000014  9900              LDR      r1,[sp,#0]
000016  f4415180          ORR      r1,r1,#0x1000
00001a  e003              B        |L14.36|
                  |L14.28|
;;;1260     }
;;;1261     if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0 ))
00001c  b921              CBNZ     r1,|L14.40|
;;;1262     {
;;;1263       USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
00001e  9900              LDR      r1,[sp,#0]
000020  f4215180          BIC      r1,r1,#0x1000
                  |L14.36|
000024  f8c01440          STR      r1,[r0,#0x440]        ;1259
                  |L14.40|
;;;1264     }
;;;1265     return HAL_OK; 
000028  2000              MOVS     r0,#0
;;;1266   }
00002a  bd08              POP      {r3,pc}
;;;1267   
                          ENDP


                          AREA ||i.USB_EP0StartXfer||, CODE, READONLY, ALIGN=2

                  USB_EP0StartXfer PROC
;;;669      */
;;;670    HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  b530              PUSH     {r4,r5,lr}
;;;671    {
;;;672      /* IN endpoint */
;;;673      if (ep->is_in == 1)
000002  784d              LDRB     r5,[r1,#1]
;;;674      {
;;;675        /* Zero Length Packet? */
;;;676        if (ep->xfer_len == 0)
;;;677        {
;;;678          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
000004  4c4d              LDR      r4,|L15.316|
000006  780b              LDRB     r3,[r1,#0]
000008  eb001343          ADD      r3,r0,r3,LSL #5
00000c  2d01              CMP      r5,#1                 ;673
00000e  d028              BEQ      |L15.98|
;;;679          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
;;;680          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
;;;681        }
;;;682        else
;;;683        {
;;;684          /* Program the transfer size and packet count
;;;685          * as follows: xfersize = N * maxpacket +
;;;686          * short_packet pktcnt = N + (short_packet
;;;687          * exist ? 1 : 0)
;;;688          */
;;;689          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
;;;690          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
;;;691          
;;;692          if(ep->xfer_len > ep->maxpacket)
;;;693          {
;;;694            ep->xfer_len = ep->maxpacket;
;;;695          }
;;;696          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
;;;697          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
;;;698        
;;;699        }
;;;700        
;;;701        if (dma == 1)
;;;702        {
;;;703          USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
;;;704        }
;;;705        else
;;;706        {
;;;707          /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;708          if (ep->xfer_len > 0)
;;;709          {
;;;710            USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
;;;711          }
;;;712        }
;;;713        
;;;714        /* EP enable, IN data in FIFO */
;;;715        USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
;;;716      }
;;;717      else /* OUT endpoint */
;;;718      {
;;;719        /* Program the transfer size and packet count as follows:
;;;720        * pktcnt = N
;;;721        * xfersize = N * maxpacket
;;;722        */
;;;723        USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
000010  f8d35b10          LDR      r5,[r3,#0xb10]
000014  f36f0512          BFC      r5,#0,#19
000018  f8c35b10          STR      r5,[r3,#0xb10]
;;;724        USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
00001c  780b              LDRB     r3,[r1,#0]
00001e  eb001343          ADD      r3,r0,r3,LSL #5
000022  f8d35b10          LDR      r5,[r3,#0xb10]
000026  4025              ANDS     r5,r5,r4
000028  f8c35b10          STR      r5,[r3,#0xb10]
;;;725          
;;;726        if (ep->xfer_len > 0)
00002c  694b              LDR      r3,[r1,#0x14]
00002e  b10b              CBZ      r3,|L15.52|
;;;727        {
;;;728          ep->xfer_len = ep->maxpacket;
000030  688b              LDR      r3,[r1,#8]
000032  614b              STR      r3,[r1,#0x14]
                  |L15.52|
;;;729        }
;;;730        
;;;731        USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
000034  780b              LDRB     r3,[r1,#0]
000036  eb001343          ADD      r3,r0,r3,LSL #5
00003a  f8d34b10          LDR      r4,[r3,#0xb10]
00003e  f4442400          ORR      r4,r4,#0x80000
000042  f8c34b10          STR      r4,[r3,#0xb10]
;;;732        USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
000046  780b              LDRB     r3,[r1,#0]
000048  eb001343          ADD      r3,r0,r3,LSL #5
00004c  f8d34b10          LDR      r4,[r3,#0xb10]
000050  688d              LDR      r5,[r1,#8]
000052  f3c50512          UBFX     r5,r5,#0,#19
000056  432c              ORRS     r4,r4,r5
000058  f8c34b10          STR      r4,[r3,#0xb10]
;;;733        
;;;734    
;;;735        if (dma == 1)
00005c  2a01              CMP      r2,#1
00005e  d05c              BEQ      |L15.282|
000060  e061              B        |L15.294|
                  |L15.98|
000062  694d              LDR      r5,[r1,#0x14]         ;676
000064  2d00              CMP      r5,#0                 ;676
000066  f8d35910          LDR      r5,[r3,#0x910]        ;689
00006a  d03b              BEQ      |L15.228|
00006c  f36f0512          BFC      r5,#0,#19             ;689
000070  f8c35910          STR      r5,[r3,#0x910]        ;689
000074  780b              LDRB     r3,[r1,#0]            ;690
000076  eb001343          ADD      r3,r0,r3,LSL #5       ;690
00007a  f8d35910          LDR      r5,[r3,#0x910]        ;690
00007e  4025              ANDS     r5,r5,r4              ;690
000080  f8c35910          STR      r5,[r3,#0x910]        ;690
000084  694c              LDR      r4,[r1,#0x14]         ;692
000086  688b              LDR      r3,[r1,#8]            ;692
000088  429c              CMP      r4,r3                 ;692
00008a  d900              BLS      |L15.142|
00008c  614b              STR      r3,[r1,#0x14]         ;694
                  |L15.142|
00008e  780b              LDRB     r3,[r1,#0]            ;696
000090  eb001343          ADD      r3,r0,r3,LSL #5       ;696
000094  f8d34910          LDR      r4,[r3,#0x910]        ;696
000098  f4442400          ORR      r4,r4,#0x80000        ;696
00009c  f8c34910          STR      r4,[r3,#0x910]        ;696
0000a0  780b              LDRB     r3,[r1,#0]            ;697
0000a2  eb001343          ADD      r3,r0,r3,LSL #5       ;697
0000a6  f8d34910          LDR      r4,[r3,#0x910]        ;697
0000aa  694d              LDR      r5,[r1,#0x14]         ;697
0000ac  f3c50512          UBFX     r5,r5,#0,#19          ;697
0000b0  ea540405          ORRS.W   r4,r4,r5              ;697
                  |L15.180|
0000b4  f8c34910          STR      r4,[r3,#0x910]        ;697
0000b8  2a01              CMP      r2,#1                 ;701
0000ba  d027              BEQ      |L15.268|
0000bc  694a              LDR      r2,[r1,#0x14]         ;708
0000be  b13a              CBZ      r2,|L15.208|
0000c0  f8d02834          LDR      r2,[r0,#0x834]        ;710
0000c4  780c              LDRB     r4,[r1,#0]            ;710
0000c6  2301              MOVS     r3,#1                 ;710
0000c8  40a3              LSLS     r3,r3,r4              ;710
0000ca  431a              ORRS     r2,r2,r3              ;710
0000cc  f8c02834          STR      r2,[r0,#0x834]        ;710
                  |L15.208|
0000d0  7809              LDRB     r1,[r1,#0]            ;715
0000d2  eb001041          ADD      r0,r0,r1,LSL #5       ;715
0000d6  f8d01900          LDR      r1,[r0,#0x900]        ;715
0000da  f0414104          ORR      r1,r1,#0x84000000     ;715
0000de  f8c01900          STR      r1,[r0,#0x900]        ;715
0000e2  e029              B        |L15.312|
                  |L15.228|
0000e4  4025              ANDS     r5,r5,r4              ;678
0000e6  f8c35910          STR      r5,[r3,#0x910]        ;678
0000ea  780b              LDRB     r3,[r1,#0]            ;679
0000ec  eb001343          ADD      r3,r0,r3,LSL #5       ;679
0000f0  f8d34910          LDR      r4,[r3,#0x910]        ;679
0000f4  f4442400          ORR      r4,r4,#0x80000        ;679
0000f8  f8c34910          STR      r4,[r3,#0x910]        ;679
0000fc  780b              LDRB     r3,[r1,#0]            ;680
0000fe  eb001343          ADD      r3,r0,r3,LSL #5       ;680
000102  f8d34910          LDR      r4,[r3,#0x910]        ;680
000106  f36f0412          BFC      r4,#0,#19             ;680
00010a  e7d3              B        |L15.180|
                  |L15.268|
00010c  780b              LDRB     r3,[r1,#0]            ;703
00010e  eb001343          ADD      r3,r0,r3,LSL #5       ;703
000112  690a              LDR      r2,[r1,#0x10]         ;703
000114  f8c32914          STR      r2,[r3,#0x914]        ;703
000118  e7da              B        |L15.208|
                  |L15.282|
;;;736        {
;;;737          USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
00011a  780b              LDRB     r3,[r1,#0]
00011c  eb001343          ADD      r3,r0,r3,LSL #5
000120  68ca              LDR      r2,[r1,#0xc]
000122  f8c32b14          STR      r2,[r3,#0xb14]
                  |L15.294|
;;;738        }
;;;739        
;;;740        /* EP enable */
;;;741        USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
000126  7809              LDRB     r1,[r1,#0]
000128  eb001041          ADD      r0,r0,r1,LSL #5
00012c  f8d01b00          LDR      r1,[r0,#0xb00]
000130  f0414104          ORR      r1,r1,#0x84000000
000134  f8c01b00          STR      r1,[r0,#0xb00]
                  |L15.312|
;;;742      }
;;;743      return HAL_OK;
000138  2000              MOVS     r0,#0
;;;744    }
00013a  bd30              POP      {r4,r5,pc}
;;;745    
                          ENDP

                  |L15.316|
                          DCD      0xe007ffff

                          AREA ||i.USB_EP0_OutStart||, CODE, READONLY, ALIGN=1

                  USB_EP0_OutStart PROC
;;;1052     */
;;;1053   HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
000000  2300              MOVS     r3,#0
;;;1054   {
;;;1055     USBx_OUTEP(0)->DOEPTSIZ = 0;
000002  f8c03b10          STR      r3,[r0,#0xb10]
;;;1056     USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
000006  f8d03b10          LDR      r3,[r0,#0xb10]
00000a  f4432300          ORR      r3,r3,#0x80000
00000e  f8c03b10          STR      r3,[r0,#0xb10]
;;;1057     USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
000012  f8d03b10          LDR      r3,[r0,#0xb10]
000016  f0430318          ORR      r3,r3,#0x18
00001a  f8c03b10          STR      r3,[r0,#0xb10]
;;;1058     USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
00001e  f8d03b10          LDR      r3,[r0,#0xb10]
000022  f04343c0          ORR      r3,r3,#0x60000000
000026  f8c03b10          STR      r3,[r0,#0xb10]
;;;1059     
;;;1060     if (dma == 1)
00002a  2901              CMP      r1,#1
00002c  d105              BNE      |L16.58|
;;;1061     {
;;;1062       USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
00002e  f8c02b14          STR      r2,[r0,#0xb14]
;;;1063       /* EP enable */
;;;1064       USBx_OUTEP(0)->DOEPCTL = 0x80008000;
000032  f04f2180          MOV      r1,#0x80008000
000036  f8c01b00          STR      r1,[r0,#0xb00]
                  |L16.58|
;;;1065     }
;;;1066     
;;;1067     return HAL_OK;  
00003a  2000              MOVS     r0,#0
;;;1068   }
00003c  4770              BX       lr
;;;1069   
                          ENDP


                          AREA ||i.USB_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_EPClearStall PROC
;;;833      */
;;;834    HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
000000  784b              LDRB     r3,[r1,#1]
;;;835    {
;;;836      if (ep->is_in == 1)
;;;837      {
;;;838        USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
000002  780a              LDRB     r2,[r1,#0]
000004  eb001242          ADD      r2,r0,r2,LSL #5
000008  2b01              CMP      r3,#1                 ;836
00000a  d00b              BEQ      |L17.36|
;;;839        if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
;;;840        {
;;;841           USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
;;;842        }    
;;;843      }
;;;844      else
;;;845      {
;;;846        USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
00000c  f8d23b00          LDR      r3,[r2,#0xb00]
000010  f4231300          BIC      r3,r3,#0x200000
000014  f8c23b00          STR      r3,[r2,#0xb00]
;;;847        if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
000018  78ca              LDRB     r2,[r1,#3]
00001a  2a03              CMP      r2,#3
00001c  d017              BEQ      |L17.78|
00001e  2a02              CMP      r2,#2
000020  d015              BEQ      |L17.78|
000022  e01d              B        |L17.96|
                  |L17.36|
000024  f8d23900          LDR      r3,[r2,#0x900]        ;838
000028  f4231300          BIC      r3,r3,#0x200000       ;838
00002c  f8c23900          STR      r3,[r2,#0x900]        ;838
000030  78ca              LDRB     r2,[r1,#3]            ;839
000032  2a03              CMP      r2,#3                 ;839
000034  d001              BEQ      |L17.58|
000036  2a02              CMP      r2,#2                 ;839
000038  d112              BNE      |L17.96|
                  |L17.58|
00003a  7809              LDRB     r1,[r1,#0]            ;841
00003c  eb001041          ADD      r0,r0,r1,LSL #5       ;841
000040  f8d01900          LDR      r1,[r0,#0x900]        ;841
000044  f0415180          ORR      r1,r1,#0x10000000     ;841
000048  f8c01900          STR      r1,[r0,#0x900]        ;841
00004c  e008              B        |L17.96|
                  |L17.78|
;;;848        {
;;;849          USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
00004e  7809              LDRB     r1,[r1,#0]
000050  eb001041          ADD      r0,r0,r1,LSL #5
000054  f8d01b00          LDR      r1,[r0,#0xb00]
000058  f0415180          ORR      r1,r1,#0x10000000
00005c  f8c01b00          STR      r1,[r0,#0xb00]
                  |L17.96|
;;;850        }    
;;;851      }
;;;852      return HAL_OK;
000060  2000              MOVS     r0,#0
;;;853    }
000062  4770              BX       lr
;;;854    
                          ENDP


                          AREA ||i.USB_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_EPSetStall PROC
;;;805      */
;;;806    HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
000000  784b              LDRB     r3,[r1,#1]
;;;807    {
;;;808      if (ep->is_in == 1)
;;;809      {
;;;810        if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)
000002  780a              LDRB     r2,[r1,#0]
000004  eb001242          ADD      r2,r0,r2,LSL #5
000008  2b01              CMP      r3,#1                 ;808
00000a  d014              BEQ      |L18.54|
;;;811        {
;;;812          USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
;;;813        } 
;;;814        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
;;;815      }
;;;816      else
;;;817      {
;;;818        if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
00000c  f8d23b00          LDR      r3,[r2,#0xb00]
000010  2b00              CMP      r3,#0
000012  db05              BLT      |L18.32|
;;;819        {
;;;820          USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
000014  f8d23b00          LDR      r3,[r2,#0xb00]
000018  f0234380          BIC      r3,r3,#0x40000000
00001c  f8c23b00          STR      r3,[r2,#0xb00]
                  |L18.32|
;;;821        } 
;;;822        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
000020  7809              LDRB     r1,[r1,#0]
000022  eb001041          ADD      r0,r0,r1,LSL #5
000026  f8d01b00          LDR      r1,[r0,#0xb00]
00002a  f4411100          ORR      r1,r1,#0x200000
00002e  f8c01b00          STR      r1,[r0,#0xb00]
                  |L18.50|
;;;823      }
;;;824      return HAL_OK;
000032  2000              MOVS     r0,#0
;;;825    }
000034  4770              BX       lr
                  |L18.54|
000036  f8d23900          LDR      r3,[r2,#0x900]        ;810
00003a  2b00              CMP      r3,#0                 ;810
00003c  db05              BLT      |L18.74|
00003e  f8d23900          LDR      r3,[r2,#0x900]        ;812
000042  f0234380          BIC      r3,r3,#0x40000000     ;812
000046  f8c23900          STR      r3,[r2,#0x900]        ;812
                  |L18.74|
00004a  7809              LDRB     r1,[r1,#0]            ;814
00004c  eb001041          ADD      r0,r0,r1,LSL #5       ;814
000050  f8d01900          LDR      r1,[r0,#0x900]        ;814
000054  f4411100          ORR      r1,r1,#0x200000       ;814
000058  f8c01900          STR      r1,[r0,#0x900]        ;814
00005c  e7e9              B        |L18.50|
;;;826    
                          ENDP


                          AREA ||i.USB_EPStartXfer||, CODE, READONLY, ALIGN=2

                  USB_EPStartXfer PROC
;;;547      */
;;;548    HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
000000  b578              PUSH     {r3-r6,lr}
;;;549    {
;;;550      uint16_t pktcnt = 0;
;;;551      
;;;552      /* IN endpoint */
;;;553      if (ep->is_in == 1)
000002  784e              LDRB     r6,[r1,#1]
;;;554      {
;;;555        /* Zero Length Packet? */
;;;556        if (ep->xfer_len == 0)
;;;557        {
;;;558          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
;;;559          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
;;;560          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
;;;561        }
;;;562        else
;;;563        {
;;;564          /* Program the transfer size and packet count
;;;565          * as follows: xfersize = N * maxpacket +
;;;566          * short_packet pktcnt = N + (short_packet
;;;567          * exist ? 1 : 0)
;;;568          */
;;;569          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
;;;570          USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
;;;571          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1)/ ep->maxpacket) << 19)) ;
000004  f06f4560          MVN      r5,#0xe0000000
000008  4c83              LDR      r4,|L19.536|
00000a  780b              LDRB     r3,[r1,#0]            ;558
00000c  eb001343          ADD      r3,r0,r3,LSL #5       ;558
000010  2e01              CMP      r6,#1                 ;553
000012  d02f              BEQ      |L19.116|
;;;572          USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
;;;573          
;;;574          if (ep->type == EP_TYPE_ISOC)
;;;575          {
;;;576            USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
;;;577            USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
;;;578          }       
;;;579        }
;;;580    
;;;581        if (dma == 1)
;;;582        {
;;;583          USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
;;;584        }
;;;585        else
;;;586        {
;;;587          if (ep->type != EP_TYPE_ISOC)
;;;588          {
;;;589            /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;590            if (ep->xfer_len > 0)
;;;591            {
;;;592              USBx_DEVICE->DIEPEMPMSK |= (1 << ep->num);
;;;593            }
;;;594          }
;;;595        }
;;;596    
;;;597        if (ep->type == EP_TYPE_ISOC)
;;;598        {
;;;599          if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
;;;600          {
;;;601            USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
;;;602          }
;;;603          else
;;;604          {
;;;605            USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
;;;606          }
;;;607        } 
;;;608        
;;;609        /* EP enable, IN data in FIFO */
;;;610        USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
;;;611        
;;;612        if (ep->type == EP_TYPE_ISOC)
;;;613        {
;;;614          USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
;;;615        }    
;;;616      }
;;;617      else /* OUT endpoint */
;;;618      {
;;;619        /* Program the transfer size and packet count as follows:
;;;620        * pktcnt = N
;;;621        * xfersize = N * maxpacket
;;;622        */  
;;;623        USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
000014  f8d36b10          LDR      r6,[r3,#0xb10]
000018  f36f0612          BFC      r6,#0,#19
00001c  f8c36b10          STR      r6,[r3,#0xb10]
;;;624        USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
000020  780b              LDRB     r3,[r1,#0]
000022  eb001343          ADD      r3,r0,r3,LSL #5
000026  f8d36b10          LDR      r6,[r3,#0xb10]
00002a  4026              ANDS     r6,r6,r4
00002c  f8c36b10          STR      r6,[r3,#0xb10]
;;;625          
;;;626        if (ep->xfer_len == 0)
000030  694b              LDR      r3,[r1,#0x14]
000032  2b00              CMP      r3,#0
000034  d07d              BEQ      |L19.306|
;;;627        {
;;;628          USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
;;;629          USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
;;;630        }
;;;631        else
;;;632        {
;;;633          pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
000036  688c              LDR      r4,[r1,#8]
000038  4423              ADD      r3,r3,r4
00003a  1e5b              SUBS     r3,r3,#1
00003c  fbb3f3f4          UDIV     r3,r3,r4
000040  b29b              UXTH     r3,r3
;;;634          USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19)); ;
000042  780c              LDRB     r4,[r1,#0]
000044  eb001444          ADD      r4,r0,r4,LSL #5
000048  f8d46b10          LDR      r6,[r4,#0xb10]
00004c  ea0545c3          AND      r5,r5,r3,LSL #19
000050  432e              ORRS     r6,r6,r5
000052  f8c46b10          STR      r6,[r4,#0xb10]
;;;635          USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
000056  780c              LDRB     r4,[r1,#0]
000058  eb001444          ADD      r4,r0,r4,LSL #5
00005c  f8d45b10          LDR      r5,[r4,#0xb10]
000060  688e              LDR      r6,[r1,#8]
000062  435e              MULS     r6,r3,r6
000064  f3c60312          UBFX     r3,r6,#0,#19
000068  431d              ORRS     r5,r5,r3
00006a  f8c45b10          STR      r5,[r4,#0xb10]
                  |L19.110|
;;;636        }
;;;637    
;;;638        if (dma == 1)
00006e  2a01              CMP      r2,#1
000070  d073              BEQ      |L19.346|
000072  e0b2              B        |L19.474|
                  |L19.116|
000074  694e              LDR      r6,[r1,#0x14]         ;556
000076  b366              CBZ      r6,|L19.210|
000078  f8d36910          LDR      r6,[r3,#0x910]        ;569
00007c  f36f0612          BFC      r6,#0,#19             ;569
000080  f8c36910          STR      r6,[r3,#0x910]        ;569
000084  780b              LDRB     r3,[r1,#0]            ;570
000086  eb001343          ADD      r3,r0,r3,LSL #5       ;570
00008a  f8d36910          LDR      r6,[r3,#0x910]        ;570
00008e  4026              ANDS     r6,r6,r4              ;570
000090  f8c36910          STR      r6,[r3,#0x910]        ;570
000094  694c              LDR      r4,[r1,#0x14]         ;571
000096  688b              LDR      r3,[r1,#8]            ;571
000098  441c              ADD      r4,r4,r3              ;571
00009a  1e64              SUBS     r4,r4,#1              ;571
00009c  fbb4f3f3          UDIV     r3,r4,r3              ;571
0000a0  ea0544c3          AND      r4,r5,r3,LSL #19      ;571
0000a4  780b              LDRB     r3,[r1,#0]            ;571
0000a6  eb001343          ADD      r3,r0,r3,LSL #5       ;571
0000aa  f8d35910          LDR      r5,[r3,#0x910]        ;571
0000ae  432c              ORRS     r4,r4,r5              ;571
0000b0  f8c34910          STR      r4,[r3,#0x910]        ;571
0000b4  780b              LDRB     r3,[r1,#0]            ;572
0000b6  eb001343          ADD      r3,r0,r3,LSL #5       ;572
0000ba  f8d34910          LDR      r4,[r3,#0x910]        ;572
0000be  694d              LDR      r5,[r1,#0x14]         ;572
0000c0  f3c50512          UBFX     r5,r5,#0,#19          ;572
0000c4  432c              ORRS     r4,r4,r5              ;572
0000c6  f8c34910          STR      r4,[r3,#0x910]        ;572
0000ca  78cb              LDRB     r3,[r1,#3]            ;574
0000cc  2b01              CMP      r3,#1                 ;574
0000ce  d016              BEQ      |L19.254|
0000d0  e027              B        |L19.290|
                  |L19.210|
0000d2  f8d35910          LDR      r5,[r3,#0x910]        ;558
0000d6  4025              ANDS     r5,r5,r4              ;558
0000d8  f8c35910          STR      r5,[r3,#0x910]        ;558
0000dc  780b              LDRB     r3,[r1,#0]            ;559
0000de  eb001343          ADD      r3,r0,r3,LSL #5       ;559
0000e2  f8d34910          LDR      r4,[r3,#0x910]        ;559
0000e6  f4442400          ORR      r4,r4,#0x80000        ;559
0000ea  f8c34910          STR      r4,[r3,#0x910]        ;559
0000ee  780b              LDRB     r3,[r1,#0]            ;560
0000f0  eb001343          ADD      r3,r0,r3,LSL #5       ;560
0000f4  f8d34910          LDR      r4,[r3,#0x910]        ;560
0000f8  f36f0412          BFC      r4,#0,#19             ;560
0000fc  e00f              B        |L19.286|
                  |L19.254|
0000fe  780b              LDRB     r3,[r1,#0]            ;576
000100  eb001343          ADD      r3,r0,r3,LSL #5       ;576
000104  f8d34910          LDR      r4,[r3,#0x910]        ;576
000108  f02444c0          BIC      r4,r4,#0x60000000     ;576
00010c  f8c34910          STR      r4,[r3,#0x910]        ;576
000110  780b              LDRB     r3,[r1,#0]            ;577
000112  eb001343          ADD      r3,r0,r3,LSL #5       ;577
000116  f8d34910          LDR      r4,[r3,#0x910]        ;577
00011a  f0445400          ORR      r4,r4,#0x20000000     ;577
                  |L19.286|
00011e  f8c34910          STR      r4,[r3,#0x910]        ;577
                  |L19.290|
000122  2a01              CMP      r2,#1                 ;581
000124  d012              BEQ      |L19.332|
000126  78cb              LDRB     r3,[r1,#3]            ;587
000128  2b01              CMP      r3,#1                 ;587
00012a  d017              BEQ      |L19.348|
00012c  694b              LDR      r3,[r1,#0x14]         ;590
00012e  b32b              CBZ      r3,|L19.380|
000130  e000              B        |L19.308|
                  |L19.306|
000132  e037              B        |L19.420|
                  |L19.308|
000134  f8d03834          LDR      r3,[r0,#0x834]        ;592
000138  780d              LDRB     r5,[r1,#0]            ;592
00013a  2401              MOVS     r4,#1                 ;592
00013c  40ac              LSLS     r4,r4,r5              ;592
00013e  4323              ORRS     r3,r3,r4              ;592
000140  f8c03834          STR      r3,[r0,#0x834]        ;592
                  |L19.324|
000144  78cb              LDRB     r3,[r1,#3]            ;597
000146  2b01              CMP      r3,#1                 ;597
000148  d008              BEQ      |L19.348|
00014a  e017              B        |L19.380|
                  |L19.332|
00014c  780c              LDRB     r4,[r1,#0]            ;583
00014e  eb001444          ADD      r4,r0,r4,LSL #5       ;583
000152  690b              LDR      r3,[r1,#0x10]         ;583
000154  f8c43914          STR      r3,[r4,#0x914]        ;583
000158  e7f4              B        |L19.324|
                  |L19.346|
00015a  e038              B        |L19.462|
                  |L19.348|
00015c  f8d03808          LDR      r3,[r0,#0x808]        ;599
000160  05db              LSLS     r3,r3,#23             ;599
000162  780b              LDRB     r3,[r1,#0]            ;605
000164  eb001343          ADD      r3,r0,r3,LSL #5       ;605
000168  f8d34900          LDR      r4,[r3,#0x900]        ;605
00016c  d402              BMI      |L19.372|
00016e  f0445400          ORR      r4,r4,#0x20000000     ;601
000172  e001              B        |L19.376|
                  |L19.372|
000174  f0445480          ORR      r4,r4,#0x10000000     ;605
                  |L19.376|
000178  f8c34900          STR      r4,[r3,#0x900]        ;601
                  |L19.380|
00017c  780b              LDRB     r3,[r1,#0]            ;610
00017e  eb001343          ADD      r3,r0,r3,LSL #5       ;610
000182  f8d34900          LDR      r4,[r3,#0x900]        ;610
000186  f0444404          ORR      r4,r4,#0x84000000     ;610
00018a  f8c34900          STR      r4,[r3,#0x900]        ;610
00018e  78cb              LDRB     r3,[r1,#3]            ;612
000190  2b01              CMP      r3,#1                 ;612
000192  d13e              BNE      |L19.530|
000194  9200              STR      r2,[sp,#0]            ;614
000196  8a8a              LDRH     r2,[r1,#0x14]         ;614
000198  b293              UXTH     r3,r2                 ;614
00019a  780a              LDRB     r2,[r1,#0]            ;614
00019c  68c9              LDR      r1,[r1,#0xc]          ;614
00019e  f7fffffe          BL       USB_WritePacket
0001a2  e036              B        |L19.530|
                  |L19.420|
0001a4  780b              LDRB     r3,[r1,#0]            ;628
0001a6  eb001343          ADD      r3,r0,r3,LSL #5       ;628
0001aa  f8d34b10          LDR      r4,[r3,#0xb10]        ;628
0001ae  688d              LDR      r5,[r1,#8]            ;628
0001b0  f3c50512          UBFX     r5,r5,#0,#19          ;628
0001b4  432c              ORRS     r4,r4,r5              ;628
0001b6  f8c34b10          STR      r4,[r3,#0xb10]        ;628
0001ba  780b              LDRB     r3,[r1,#0]            ;629
0001bc  eb001343          ADD      r3,r0,r3,LSL #5       ;629
0001c0  f8d34b10          LDR      r4,[r3,#0xb10]        ;629
0001c4  f4442400          ORR      r4,r4,#0x80000        ;629
0001c8  f8c34b10          STR      r4,[r3,#0xb10]        ;629
0001cc  e74f              B        |L19.110|
                  |L19.462|
;;;639        {
;;;640          USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
0001ce  780b              LDRB     r3,[r1,#0]
0001d0  eb001343          ADD      r3,r0,r3,LSL #5
0001d4  68ca              LDR      r2,[r1,#0xc]
0001d6  f8c32b14          STR      r2,[r3,#0xb14]
                  |L19.474|
;;;641        }
;;;642        
;;;643        if (ep->type == EP_TYPE_ISOC)
0001da  78ca              LDRB     r2,[r1,#3]
0001dc  2a01              CMP      r2,#1
0001de  d10f              BNE      |L19.512|
;;;644        {
;;;645          if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
0001e0  f8d02808          LDR      r2,[r0,#0x808]
0001e4  05d2              LSLS     r2,r2,#23
;;;646          {
;;;647            USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
;;;648          }
;;;649          else
;;;650          {
;;;651            USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
0001e6  780a              LDRB     r2,[r1,#0]
0001e8  eb001242          ADD      r2,r0,r2,LSL #5
0001ec  f8d23b00          LDR      r3,[r2,#0xb00]
0001f0  d402              BMI      |L19.504|
0001f2  f0435300          ORR      r3,r3,#0x20000000     ;647
0001f6  e001              B        |L19.508|
                  |L19.504|
0001f8  f0435380          ORR      r3,r3,#0x10000000
                  |L19.508|
0001fc  f8c23b00          STR      r3,[r2,#0xb00]        ;647
                  |L19.512|
;;;652          }
;;;653        }
;;;654        /* EP enable */
;;;655        USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
000200  7809              LDRB     r1,[r1,#0]
000202  eb001041          ADD      r0,r0,r1,LSL #5
000206  f8d01b00          LDR      r1,[r0,#0xb00]
00020a  f0414104          ORR      r1,r1,#0x84000000
00020e  f8c01b00          STR      r1,[r0,#0xb00]
                  |L19.530|
;;;656      }
;;;657      return HAL_OK;
000212  2000              MOVS     r0,#0
;;;658    }
000214  bd78              POP      {r3-r6,pc}
;;;659    
                          ENDP

000216  0000              DCW      0x0000
                  |L19.536|
                          DCD      0xe007ffff

                          AREA ||i.USB_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_EnableGlobalInt PROC
;;;145      */
;;;146    HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
000000  6881              LDR      r1,[r0,#8]
;;;147    {
;;;148      USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
000002  f0410101          ORR      r1,r1,#1
000006  6081              STR      r1,[r0,#8]
;;;149      return HAL_OK;
000008  2000              MOVS     r0,#0
;;;150    }
00000a  4770              BX       lr
;;;151    
                          ENDP


                          AREA ||i.USB_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushRxFifo PROC
;;;352      */
;;;353    HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
000000  2100              MOVS     r1,#0
;;;354    {
;;;355      uint32_t count = 0;
;;;356      
;;;357      USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
000002  2210              MOVS     r2,#0x10
000004  6102              STR      r2,[r0,#0x10]
;;;358      
;;;359      do
;;;360      {
;;;361        if (++count > 200000)
000006  4a05              LDR      r2,|L21.28|
                  |L21.8|
000008  1c49              ADDS     r1,r1,#1
00000a  4291              CMP      r1,r2
00000c  d901              BLS      |L21.18|
;;;362        {
;;;363          return HAL_TIMEOUT;
00000e  2003              MOVS     r0,#3
;;;364        }
;;;365      }
;;;366      while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
;;;367      
;;;368      return HAL_OK;
;;;369    }
000010  4770              BX       lr
                  |L21.18|
000012  6903              LDR      r3,[r0,#0x10]         ;366
000014  06db              LSLS     r3,r3,#27             ;366
000016  d4f7              BMI      |L21.8|
000018  2000              MOVS     r0,#0                 ;368
00001a  4770              BX       lr
;;;370    
                          ENDP

                  |L21.28|
                          DCD      0x00030d40

                          AREA ||i.USB_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_FlushTxFifo PROC
;;;328      */
;;;329    HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
000000  2200              MOVS     r2,#0
;;;330    {
;;;331      uint32_t count = 0;
;;;332     
;;;333      USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 5 )); 
000002  2320              MOVS     r3,#0x20
000004  ea431141          ORR      r1,r3,r1,LSL #5
000008  6101              STR      r1,[r0,#0x10]
;;;334     
;;;335      do
;;;336      {
;;;337        if (++count > 200000)
00000a  4905              LDR      r1,|L22.32|
                  |L22.12|
00000c  1c52              ADDS     r2,r2,#1
00000e  428a              CMP      r2,r1
000010  d901              BLS      |L22.22|
;;;338        {
;;;339          return HAL_TIMEOUT;
000012  2003              MOVS     r0,#3
;;;340        }
;;;341      }
;;;342      while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
;;;343      
;;;344      return HAL_OK;
;;;345    }
000014  4770              BX       lr
                  |L22.22|
000016  6903              LDR      r3,[r0,#0x10]         ;342
000018  069b              LSLS     r3,r3,#26             ;342
00001a  d4f7              BMI      |L22.12|
00001c  2000              MOVS     r0,#0                 ;344
00001e  4770              BX       lr
;;;346    
                          ENDP

                  |L22.32|
                          DCD      0x00030d40

                          AREA ||i.USB_GetCurrentFrame||, CODE, READONLY, ALIGN=1

                  USB_GetCurrentFrame PROC
;;;1289   */
;;;1290   uint32_t USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx)
000000  f8d00408          LDR      r0,[r0,#0x408]
;;;1291   {
;;;1292     return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
000004  b280              UXTH     r0,r0
;;;1293   }
000006  4770              BX       lr
;;;1294   
                          ENDP


                          AREA ||i.USB_GetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetDevSpeed PROC
;;;397      */
;;;398    uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
000000  2100              MOVS     r1,#0
;;;399    	{
;;;400    	uint8_t speed = 0;
;;;401    
;;;402    	if( (USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ )
000002  f8d02808          LDR      r2,[r0,#0x808]
000006  f0120f06          TST      r2,#6
00000a  d015              BEQ      |L24.56|
;;;403    		{
;;;404    		speed = USB_OTG_SPEED_HIGH;
;;;405    		}
;;;406    	else if( ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
00000c  f8d02808          LDR      r2,[r0,#0x808]
000010  f3c20241          UBFX     r2,r2,#1,#2
000014  2a01              CMP      r2,#1
000016  d00c              BEQ      |L24.50|
;;;407    					 ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ)            )
000018  f8d02808          LDR      r2,[r0,#0x808]
00001c  f3c20241          UBFX     r2,r2,#1,#2
000020  2a03              CMP      r2,#3
000022  d006              BEQ      |L24.50|
;;;408    		{
;;;409    		speed = USB_OTG_SPEED_FULL;
;;;410    		}
;;;411    	else if( (USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ )
000024  f8d00808          LDR      r0,[r0,#0x808]
000028  f3c00041          UBFX     r0,r0,#1,#2
00002c  2802              CMP      r0,#2
00002e  d002              BEQ      |L24.54|
000030  e002              B        |L24.56|
                  |L24.50|
000032  2103              MOVS     r1,#3                 ;409
000034  e000              B        |L24.56|
                  |L24.54|
;;;412    		{
;;;413    		speed = USB_OTG_SPEED_LOW;
000036  2102              MOVS     r1,#2
                  |L24.56|
;;;414    		}
;;;415    
;;;416    	return speed;
000038  4608              MOV      r0,r1
;;;417    	}
00003a  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.USB_GetHostSpeed||, CODE, READONLY, ALIGN=1

                  USB_GetHostSpeed PROC
;;;1276     */
;;;1277   uint32_t USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx)
000000  b508              PUSH     {r3,lr}
;;;1278   {
;;;1279     __IO uint32_t hprt0;
;;;1280     
;;;1281     hprt0 = USBx_HPRT0;
000002  f8d00440          LDR      r0,[r0,#0x440]
;;;1282     return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
000006  9000              STR      r0,[sp,#0]
000008  f3c04041          UBFX     r0,r0,#17,#2
;;;1283   }
00000c  bd08              POP      {r3,pc}
;;;1284   
                          ENDP


                          AREA ||i.USB_GetMode||, CODE, READONLY, ALIGN=1

                  USB_GetMode PROC
;;;1016     */
;;;1017   uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
000000  6940              LDR      r0,[r0,#0x14]
;;;1018   {
;;;1019     return ((USBx->GINTSTS ) & 0x1);
000002  f0000001          AND      r0,r0,#1
;;;1020   }
000006  4770              BX       lr
;;;1021   
                          ENDP


                          AREA ||i.USB_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_HC_Halt PROC
;;;1546     */
;;;1547   HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1548   {
000002  4602              MOV      r2,r0
;;;1549     uint32_t count = 0;
000004  2300              MOVS     r3,#0
;;;1550     
;;;1551     /* Check for space in the request queue to issue the halt. */
;;;1552     if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))
000006  f50260a0          ADD      r0,r2,#0x500
00000a  eb001041          ADD      r0,r0,r1,LSL #5
00000e  6800              LDR      r0,[r0,#0]
000010  2000              MOVS     r0,#0
000012  b938              CBNZ     r0,|L27.36|
000014  f50260a0          ADD      r0,r2,#0x500
000018  eb001041          ADD      r0,r0,r1,LSL #5
00001c  6800              LDR      r0,[r0,#0]
00001e  f4002000          AND      r0,r0,#0x80000
000022  b3c8              CBZ      r0,|L27.152|
                  |L27.36|
;;;1553     {
;;;1554       USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
000024  f50260a0          ADD      r0,r2,#0x500
000028  eb001041          ADD      r0,r0,r1,LSL #5
00002c  6800              LDR      r0,[r0,#0]
00002e  f0404480          ORR      r4,r0,#0x40000000
000032  f50260a0          ADD      r0,r2,#0x500
000036  eb001041          ADD      r0,r0,r1,LSL #5
00003a  6004              STR      r4,[r0,#0]
;;;1555       
;;;1556       if ((USBx->HNPTXSTS & 0xFFFF) == 0)
00003c  6ad0              LDR      r0,[r2,#0x2c]
00003e  b280              UXTH     r0,r0
000040  bb58              CBNZ     r0,|L27.154|
;;;1557       {
;;;1558         USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
000042  f50260a0          ADD      r0,r2,#0x500
000046  eb001041          ADD      r0,r0,r1,LSL #5
00004a  6800              LDR      r0,[r0,#0]
00004c  f0204400          BIC      r4,r0,#0x80000000
000050  f50260a0          ADD      r0,r2,#0x500
000054  eb001041          ADD      r0,r0,r1,LSL #5
000058  6004              STR      r4,[r0,#0]
;;;1559         USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
00005a  f50260a0          ADD      r0,r2,#0x500
00005e  eb001041          ADD      r0,r0,r1,LSL #5
000062  6800              LDR      r0,[r0,#0]
000064  f0404400          ORR      r4,r0,#0x80000000
000068  f50260a0          ADD      r0,r2,#0x500
00006c  eb001041          ADD      r0,r0,r1,LSL #5
000070  6004              STR      r4,[r0,#0]
;;;1560         USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
000072  f50260a0          ADD      r0,r2,#0x500
000076  eb001041          ADD      r0,r0,r1,LSL #5
00007a  6800              LDR      r0,[r0,#0]
00007c  f4204400          BIC      r4,r0,#0x8000
000080  f50260a0          ADD      r0,r2,#0x500
000084  eb001041          ADD      r0,r0,r1,LSL #5
000088  6004              STR      r4,[r0,#0]
;;;1561         do 
00008a  bf00              NOP      
                  |L27.140|
;;;1562         {
;;;1563           if (++count > 1000) 
00008c  1c58              ADDS     r0,r3,#1
00008e  4603              MOV      r3,r0
000090  f5b07f7a          CMP      r0,#0x3e8
000094  d902              BLS      |L27.156|
;;;1564           {
;;;1565             break;
000096  e00b              B        |L27.176|
                  |L27.152|
000098  e018              B        |L27.204|
                  |L27.154|
00009a  e00a              B        |L27.178|
                  |L27.156|
;;;1566           }
;;;1567         } 
;;;1568         while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
00009c  f50260a0          ADD      r0,r2,#0x500
0000a0  eb001041          ADD      r0,r0,r1,LSL #5
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f0004000          AND      r0,r0,#0x80000000
0000aa  f1b04f00          CMP      r0,#0x80000000
0000ae  d0ed              BEQ      |L27.140|
                  |L27.176|
0000b0  e060              B        |L27.372|
                  |L27.178|
;;;1569       }
;;;1570       else
;;;1571       {
;;;1572         USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
0000b2  f50260a0          ADD      r0,r2,#0x500
0000b6  eb001041          ADD      r0,r0,r1,LSL #5
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0404400          ORR      r4,r0,#0x80000000
0000c0  f50260a0          ADD      r0,r2,#0x500
0000c4  eb001041          ADD      r0,r0,r1,LSL #5
0000c8  6004              STR      r4,[r0,#0]
0000ca  e053              B        |L27.372|
                  |L27.204|
;;;1573       }
;;;1574     }
;;;1575     else
;;;1576     {
;;;1577       USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
0000cc  f50260a0          ADD      r0,r2,#0x500
0000d0  eb001041          ADD      r0,r0,r1,LSL #5
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0404480          ORR      r4,r0,#0x40000000
0000da  f50260a0          ADD      r0,r2,#0x500
0000de  eb001041          ADD      r0,r0,r1,LSL #5
0000e2  6004              STR      r4,[r0,#0]
;;;1578       
;;;1579       if ((USBx_HOST->HPTXSTS & 0xFFFF) == 0)
0000e4  f44f6082          MOV      r0,#0x410
0000e8  5880              LDR      r0,[r0,r2]
0000ea  b280              UXTH     r0,r0
0000ec  bba8              CBNZ     r0,|L27.346|
;;;1580       {
;;;1581         USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
0000ee  f50260a0          ADD      r0,r2,#0x500
0000f2  eb001041          ADD      r0,r0,r1,LSL #5
0000f6  6800              LDR      r0,[r0,#0]
0000f8  f0204400          BIC      r4,r0,#0x80000000
0000fc  f50260a0          ADD      r0,r2,#0x500
000100  eb001041          ADD      r0,r0,r1,LSL #5
000104  6004              STR      r4,[r0,#0]
;;;1582         USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
000106  f50260a0          ADD      r0,r2,#0x500
00010a  eb001041          ADD      r0,r0,r1,LSL #5
00010e  6800              LDR      r0,[r0,#0]
000110  f0404400          ORR      r4,r0,#0x80000000
000114  f50260a0          ADD      r0,r2,#0x500
000118  eb001041          ADD      r0,r0,r1,LSL #5
00011c  6004              STR      r4,[r0,#0]
;;;1583         USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
00011e  f50260a0          ADD      r0,r2,#0x500
000122  eb001041          ADD      r0,r0,r1,LSL #5
000126  6800              LDR      r0,[r0,#0]
000128  f4204400          BIC      r4,r0,#0x8000
00012c  f50260a0          ADD      r0,r2,#0x500
000130  eb001041          ADD      r0,r0,r1,LSL #5
000134  6004              STR      r4,[r0,#0]
;;;1584         do 
000136  bf00              NOP      
                  |L27.312|
;;;1585         {
;;;1586           if (++count > 1000) 
000138  1c58              ADDS     r0,r3,#1
00013a  4603              MOV      r3,r0
00013c  f5b07f7a          CMP      r0,#0x3e8
000140  d900              BLS      |L27.324|
;;;1587           {
;;;1588             break;
000142  e009              B        |L27.344|
                  |L27.324|
;;;1589           }
;;;1590         } 
;;;1591         while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
000144  f50260a0          ADD      r0,r2,#0x500
000148  eb001041          ADD      r0,r0,r1,LSL #5
00014c  6800              LDR      r0,[r0,#0]
00014e  f0004000          AND      r0,r0,#0x80000000
000152  f1b04f00          CMP      r0,#0x80000000
000156  d0ef              BEQ      |L27.312|
                  |L27.344|
000158  e00c              B        |L27.372|
                  |L27.346|
00015a  e7ff              B        |L27.348|
                  |L27.348|
;;;1592       }
;;;1593       else
;;;1594       {
;;;1595          USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
00015c  f50260a0          ADD      r0,r2,#0x500
000160  eb001041          ADD      r0,r0,r1,LSL #5
000164  6800              LDR      r0,[r0,#0]
000166  f0404400          ORR      r4,r0,#0x80000000
00016a  f50260a0          ADD      r0,r2,#0x500
00016e  eb001041          ADD      r0,r0,r1,LSL #5
000172  6004              STR      r4,[r0,#0]
                  |L27.372|
;;;1596       }
;;;1597     }
;;;1598     
;;;1599     return HAL_OK;
000174  2000              MOVS     r0,#0
;;;1600   }
000176  bd10              POP      {r4,pc}
;;;1601   
                          ENDP


                          AREA ||i.USB_HC_Init||, CODE, READONLY, ALIGN=2

                  USB_HC_Init PROC
;;;1318     */
;;;1319   HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
000000  b5f0              PUSH     {r4-r7,lr}
;;;1320                                 uint8_t ch_num,
;;;1321                                 uint8_t epnum,
;;;1322                                 uint8_t dev_address,
;;;1323                                 uint8_t speed,
;;;1324                                 uint8_t ep_type,
;;;1325                                 uint16_t mps)
;;;1326   {
000002  e9dd5606          LDRD     r5,r6,[sp,#0x18]
;;;1327       
;;;1328     /* Clear old interrupt conditions for this host channel. */
;;;1329     USBx_HC(ch_num)->HCINT = 0xFFFFFFFF;
000006  f04f3cff          MOV      r12,#0xffffffff
00000a  eb001441          ADD      r4,r0,r1,LSL #5
00000e  9f05              LDR      r7,[sp,#0x14]
000010  f8c4c508          STR      r12,[r4,#0x508]
000014  b135              CBZ      r5,|L28.36|
;;;1330     
;;;1331     /* Enable channel interrupts required for this transfer. */
;;;1332     switch (ep_type) 
000016  2d01              CMP      r5,#1
000018  d021              BEQ      |L28.94|
00001a  2d02              CMP      r5,#2
00001c  d002              BEQ      |L28.36|
00001e  2d03              CMP      r5,#3
000020  d12a              BNE      |L28.120|
000022  e014              B        |L28.78|
                  |L28.36|
;;;1333     {
;;;1334     case EP_TYPE_CTRL:
;;;1335     case EP_TYPE_BULK:
;;;1336       
;;;1337       USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
000024  f2404c9d          MOV      r12,#0x49d
000028  f8c4c50c          STR      r12,[r4,#0x50c]
;;;1338                                   USB_OTG_HCINTMSK_STALLM |\
;;;1339                                   USB_OTG_HCINTMSK_TXERRM |\
;;;1340                                   USB_OTG_HCINTMSK_DTERRM |\
;;;1341                                   USB_OTG_HCINTMSK_AHBERR |\
;;;1342                                   USB_OTG_HCINTMSK_NAKM ;
;;;1343    
;;;1344       if (epnum & 0x80) 
00002c  ea5f6c02          LSLS     r12,r2,#24
000030  d505              BPL      |L28.62|
;;;1345       {
;;;1346         USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
000032  bf00              NOP      
                  |L28.52|
000034  f8d4c50c          LDR      r12,[r4,#0x50c]
000038  f44c7c80          ORR      r12,r12,#0x100
00003c  e01a              B        |L28.116|
                  |L28.62|
;;;1347       } 
;;;1348       else 
;;;1349       {
;;;1350         if(USBx != USB_OTG_FS)
00003e  f1b04fa0          CMP      r0,#0x50000000
000042  d019              BEQ      |L28.120|
;;;1351         {
;;;1352           USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
000044  f8d4c50c          LDR      r12,[r4,#0x50c]
000048  f04c0c60          ORR      r12,r12,#0x60
00004c  e012              B        |L28.116|
                  |L28.78|
;;;1353         }
;;;1354       }
;;;1355       break;
;;;1356     case EP_TYPE_INTR:
;;;1357       
;;;1358       USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
00004e  f2406c9d          MOV      r12,#0x69d
000052  f8c4c50c          STR      r12,[r4,#0x50c]
;;;1359                                   USB_OTG_HCINTMSK_STALLM |\
;;;1360                                   USB_OTG_HCINTMSK_TXERRM |\
;;;1361                                   USB_OTG_HCINTMSK_DTERRM |\
;;;1362                                   USB_OTG_HCINTMSK_NAKM   |\
;;;1363                                   USB_OTG_HCINTMSK_AHBERR |\
;;;1364                                   USB_OTG_HCINTMSK_FRMORM ;    
;;;1365       
;;;1366       if (epnum & 0x80) 
000056  ea5f6c02          LSLS     r12,r2,#24
00005a  d4eb              BMI      |L28.52|
00005c  e00c              B        |L28.120|
                  |L28.94|
;;;1367       {
;;;1368         USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
;;;1369       }
;;;1370       
;;;1371       break;
;;;1372     case EP_TYPE_ISOC:
;;;1373       
;;;1374       USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
00005e  f2402c25          MOV      r12,#0x225
000062  f8c4c50c          STR      r12,[r4,#0x50c]
;;;1375                                   USB_OTG_HCINTMSK_ACKM   |\
;;;1376                                   USB_OTG_HCINTMSK_AHBERR |\
;;;1377                                   USB_OTG_HCINTMSK_FRMORM ;   
;;;1378       
;;;1379       if (epnum & 0x80) 
000066  ea5f6c02          LSLS     r12,r2,#24
00006a  d505              BPL      |L28.120|
;;;1380       {
;;;1381         USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);      
00006c  f8d4c50c          LDR      r12,[r4,#0x50c]
000070  f44c7cc0          ORR      r12,r12,#0x180
                  |L28.116|
000074  f8c4c50c          STR      r12,[r4,#0x50c]
                  |L28.120|
;;;1382       }
;;;1383       break;
;;;1384     }
;;;1385     
;;;1386     /* Enable the top level host channel interrupt. */
;;;1387     USBx_HOST->HAINTMSK |= (1 << ch_num);
000078  f8d0c418          LDR      r12,[r0,#0x418]
00007c  f04f0e01          MOV      lr,#1
000080  fa0efe01          LSL      lr,lr,r1
000084  ea4c0c0e          ORR      r12,r12,lr
000088  f8c0c418          STR      r12,[r0,#0x418]
;;;1388     
;;;1389     /* Make sure host channel interrupts are enabled. */
;;;1390     USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
00008c  6981              LDR      r1,[r0,#0x18]
00008e  f0417100          ORR      r1,r1,#0x2000000
000092  6181              STR      r1,[r0,#0x18]
;;;1391     
;;;1392     /* Program the HCCHAR register */
;;;1393     USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
000094  f04f50fe          MOV      r0,#0x1fc00000
000098  ea005083          AND      r0,r0,r3,LSL #22
00009c  f44f41f0          MOV      r1,#0x7800
0000a0  ea0121c2          AND      r1,r1,r2,LSL #11
0000a4  4308              ORRS     r0,r0,r1
0000a6  f44f4100          MOV      r1,#0x8000
0000aa  ea012102          AND      r1,r1,r2,LSL #8
0000ae  4308              ORRS     r0,r0,r1
0000b0  2f02              CMP      r7,#2
0000b2  d010              BEQ      |L28.214|
0000b4  f05f0100          MOVS.W   r1,#0
                  |L28.184|
0000b8  ea404041          ORR      r0,r0,r1,LSL #17
0000bc  f44f2140          MOV      r1,#0xc0000
0000c0  ea014185          AND      r1,r1,r5,LSL #18
0000c4  4308              ORRS     r0,r0,r1
0000c6  f3c6010a          UBFX     r1,r6,#0,#11
0000ca  4308              ORRS     r0,r0,r1
0000cc  f8c40500          STR      r0,[r4,#0x500]
;;;1394                                (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
;;;1395                                ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
;;;1396                                (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
;;;1397                                ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
;;;1398                                (mps & USB_OTG_HCCHAR_MPSIZ));
;;;1399       
;;;1400     if (ep_type == EP_TYPE_INTR)
0000d0  2d03              CMP      r5,#3
0000d2  d002              BEQ      |L28.218|
0000d4  e007              B        |L28.230|
                  |L28.214|
0000d6  2101              MOVS     r1,#1                 ;1393
0000d8  e7ee              B        |L28.184|
                  |L28.218|
;;;1401     {
;;;1402       USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
0000da  f8d40500          LDR      r0,[r4,#0x500]
0000de  f0405000          ORR      r0,r0,#0x20000000
0000e2  f8c40500          STR      r0,[r4,#0x500]
                  |L28.230|
;;;1403     }
;;;1404   
;;;1405     return HAL_OK; 
0000e6  2000              MOVS     r0,#0
;;;1406   }
0000e8  bdf0              POP      {r4-r7,pc}
;;;1407   
                          ENDP


                          AREA ||i.USB_HC_ReadInterrupt||, CODE, READONLY, ALIGN=1

                  USB_HC_ReadInterrupt PROC
;;;1534     */
;;;1535   uint32_t USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx)
000000  4601              MOV      r1,r0
;;;1536   {
;;;1537     return ((USBx_HOST->HAINT) & 0xFFFF);
000002  f2404014          MOV      r0,#0x414
000006  5840              LDR      r0,[r0,r1]
000008  b280              UXTH     r0,r0
;;;1538   }
00000a  4770              BX       lr
;;;1539   
                          ENDP


                          AREA ||i.USB_HC_StartXfer||, CODE, READONLY, ALIGN=2

                  USB_HC_StartXfer PROC
;;;1424   #endif /* __CC_ARM */
;;;1425   HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
000000  e92d47f8          PUSH     {r3-r10,lr}
;;;1426   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;1427     uint8_t  is_oddframe = 0; 
00000a  f04f0a00          MOV      r10,#0
;;;1428     uint16_t len_words = 0;   
00000e  46d1              MOV      r9,r10
;;;1429     uint16_t num_packets = 0;
000010  2700              MOVS     r7,#0
;;;1430     uint16_t max_hc_pkt_count = 256;
000012  f44f7880          MOV      r8,#0x100
;;;1431     
;;;1432     if((USBx != USB_OTG_FS) && (hc->speed == USB_OTG_SPEED_HIGH))
000016  f1b54fa0          CMP      r5,#0x50000000
00001a  d01c              BEQ      |L30.86|
00001c  7920              LDRB     r0,[r4,#4]
00001e  b9d0              CBNZ     r0,|L30.86|
;;;1433     {
;;;1434       if((dma == 0) && (hc->do_ping == 1))
000020  b94e              CBNZ     r6,|L30.54|
000022  7960              LDRB     r0,[r4,#5]
000024  2801              CMP      r0,#1
000026  d106              BNE      |L30.54|
;;;1435       {
;;;1436         USB_DoPing(USBx, hc->ch_num);
000028  7861              LDRB     r1,[r4,#1]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USB_DoPing
;;;1437         return HAL_OK;
000030  2000              MOVS     r0,#0
                  |L30.50|
;;;1438       }
;;;1439       else if(dma == 1)
;;;1440       {
;;;1441          USBx_HC(hc->ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
;;;1442          hc->do_ping = 0;
;;;1443       }
;;;1444     }
;;;1445     
;;;1446     /* Compute the expected number of packets associated to the transfer */
;;;1447     if (hc->xfer_len > 0)
;;;1448     {
;;;1449       num_packets = (hc->xfer_len + hc->max_packet - 1) / hc->max_packet;
;;;1450       
;;;1451       if (num_packets > max_hc_pkt_count)
;;;1452       {
;;;1453         num_packets = max_hc_pkt_count;
;;;1454         hc->xfer_len = num_packets * hc->max_packet;
;;;1455       }
;;;1456     }
;;;1457     else
;;;1458     {
;;;1459       num_packets = 1;
;;;1460     }
;;;1461     if (hc->ep_is_in)
;;;1462     {
;;;1463       hc->xfer_len = num_packets * hc->max_packet;
;;;1464     }
;;;1465     
;;;1466     
;;;1467     
;;;1468     /* Initialize the HCTSIZn register */
;;;1469     USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
;;;1470                                   ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
;;;1471                                   (((hc->data_pid) << 29) & USB_OTG_HCTSIZ_DPID);
;;;1472     
;;;1473     if (dma)
;;;1474     {
;;;1475       /* xfer_buff MUST be 32-bits aligned */
;;;1476       USBx_HC(hc->ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
;;;1477     }
;;;1478   
;;;1479     is_oddframe = (USBx_HOST->HFNUM & 0x01) ? 0 : 1;
;;;1480     USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
;;;1481     USBx_HC(hc->ch_num)->HCCHAR |= (is_oddframe << 29);
;;;1482     
;;;1483     /* Set host channel enable */
;;;1484     USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHDIS;
;;;1485     USBx_HC(hc->ch_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
;;;1486   
;;;1487     if (dma == 0) /* Slave mode */
;;;1488     {  
;;;1489       if((hc->ep_is_in == 0) && (hc->xfer_len > 0))
;;;1490       {
;;;1491         switch(hc->ep_type) 
;;;1492         {
;;;1493           /* Non periodic transfer */
;;;1494         case EP_TYPE_CTRL:
;;;1495         case EP_TYPE_BULK:
;;;1496           
;;;1497           len_words = (hc->xfer_len + 3) / 4;
;;;1498           
;;;1499           /* check if there is enough space in FIFO space */
;;;1500           if(len_words > (USBx->HNPTXSTS & 0xFFFF))
;;;1501           {
;;;1502             /* need to process data in nptxfempty interrupt */
;;;1503             USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
;;;1504           }
;;;1505           break;
;;;1506           /* Periodic transfer */
;;;1507         case EP_TYPE_INTR:
;;;1508         case EP_TYPE_ISOC:
;;;1509           len_words = (hc->xfer_len + 3) / 4;
;;;1510           /* check if there is enough space in FIFO space */
;;;1511           if(len_words > (USBx_HOST->HPTXSTS & 0xFFFF)) /* split the transfer */
;;;1512           {
;;;1513             /* need to process data in ptxfempty interrupt */
;;;1514             USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;          
;;;1515           }
;;;1516           break;
;;;1517           
;;;1518         default:
;;;1519           break;
;;;1520         }
;;;1521         
;;;1522         /* Write packet into the Tx FIFO. */
;;;1523         USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, hc->xfer_len, 0);
;;;1524       }
;;;1525     }
;;;1526     
;;;1527     return HAL_OK;
;;;1528   }
000032  e8bd87f8          POP      {r3-r10,pc}
                  |L30.54|
000036  2e01              CMP      r6,#1                 ;1439
000038  d10d              BNE      |L30.86|
00003a  7860              LDRB     r0,[r4,#1]            ;1441
00003c  f50561a0          ADD      r1,r5,#0x500          ;1441
000040  eb011040          ADD      r0,r1,r0,LSL #5       ;1441
000044  68c0              LDR      r0,[r0,#0xc]          ;1441
000046  f0200260          BIC      r2,r0,#0x60           ;1441
00004a  7860              LDRB     r0,[r4,#1]            ;1441
00004c  eb011040          ADD      r0,r1,r0,LSL #5       ;1441
000050  60c2              STR      r2,[r0,#0xc]          ;1441
000052  2000              MOVS     r0,#0                 ;1442
000054  7160              STRB     r0,[r4,#5]            ;1442
                  |L30.86|
000056  6920              LDR      r0,[r4,#0x10]         ;1447
000058  b168              CBZ      r0,|L30.118|
00005a  8921              LDRH     r1,[r4,#8]            ;1449
00005c  6920              LDR      r0,[r4,#0x10]         ;1449
00005e  4408              ADD      r0,r0,r1              ;1449
000060  1e40              SUBS     r0,r0,#1              ;1449
000062  fbb0f0f1          UDIV     r0,r0,r1              ;1449
000066  b287              UXTH     r7,r0                 ;1449
000068  4547              CMP      r7,r8                 ;1451
00006a  dd05              BLE      |L30.120|
00006c  4647              MOV      r7,r8                 ;1453
00006e  8920              LDRH     r0,[r4,#8]            ;1454
000070  4378              MULS     r0,r7,r0              ;1454
000072  6120              STR      r0,[r4,#0x10]         ;1454
000074  e000              B        |L30.120|
                  |L30.118|
000076  2701              MOVS     r7,#1                 ;1459
                  |L30.120|
000078  78e0              LDRB     r0,[r4,#3]            ;1461
00007a  b110              CBZ      r0,|L30.130|
00007c  8920              LDRH     r0,[r4,#8]            ;1463
00007e  4378              MULS     r0,r7,r0              ;1463
000080  6120              STR      r0,[r4,#0x10]         ;1463
                  |L30.130|
000082  6920              LDR      r0,[r4,#0x10]         ;1469
000084  f3c00012          UBFX     r0,r0,#0,#19          ;1469
000088  4940              LDR      r1,|L30.396|
00008a  ea0141c7          AND      r1,r1,r7,LSL #19      ;1469
00008e  4308              ORRS     r0,r0,r1              ;1469
000090  7aa1              LDRB     r1,[r4,#0xa]          ;1469
000092  f04f42c0          MOV      r2,#0x60000000        ;1469
000096  ea027141          AND      r1,r2,r1,LSL #29      ;1469
00009a  4308              ORRS     r0,r0,r1              ;1469
00009c  7861              LDRB     r1,[r4,#1]            ;1469
00009e  f50562a0          ADD      r2,r5,#0x500          ;1469
0000a2  eb021141          ADD      r1,r2,r1,LSL #5       ;1469
0000a6  6108              STR      r0,[r1,#0x10]         ;1469
0000a8  b136              CBZ      r6,|L30.184|
0000aa  7860              LDRB     r0,[r4,#1]            ;1476
0000ac  f50561a0          ADD      r1,r5,#0x500          ;1476
0000b0  eb011040          ADD      r0,r1,r0,LSL #5       ;1476
0000b4  68e2              LDR      r2,[r4,#0xc]          ;1476
0000b6  6142              STR      r2,[r0,#0x14]         ;1476
                  |L30.184|
0000b8  f44f6081          MOV      r0,#0x408             ;1479
0000bc  5940              LDR      r0,[r0,r5]            ;1479
0000be  f0000001          AND      r0,r0,#1              ;1479
0000c2  f0800a01          EOR      r10,r0,#1             ;1479
0000c6  7860              LDRB     r0,[r4,#1]            ;1480
0000c8  f50561a0          ADD      r1,r5,#0x500          ;1480
0000cc  eb011040          ADD      r0,r1,r0,LSL #5       ;1480
0000d0  6800              LDR      r0,[r0,#0]            ;1480
0000d2  f0205200          BIC      r2,r0,#0x20000000     ;1480
0000d6  7860              LDRB     r0,[r4,#1]            ;1480
0000d8  eb011040          ADD      r0,r1,r0,LSL #5       ;1480
0000dc  6002              STR      r2,[r0,#0]            ;1480
0000de  7860              LDRB     r0,[r4,#1]            ;1481
0000e0  eb011040          ADD      r0,r1,r0,LSL #5       ;1481
0000e4  6800              LDR      r0,[r0,#0]            ;1481
0000e6  ea40724a          ORR      r2,r0,r10,LSL #29     ;1481
0000ea  7860              LDRB     r0,[r4,#1]            ;1481
0000ec  eb011040          ADD      r0,r1,r0,LSL #5       ;1481
0000f0  6002              STR      r2,[r0,#0]            ;1481
0000f2  7860              LDRB     r0,[r4,#1]            ;1484
0000f4  eb011040          ADD      r0,r1,r0,LSL #5       ;1484
0000f8  6800              LDR      r0,[r0,#0]            ;1484
0000fa  f0204280          BIC      r2,r0,#0x40000000     ;1484
0000fe  7860              LDRB     r0,[r4,#1]            ;1484
000100  eb011040          ADD      r0,r1,r0,LSL #5       ;1484
000104  6002              STR      r2,[r0,#0]            ;1484
000106  7860              LDRB     r0,[r4,#1]            ;1485
000108  eb011040          ADD      r0,r1,r0,LSL #5       ;1485
00010c  6800              LDR      r0,[r0,#0]            ;1485
00010e  f0404200          ORR      r2,r0,#0x80000000     ;1485
000112  7860              LDRB     r0,[r4,#1]            ;1485
000114  eb011040          ADD      r0,r1,r0,LSL #5       ;1485
000118  6002              STR      r2,[r0,#0]            ;1485
00011a  bbae              CBNZ     r6,|L30.392|
00011c  78e0              LDRB     r0,[r4,#3]            ;1489
00011e  bb98              CBNZ     r0,|L30.392|
000120  6920              LDR      r0,[r4,#0x10]         ;1489
000122  b388              CBZ      r0,|L30.392|
000124  79e0              LDRB     r0,[r4,#7]            ;1491
000126  b130              CBZ      r0,|L30.310|
000128  2801              CMP      r0,#1                 ;1491
00012a  d013              BEQ      |L30.340|
00012c  2802              CMP      r0,#2                 ;1491
00012e  d003              BEQ      |L30.312|
000130  2803              CMP      r0,#3                 ;1491
000132  d11e              BNE      |L30.370|
000134  e00d              B        |L30.338|
                  |L30.310|
000136  bf00              NOP                            ;1495
                  |L30.312|
000138  6920              LDR      r0,[r4,#0x10]         ;1497
00013a  1cc0              ADDS     r0,r0,#3              ;1497
00013c  f3c0098f          UBFX     r9,r0,#2,#16          ;1497
000140  6ae8              LDR      r0,[r5,#0x2c]         ;1500
000142  b280              UXTH     r0,r0                 ;1500
000144  4548              CMP      r0,r9                 ;1500
000146  d203              BCS      |L30.336|
000148  69a8              LDR      r0,[r5,#0x18]         ;1503
00014a  f0400020          ORR      r0,r0,#0x20           ;1503
00014e  61a8              STR      r0,[r5,#0x18]         ;1503
                  |L30.336|
000150  e010              B        |L30.372|
                  |L30.338|
000152  bf00              NOP                            ;1508
                  |L30.340|
000154  6920              LDR      r0,[r4,#0x10]         ;1509
000156  1cc0              ADDS     r0,r0,#3              ;1509
000158  f3c0098f          UBFX     r9,r0,#2,#16          ;1509
00015c  f44f6082          MOV      r0,#0x410             ;1511
000160  5940              LDR      r0,[r0,r5]            ;1511
000162  b280              UXTH     r0,r0                 ;1511
000164  4548              CMP      r0,r9                 ;1511
000166  d203              BCS      |L30.368|
000168  69a8              LDR      r0,[r5,#0x18]         ;1514
00016a  f0406080          ORR      r0,r0,#0x4000000      ;1514
00016e  61a8              STR      r0,[r5,#0x18]         ;1514
                  |L30.368|
000170  e000              B        |L30.372|
                  |L30.370|
000172  bf00              NOP                            ;1519
                  |L30.372|
000174  bf00              NOP                            ;1505
000176  2000              MOVS     r0,#0                 ;1523
000178  9000              STR      r0,[sp,#0]            ;1523
00017a  8a20              LDRH     r0,[r4,#0x10]         ;1523
00017c  b283              UXTH     r3,r0                 ;1523
00017e  7862              LDRB     r2,[r4,#1]            ;1523
000180  4628              MOV      r0,r5                 ;1523
000182  68e1              LDR      r1,[r4,#0xc]          ;1523
000184  f7fffffe          BL       USB_WritePacket
                  |L30.392|
000188  2000              MOVS     r0,#0                 ;1527
00018a  e752              B        |L30.50|
;;;1529   
                          ENDP

                  |L30.396|
                          DCD      0x1ff80000

                          AREA ||i.USB_HostInit||, CODE, READONLY, ALIGN=2

                  USB_HostInit PROC
;;;1114     */
;;;1115   HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1116   {
000004  4617              MOV      r7,r2
000006  4604              MOV      r4,r0
;;;1117     uint32_t i;
;;;1118     
;;;1119     /* Restart the Phy Clock */
;;;1120     USBx_PCGCCTL = 0;
000008  2500              MOVS     r5,#0
00000a  f8dd9020          LDR      r9,[sp,#0x20]
00000e  f8c05e00          STR      r5,[r0,#0xe00]
;;;1121     
;;;1122     /* no VBUS sensing*/
;;;1123     USBx->GCCFG &=~ (USB_OTG_GCCFG_VBUSASEN);
000012  6b80              LDR      r0,[r0,#0x38]
000014  f4202080          BIC      r0,r0,#0x40000
000018  63a0              STR      r0,[r4,#0x38]
;;;1124     USBx->GCCFG &=~ (USB_OTG_GCCFG_VBUSBSEN);
00001a  6ba0              LDR      r0,[r4,#0x38]
00001c  f4202000          BIC      r0,r0,#0x80000
000020  63a0              STR      r0,[r4,#0x38]
;;;1125     USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
000022  6ba0              LDR      r0,[r4,#0x38]
000024  f4401000          ORR      r0,r0,#0x200000
000028  63a0              STR      r0,[r4,#0x38]
;;;1126     
;;;1127     /* Disable the FS/LS support mode only */
;;;1128     if((cfg.speed == USB_OTG_SPEED_FULL)&&
;;;1129        (USBx != USB_OTG_FS))
00002a  f04f48a0          MOV      r8,#0x50000000
00002e  2b03              CMP      r3,#3                 ;1128
000030  d106              BNE      |L31.64|
000032  4544              CMP      r4,r8
000034  d004              BEQ      |L31.64|
;;;1130     {
;;;1131       USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
000036  f8d40400          LDR      r0,[r4,#0x400]
00003a  f0400004          ORR      r0,r0,#4
00003e  e003              B        |L31.72|
                  |L31.64|
;;;1132     }
;;;1133     else
;;;1134     {
;;;1135       USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);  
000040  f8d40400          LDR      r0,[r4,#0x400]
000044  f0200004          BIC      r0,r0,#4
                  |L31.72|
000048  f8c40400          STR      r0,[r4,#0x400]
;;;1136     }
;;;1137   
;;;1138     /* Make sure the FIFOs are flushed. */
;;;1139     USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
00004c  2110              MOVS     r1,#0x10
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       USB_FlushTxFifo
;;;1140     USB_FlushRxFifo(USBx);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       USB_FlushRxFifo
;;;1141   
;;;1142     /* Clear all pending HC Interrupts */
;;;1143     for (i = 0; i < cfg.Host_channels; i++)
00005a  2000              MOVS     r0,#0
;;;1144     {
;;;1145       USBx_HC(i)->HCINT = 0xFFFFFFFF;
00005c  1e46              SUBS     r6,r0,#1
00005e  e006              B        |L31.110|
                  |L31.96|
000060  eb041140          ADD      r1,r4,r0,LSL #5
000064  f8c16508          STR      r6,[r1,#0x508]
;;;1146       USBx_HC(i)->HCINTMSK = 0;
000068  f8c1550c          STR      r5,[r1,#0x50c]
00006c  1c40              ADDS     r0,r0,#1
                  |L31.110|
00006e  4287              CMP      r7,r0                 ;1143
000070  d8f6              BHI      |L31.96|
;;;1147     }
;;;1148     
;;;1149     /* Enable VBUS driving */
;;;1150     USB_DriveVbus(USBx, 1);
000072  2101              MOVS     r1,#1
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USB_DriveVbus
;;;1151     
;;;1152     HAL_Delay(200);
00007a  20c8              MOVS     r0,#0xc8
00007c  f7fffffe          BL       HAL_Delay
;;;1153     
;;;1154     /* Disable all interrupts. */
;;;1155     USBx->GINTMSK = 0;
000080  61a5              STR      r5,[r4,#0x18]
;;;1156     
;;;1157     /* Clear any pending interrupts */
;;;1158     USBx->GINTSTS = 0xFFFFFFFF;
000082  6166              STR      r6,[r4,#0x14]
;;;1159   
;;;1160     
;;;1161     if(USBx == USB_OTG_FS)
000084  4544              CMP      r4,r8
000086  d105              BNE      |L31.148|
;;;1162     {
;;;1163       /* set Rx FIFO size */
;;;1164       USBx->GRXFSIZ  = (uint32_t )0x80; 
000088  2080              MOVS     r0,#0x80
00008a  6260              STR      r0,[r4,#0x24]
;;;1165       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
00008c  480c              LDR      r0,|L31.192|
00008e  62a0              STR      r0,[r4,#0x28]
;;;1166       USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
000090  480c              LDR      r0,|L31.196|
000092  e005              B        |L31.160|
                  |L31.148|
;;;1167   
;;;1168     }
;;;1169   
;;;1170     else
;;;1171     {
;;;1172       /* set Rx FIFO size */
;;;1173       USBx->GRXFSIZ  = (uint32_t )0x200; 
000094  f44f7000          MOV      r0,#0x200
000098  6260              STR      r0,[r4,#0x24]
;;;1174       USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x100 << 16)& USB_OTG_NPTXFD) | 0x200);
00009a  480b              LDR      r0,|L31.200|
00009c  62a0              STR      r0,[r4,#0x28]
;;;1175       USBx->HPTXFSIZ = (uint32_t )(((0xE0 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0x300);
00009e  480b              LDR      r0,|L31.204|
                  |L31.160|
0000a0  f8c40100          STR      r0,[r4,#0x100]
;;;1176     }
;;;1177     
;;;1178     /* Enable the common interrupts */
;;;1179     if (cfg.dma_enable == DISABLE)
0000a4  f1b90f00          CMP      r9,#0
0000a8  d103              BNE      |L31.178|
;;;1180     {
;;;1181       USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
0000aa  69a0              LDR      r0,[r4,#0x18]
0000ac  f0400010          ORR      r0,r0,#0x10
0000b0  61a0              STR      r0,[r4,#0x18]
                  |L31.178|
;;;1182     }
;;;1183     
;;;1184     /* Enable interrupts matching to the Host mode ONLY */
;;;1185     USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM |\
0000b2  69a0              LDR      r0,[r4,#0x18]
0000b4  4906              LDR      r1,|L31.208|
0000b6  4308              ORRS     r0,r0,r1
0000b8  61a0              STR      r0,[r4,#0x18]
;;;1186                       USB_OTG_GINTMSK_SOFM             |USB_OTG_GINTSTS_DISCINT|\
;;;1187                       USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
;;;1188   
;;;1189     return HAL_OK;
0000ba  2000              MOVS     r0,#0
;;;1190   }
0000bc  e8bd87f0          POP      {r4-r10,pc}
;;;1191   
                          ENDP

                  |L31.192|
                          DCD      0x00600080
                  |L31.196|
                          DCD      0x004000e0
                  |L31.200|
                          DCD      0x01000200
                  |L31.204|
                          DCD      0x00e00300
                  |L31.208|
                          DCD      0xa3200008

                          AREA ||i.USB_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_InitFSLSPClkSel PROC
;;;1201     */
;;;1202   HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
000000  f8d02400          LDR      r2,[r0,#0x400]
;;;1203   {
;;;1204   	//#warning !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;;;1205     USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
000004  f0220203          BIC      r2,r2,#3
000008  f8c02400          STR      r2,[r0,#0x400]
;;;1206     USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
00000c  f8d02400          LDR      r2,[r0,#0x400]
000010  f0010303          AND      r3,r1,#3
000014  431a              ORRS     r2,r2,r3
000016  f8c02400          STR      r2,[r0,#0x400]
;;;1207     
;;;1208     if (freq ==  HCFG_48_MHZ)
00001a  2901              CMP      r1,#1
00001c  d002              BEQ      |L32.36|
;;;1209     {
;;;1210       USBx_HOST->HFIR = (uint32_t)48000;
;;;1211     }
;;;1212     else if (freq ==  HCFG_6_MHZ)
00001e  2902              CMP      r1,#2
000020  d003              BEQ      |L32.42|
000022  e006              B        |L32.50|
                  |L32.36|
000024  f64b3180          MOV      r1,#0xbb80            ;1210
000028  e001              B        |L32.46|
                  |L32.42|
;;;1213     {
;;;1214       USBx_HOST->HFIR = (uint32_t)6000;
00002a  f2417170          MOV      r1,#0x1770
                  |L32.46|
00002e  f8c01404          STR      r1,[r0,#0x404]
                  |L32.50|
;;;1215     } 
;;;1216     return HAL_OK;  
000032  2000              MOVS     r0,#0
;;;1217   }
000034  4770              BX       lr
;;;1218   
                          ENDP


                          AREA ||i.USB_ReadDevAllInEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllInEpInterrupt PROC
;;;956      */
;;;957    uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
000000  f8d01818          LDR      r1,[r0,#0x818]
;;;958    {
;;;959      uint32_t v;
;;;960      v  = USBx_DEVICE->DAINT;
;;;961      v &= USBx_DEVICE->DAINTMSK;
000004  f8d0081c          LDR      r0,[r0,#0x81c]
000008  4008              ANDS     r0,r0,r1
;;;962      return ((v & 0xFFFF));
00000a  b280              UXTH     r0,r0
;;;963    }
00000c  4770              BX       lr
;;;964    
                          ENDP


                          AREA ||i.USB_ReadDevAllOutEpInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevAllOutEpInterrupt PROC
;;;943      */
;;;944    uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
000000  f8d01818          LDR      r1,[r0,#0x818]
;;;945    {
;;;946      uint32_t v;
;;;947      v  = USBx_DEVICE->DAINT;
;;;948      v &= USBx_DEVICE->DAINTMSK;
000004  f8d0081c          LDR      r0,[r0,#0x81c]
000008  4008              ANDS     r0,r0,r1
;;;949      return ((v & 0xffff0000) >> 16);
00000a  0c00              LSRS     r0,r0,#16
;;;950    }
00000c  4770              BX       lr
;;;951    
                          ENDP


                          AREA ||i.USB_ReadDevInEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevInEPInterrupt PROC
;;;986      */
;;;987    uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
000000  f8d03810          LDR      r3,[r0,#0x810]
;;;988    {
;;;989      uint32_t v, msk, emp;
;;;990      
;;;991      msk = USBx_DEVICE->DIEPMSK;
;;;992      emp = USBx_DEVICE->DIEPEMPMSK;
000004  f8d02834          LDR      r2,[r0,#0x834]
;;;993      msk |= ((emp >> epnum) & 0x1) << 7;
000008  40ca              LSRS     r2,r2,r1
00000a  f0020201          AND      r2,r2,#1
00000e  ea4312c2          ORR      r2,r3,r2,LSL #7
;;;994      v = USBx_INEP(epnum)->DIEPINT & msk;
000012  eb001041          ADD      r0,r0,r1,LSL #5
000016  f8d00908          LDR      r0,[r0,#0x908]
00001a  4010              ANDS     r0,r0,r2
;;;995      return v;
;;;996    }
00001c  4770              BX       lr
;;;997    
                          ENDP


                          AREA ||i.USB_ReadDevOutEPInterrupt||, CODE, READONLY, ALIGN=1

                  USB_ReadDevOutEPInterrupt PROC
;;;971      */
;;;972    uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
000000  eb001141          ADD      r1,r0,r1,LSL #5
;;;973    {
;;;974      uint32_t v;
;;;975      v  = USBx_OUTEP(epnum)->DOEPINT;
000004  f8d11b08          LDR      r1,[r1,#0xb08]
;;;976      v &= USBx_DEVICE->DOEPMSK;
000008  f8d00814          LDR      r0,[r0,#0x814]
00000c  4008              ANDS     r0,r0,r1
;;;977      return v;
;;;978    }
00000e  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.USB_ReadInterrupts||, CODE, READONLY, ALIGN=1

                  USB_ReadInterrupts PROC
;;;929      */
;;;930    uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
000000  6941              LDR      r1,[r0,#0x14]
;;;931    {
;;;932      uint32_t v = 0;
;;;933      
;;;934      v = USBx->GINTSTS;
;;;935      v &= USBx->GINTMSK;
000002  6980              LDR      r0,[r0,#0x18]
000004  4008              ANDS     r0,r0,r1
;;;936      return v;  
;;;937    }
000006  4770              BX       lr
;;;938    
                          ENDP


                          AREA ||i.USB_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_ReadPacket PROC
;;;786      */
;;;787    void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;788    {
000002  4603              MOV      r3,r0
;;;789      uint32_t i=0;
000004  2000              MOVS     r0,#0
000006  1cd2              ADDS     r2,r2,#3
;;;790      uint32_t count32b = (len + 3) / 4;
000008  0892              LSRS     r2,r2,#2
00000a  f5035380          ADD      r3,r3,#0x1000
00000e  e003              B        |L38.24|
                  |L38.16|
;;;791      
;;;792      for ( i = 0; i < count32b; i++, dest += 4 )
;;;793      {
;;;794        *(__packed uint32_t *)dest = USBx_DFIFO(0);
000010  681c              LDR      r4,[r3,#0]
000012  f8414b04          STR      r4,[r1],#4
000016  1c40              ADDS     r0,r0,#1
                  |L38.24|
000018  4290              CMP      r0,r2                 ;792
00001a  d3f9              BCC      |L38.16|
;;;795        
;;;796      }
;;;797      return ((void *)dest);
00001c  4608              MOV      r0,r1
;;;798    }
00001e  bd10              POP      {r4,pc}
;;;799    
                          ENDP


                          AREA ||i.USB_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_ResetPort PROC
;;;1225     */
;;;1226   HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
000000  b538              PUSH     {r3-r5,lr}
;;;1227   {
000002  4604              MOV      r4,r0
;;;1228     __IO uint32_t hprt0;
;;;1229     
;;;1230     hprt0 = USBx_HPRT0;
000004  f8d00440          LDR      r0,[r0,#0x440]
;;;1231     
;;;1232     hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
000008  f020002e          BIC      r0,r0,#0x2e
;;;1233       USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
;;;1234     
;;;1235     USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
00000c  9000              STR      r0,[sp,#0]
00000e  f4407080          ORR      r0,r0,#0x100
000012  f8c40440          STR      r0,[r4,#0x440]
;;;1236     HAL_Delay (10);                                /* See Note #1 */
000016  200a              MOVS     r0,#0xa
000018  f5046488          ADD      r4,r4,#0x440
00001c  f7fffffe          BL       HAL_Delay
;;;1237     USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
000020  9800              LDR      r0,[sp,#0]
000022  f4207080          BIC      r0,r0,#0x100
000026  6020              STR      r0,[r4,#0]
;;;1238     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1239   }
00002a  bd38              POP      {r3-r5,pc}
;;;1240   
                          ENDP


                          AREA ||i.USB_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_SetCurrentMode PROC
;;;174      */
;;;175    HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177      USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
000002  68c2              LDR      r2,[r0,#0xc]
000004  f02242c0          BIC      r2,r2,#0x60000000
000008  60c2              STR      r2,[r0,#0xc]
;;;178      
;;;179      if ( mode == USB_OTG_HOST_MODE)
00000a  2901              CMP      r1,#1
00000c  d001              BEQ      |L40.18|
;;;180      {
;;;181        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
;;;182      }
;;;183      else if ( mode == USB_OTG_DEVICE_MODE)
00000e  b121              CBZ      r1,|L40.26|
000010  e007              B        |L40.34|
                  |L40.18|
000012  68c1              LDR      r1,[r0,#0xc]          ;181
000014  f0415100          ORR      r1,r1,#0x20000000     ;181
000018  e002              B        |L40.32|
                  |L40.26|
;;;184      {
;;;185        USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  f0414180          ORR      r1,r1,#0x40000000
                  |L40.32|
000020  60c1              STR      r1,[r0,#0xc]
                  |L40.34|
;;;186      }
;;;187      HAL_Delay(50);
000022  2032              MOVS     r0,#0x32
000024  f7fffffe          BL       HAL_Delay
;;;188      
;;;189      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;190    }
00002a  bd10              POP      {r4,pc}
;;;191    
                          ENDP


                          AREA ||i.USB_SetDevAddress||, CODE, READONLY, ALIGN=1

                  USB_SetDevAddress PROC
;;;890      */
;;;891    HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
000000  f8d02800          LDR      r2,[r0,#0x800]
;;;892    {
;;;893      USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
000004  f42262fe          BIC      r2,r2,#0x7f0
000008  f8c02800          STR      r2,[r0,#0x800]
;;;894      USBx_DEVICE->DCFG |= (address << 4) & USB_OTG_DCFG_DAD ;
00000c  f8d02800          LDR      r2,[r0,#0x800]
000010  f44f63fe          MOV      r3,#0x7f0
000014  ea031101          AND      r1,r3,r1,LSL #4
000018  430a              ORRS     r2,r2,r1
00001a  f8c02800          STR      r2,[r0,#0x800]
;;;895      
;;;896      return HAL_OK;  
00001e  2000              MOVS     r0,#0
;;;897    }
000020  4770              BX       lr
;;;898    
                          ENDP


                          AREA ||i.USB_SetDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_SetDevSpeed PROC
;;;382      */
;;;383    HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
000000  f8d02800          LDR      r2,[r0,#0x800]
;;;384    {
;;;385      USBx_DEVICE->DCFG |= speed;
000004  430a              ORRS     r2,r2,r1
000006  f8c02800          STR      r2,[r0,#0x800]
;;;386      return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;387    }
00000c  4770              BX       lr
;;;388    
                          ENDP


                          AREA ||i.USB_StopDevice||, CODE, READONLY, ALIGN=1

                  USB_StopDevice PROC
;;;859      */
;;;860    HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
000000  b510              PUSH     {r4,lr}
;;;861    {
000002  4604              MOV      r4,r0
;;;862      uint32_t i;
;;;863      
;;;864      /* Clear Pending interrupt */
;;;865      for (i = 0; i < 15 ; i++)
000004  2000              MOVS     r0,#0
;;;866      {
;;;867        USBx_INEP(i)->DIEPINT  = 0xFF;
000006  21ff              MOVS     r1,#0xff
                  |L43.8|
000008  eb041240          ADD      r2,r4,r0,LSL #5
00000c  f8c21908          STR      r1,[r2,#0x908]
;;;868        USBx_OUTEP(i)->DOEPINT  = 0xFF;
000010  f8c21b08          STR      r1,[r2,#0xb08]
000014  1c40              ADDS     r0,r0,#1
000016  280f              CMP      r0,#0xf               ;865
000018  d3f6              BCC      |L43.8|
;;;869      }
;;;870      USBx_DEVICE->DAINT = 0xFFFFFFFF;
00001a  f04f30ff          MOV      r0,#0xffffffff
00001e  f8c40818          STR      r0,[r4,#0x818]
;;;871      
;;;872      /* Clear interrupt masks */
;;;873      USBx_DEVICE->DIEPMSK  = 0;
000022  2000              MOVS     r0,#0
000024  f8c40810          STR      r0,[r4,#0x810]
;;;874      USBx_DEVICE->DOEPMSK  = 0;
000028  f8c40814          STR      r0,[r4,#0x814]
;;;875      USBx_DEVICE->DAINTMSK = 0;
00002c  f8c4081c          STR      r0,[r4,#0x81c]
;;;876      
;;;877      /* Flush the FIFO */
;;;878      USB_FlushRxFifo(USBx);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USB_FlushRxFifo
;;;879      USB_FlushTxFifo(USBx ,  0x10 );  
000036  2110              MOVS     r1,#0x10
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USB_FlushTxFifo
;;;880      
;;;881      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;882    }
000040  bd10              POP      {r4,pc}
;;;883    
                          ENDP


                          AREA ||i.USB_StopHost||, CODE, READONLY, ALIGN=1

                  USB_StopHost PROC
;;;1627     */
;;;1628   HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1629   {
000002  4605              MOV      r5,r0
;;;1630     uint8_t i;
;;;1631     uint32_t count = 0;
000004  2700              MOVS     r7,#0
000006  68a8              LDR      r0,[r5,#8]
000008  f0200001          BIC      r0,r0,#1
00000c  60a8              STR      r0,[r5,#8]
;;;1632     uint32_t value;
;;;1633     
;;;1634     USB_DisableGlobalInt(USBx);
;;;1635     
;;;1636       /* Flush FIFO */
;;;1637     USB_FlushTxFifo(USBx, 0x10);
00000e  2110              MOVS     r1,#0x10
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USB_FlushTxFifo
;;;1638     USB_FlushRxFifo(USBx);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       USB_FlushRxFifo
;;;1639     
;;;1640     /* Flush out any leftover queued requests. */
;;;1641     for (i = 0; i <= 15; i++)
00001c  2400              MOVS     r4,#0
00001e  e011              B        |L44.68|
                  |L44.32|
;;;1642     {   
;;;1643   
;;;1644       value = USBx_HC(i)->HCCHAR ;
000020  f50560a0          ADD      r0,r5,#0x500
000024  eb001044          ADD      r0,r0,r4,LSL #5
000028  6806              LDR      r6,[r0,#0]
;;;1645       value |=  USB_OTG_HCCHAR_CHDIS;
00002a  f0464680          ORR      r6,r6,#0x40000000
;;;1646       value &= ~USB_OTG_HCCHAR_CHENA;  
00002e  f0264600          BIC      r6,r6,#0x80000000
;;;1647       value &= ~USB_OTG_HCCHAR_EPDIR;
000032  f4264600          BIC      r6,r6,#0x8000
;;;1648       USBx_HC(i)->HCCHAR = value;
000036  f50560a0          ADD      r0,r5,#0x500
00003a  eb001044          ADD      r0,r0,r4,LSL #5
00003e  6006              STR      r6,[r0,#0]
000040  1c60              ADDS     r0,r4,#1              ;1641
000042  b2c4              UXTB     r4,r0                 ;1641
                  |L44.68|
000044  2c0f              CMP      r4,#0xf               ;1641
000046  ddeb              BLE      |L44.32|
;;;1649     }
;;;1650     
;;;1651     /* Halt all channels to put them into a known state. */  
;;;1652     for (i = 0; i <= 15; i++)
000048  2400              MOVS     r4,#0
00004a  e023              B        |L44.148|
                  |L44.76|
;;;1653     {   
;;;1654   
;;;1655       value = USBx_HC(i)->HCCHAR ;
00004c  f50560a0          ADD      r0,r5,#0x500
000050  eb001044          ADD      r0,r0,r4,LSL #5
000054  6806              LDR      r6,[r0,#0]
;;;1656       
;;;1657       value |= USB_OTG_HCCHAR_CHDIS;
000056  f0464680          ORR      r6,r6,#0x40000000
;;;1658       value |= USB_OTG_HCCHAR_CHENA;  
00005a  f0464600          ORR      r6,r6,#0x80000000
;;;1659       value &= ~USB_OTG_HCCHAR_EPDIR;
00005e  f4264600          BIC      r6,r6,#0x8000
;;;1660       
;;;1661       USBx_HC(i)->HCCHAR = value;
000062  f50560a0          ADD      r0,r5,#0x500
000066  eb001044          ADD      r0,r0,r4,LSL #5
00006a  6006              STR      r6,[r0,#0]
;;;1662       do 
00006c  bf00              NOP      
                  |L44.110|
;;;1663       {
;;;1664         if (++count > 1000) 
00006e  1c78              ADDS     r0,r7,#1
000070  4607              MOV      r7,r0
000072  f5b07f7a          CMP      r0,#0x3e8
000076  d900              BLS      |L44.122|
;;;1665         {
;;;1666           break;
000078  e009              B        |L44.142|
                  |L44.122|
;;;1667         }
;;;1668       } 
;;;1669       while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
00007a  f50560a0          ADD      r0,r5,#0x500
00007e  eb001044          ADD      r0,r0,r4,LSL #5
000082  6800              LDR      r0,[r0,#0]
000084  f0004000          AND      r0,r0,#0x80000000
000088  f1b04f00          CMP      r0,#0x80000000
00008c  d0ef              BEQ      |L44.110|
                  |L44.142|
00008e  bf00              NOP                            ;1666
000090  1c60              ADDS     r0,r4,#1              ;1652
000092  b2c4              UXTB     r4,r0                 ;1652
                  |L44.148|
000094  2c0f              CMP      r4,#0xf               ;1652
000096  ddd9              BLE      |L44.76|
;;;1670     }
;;;1671   
;;;1672     /* Clear any pending Host interrups */  
;;;1673     USBx_HOST->HAINT = 0xFFFFFFFF;
000098  f04f31ff          MOV      r1,#0xffffffff
00009c  f2404014          MOV      r0,#0x414
0000a0  5141              STR      r1,[r0,r5]
;;;1674     USBx->GINTSTS = 0xFFFFFFFF;
0000a2  4608              MOV      r0,r1
0000a4  6168              STR      r0,[r5,#0x14]
0000a6  68a8              LDR      r0,[r5,#8]
0000a8  f0400001          ORR      r0,r0,#1
0000ac  60a8              STR      r0,[r5,#8]
;;;1675     USB_EnableGlobalInt(USBx);
;;;1676     return HAL_OK;  
0000ae  2000              MOVS     r0,#0
;;;1677   }
0000b0  bdf0              POP      {r4-r7,pc}
;;;1678   /**
                          ENDP


                          AREA ||i.USB_WritePacket||, CODE, READONLY, ALIGN=2

                  USB_WritePacket PROC
;;;758      */
;;;759    HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
000000  b530              PUSH     {r4,r5,lr}
;;;760    	{
;;;761    	uint32_t count32b = 0 , i= 0;
000002  2400              MOVS     r4,#0
000004  9d03              LDR      r5,[sp,#0xc]          ;760
000006  b96d              CBNZ     r5,|L45.36|
000008  1cdb              ADDS     r3,r3,#3              ;760
;;;762    
;;;763    	if( dma == 0 )
;;;764    		{
;;;765    		count32b =  (len + 3) / 4;
00000a  089b              LSRS     r3,r3,#2
;;;766    		for( i = 0; i < count32b; i++, src += 4 )
;;;767    			{
;;;768    			USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
00000c  eb003002          ADD      r0,r0,r2,LSL #12
000010  f5005080          ADD      r0,r0,#0x1000
000014  e004              B        |L45.32|
000016  bf00              NOP      
                  |L45.24|
000018  f8512b04          LDR      r2,[r1],#4
00001c  6002              STR      r2,[r0,#0]
00001e  1c64              ADDS     r4,r4,#1
                  |L45.32|
000020  429c              CMP      r4,r3                 ;766
000022  d3f9              BCC      |L45.24|
                  |L45.36|
;;;769    			}
;;;770    		}
;;;771    	return HAL_OK;
000024  2000              MOVS     r0,#0
;;;772    	}
000026  bd30              POP      {r4,r5,pc}
;;;773    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  debug
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_ll_usb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f2xx_ll_usb_c_832330cf____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_stm32f2xx_ll_usb_c_832330cf____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f2xx_ll_usb_c_832330cf____REVSH|
#line 144
|__asm___18_stm32f2xx_ll_usb_c_832330cf____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
