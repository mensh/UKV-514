; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_pcd.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_pcd.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_pcd.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_pcd.c]
                          THUMB

                          AREA ||i.HAL_PCD_ActiveRemoteWakeup||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ActiveRemoteWakeup PROC
;;;1089     */
;;;1090   HAL_StatusTypeDef HAL_PCD_ActiveRemoteWakeup(PCD_HandleTypeDef *hpcd)
000000  6800              LDR      r0,[r0,#0]
;;;1091   {
;;;1092     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
;;;1093       
;;;1094     if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
000002  f8d01808          LDR      r1,[r0,#0x808]
000006  07c9              LSLS     r1,r1,#31
000008  d005              BEQ      |L1.22|
;;;1095     {
;;;1096       /* active Remote wakeup signaling */
;;;1097       USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
00000a  f8d01804          LDR      r1,[r0,#0x804]
00000e  f0410101          ORR      r1,r1,#1
000012  f8c01804          STR      r1,[r0,#0x804]
                  |L1.22|
;;;1098     }
;;;1099     return HAL_OK;  
000016  2000              MOVS     r0,#0
;;;1100   }
000018  4770              BX       lr
;;;1101   
                          ENDP


                          AREA ||i.HAL_PCD_ConnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ConnectCallback PROC
;;;691      */
;;;692     __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;693    {
;;;694      /* NOTE : This function Should not be modified, when the callback is needed,
;;;695                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;696       */ 
;;;697    }
;;;698    
                          ENDP


                          AREA ||i.HAL_PCD_DataInStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataInStageCallback PROC
;;;596      */
;;;597     __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;598    {
;;;599      /* NOTE : This function Should not be modified, when the callback is needed,
;;;600                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;601       */ 
;;;602    }
;;;603    /**
                          ENDP


                          AREA ||i.HAL_PCD_DataOutStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DataOutStageCallback PROC
;;;584      */
;;;585     __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;586    {
;;;587      /* NOTE : This function Should not be modified, when the callback is needed,
;;;588                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;589       */ 
;;;590    }
;;;591    
                          ENDP


                          AREA ||i.HAL_PCD_DeActiveRemoteWakeup||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DeActiveRemoteWakeup PROC
;;;1106     */
;;;1107   HAL_StatusTypeDef HAL_PCD_DeActiveRemoteWakeup(PCD_HandleTypeDef *hpcd)
000000  6800              LDR      r0,[r0,#0]
;;;1108   {
;;;1109     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
;;;1110     
;;;1111     /* active Remote wakeup signaling */
;;;1112      USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
000002  f8d01804          LDR      r1,[r0,#0x804]
000006  f0210101          BIC      r1,r1,#1
00000a  f8c01804          STR      r1,[r0,#0x804]
;;;1113     return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;1114   }
000010  4770              BX       lr
;;;1115   /**
                          ENDP


                          AREA ||i.HAL_PCD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DeInit PROC
;;;190      */
;;;191    HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  0004              MOVS     r4,r0
000004  d00c              BEQ      |L6.32|
;;;193      /* Check the PCD handle allocation */
;;;194      if(hpcd == NULL)
;;;195      {
;;;196        return HAL_ERROR;
;;;197      }
;;;198    
;;;199      hpcd->State = PCD_BUSY;
000006  2002              MOVS     r0,#2
000008  f8840379          STRB     r0,[r4,#0x379]
;;;200      
;;;201      /* Stop Device */
;;;202      HAL_PCD_Stop(hpcd);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_PCD_Stop
;;;203        
;;;204      /* DeInit the low level hardware */
;;;205      HAL_PCD_MspDeInit(hpcd);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_PCD_MspDeInit
;;;206      
;;;207      hpcd->State = PCD_READY; 
000018  2000              MOVS     r0,#0
00001a  f8840379          STRB     r0,[r4,#0x379]
;;;208      
;;;209      return HAL_OK;
;;;210    }
00001e  bd10              POP      {r4,pc}
                  |L6.32|
000020  2001              MOVS     r0,#1                 ;196
000022  bd10              POP      {r4,pc}
;;;211    
                          ENDP


                          AREA ||i.HAL_PCD_DevConnect||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DevConnect PROC
;;;736      */
;;;737    HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;738    {
000002  4604              MOV      r4,r0
;;;739      __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L7.32|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;740      USB_DevConnect(hpcd->Instance);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USB_DevConnect
;;;741      __HAL_UNLOCK(hpcd); 
000018  2000              MOVS     r0,#0
00001a  f8840378          STRB     r0,[r4,#0x378]
;;;742      return HAL_OK;
;;;743    }
00001e  bd10              POP      {r4,pc}
                  |L7.32|
000020  2002              MOVS     r0,#2                 ;739
000022  bd10              POP      {r4,pc}
;;;744    
                          ENDP


                          AREA ||i.HAL_PCD_DevDisconnect||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DevDisconnect PROC
;;;751      */
;;;752    HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;753    {
000002  4604              MOV      r4,r0
;;;754      __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L8.32|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;755      USB_DevDisconnect(hpcd->Instance);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USB_DevDisconnect
;;;756      __HAL_UNLOCK(hpcd); 
000018  2000              MOVS     r0,#0
00001a  f8840378          STRB     r0,[r4,#0x378]
;;;757      return HAL_OK;
;;;758    }
00001e  bd10              POP      {r4,pc}
                  |L8.32|
000020  2002              MOVS     r0,#2                 ;754
000022  bd10              POP      {r4,pc}
;;;759    
                          ENDP


                          AREA ||i.HAL_PCD_DisconnectCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_DisconnectCallback PROC
;;;703      */
;;;704     __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;705    {
;;;706      /* NOTE : This function Should not be modified, when the callback is needed,
;;;707                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;708       */ 
;;;709    }
;;;710    
                          ENDP


                          AREA ||i.HAL_PCD_EP_Close||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Close PROC
;;;822      */
;;;823    HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b510              PUSH     {r4,lr}
;;;824    {  
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;825      USB_OTG_EPTypeDef *ep;
;;;826      
;;;827      if ((ep_addr & 0x80) == 0x80)
000006  060b              LSLS     r3,r1,#24
;;;828      {
;;;829        ep = &hpcd->IN_ep[ep_addr & 0x7F];
000008  f001007f          AND      r0,r1,#0x7f
00000c  ebc001c0          RSB      r1,r0,r0,LSL #3
000010  eb040181          ADD      r1,r4,r1,LSL #2
000014  d501              BPL      |L10.26|
000016  3130              ADDS     r1,r1,#0x30           ;824
000018  e001              B        |L10.30|
                  |L10.26|
00001a  f50171ea          ADD      r1,r1,#0x1d4
                  |L10.30|
;;;830      }
;;;831      else
;;;832      {
;;;833        ep = &hpcd->OUT_ep[ep_addr & 0x7F];
;;;834      }
;;;835      ep->num   = ep_addr & 0x7F;
00001e  7008              STRB     r0,[r1,#0]
;;;836      
;;;837      ep->is_in = (0x80 & ep_addr) != 0;
000020  09d0              LSRS     r0,r2,#7
000022  7048              STRB     r0,[r1,#1]
;;;838      
;;;839      __HAL_LOCK(hpcd); 
000024  f8940378          LDRB     r0,[r4,#0x378]
000028  2801              CMP      r0,#1
00002a  d009              BEQ      |L10.64|
00002c  2001              MOVS     r0,#1
00002e  f8840378          STRB     r0,[r4,#0x378]
;;;840      USB_DeactivateEndpoint(hpcd->Instance , ep);
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       USB_DeactivateEndpoint
;;;841      __HAL_UNLOCK(hpcd);   
000038  2000              MOVS     r0,#0
00003a  f8840378          STRB     r0,[r4,#0x378]
;;;842      return HAL_OK;
;;;843    }
00003e  bd10              POP      {r4,pc}
                  |L10.64|
000040  2002              MOVS     r0,#2                 ;839
000042  bd10              POP      {r4,pc}
;;;844    
                          ENDP


                          AREA ||i.HAL_PCD_EP_ClrStall||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_ClrStall PROC
;;;979      */
;;;980    HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;981    {
000002  460a              MOV      r2,r1
000004  4604              MOV      r4,r0
;;;982      USB_OTG_EPTypeDef *ep;
;;;983      
;;;984      if ((0x80 & ep_addr) == 0x80)
000006  0609              LSLS     r1,r1,#24
;;;985      {
;;;986        ep = &hpcd->IN_ep[ep_addr & 0x7F];
000008  f002007f          AND      r0,r2,#0x7f
00000c  d505              BPL      |L11.26|
00000e  ebc001c0          RSB      r1,r0,r0,LSL #3
000012  eb040181          ADD      r1,r4,r1,LSL #2
000016  3130              ADDS     r1,r1,#0x30
000018  e005              B        |L11.38|
                  |L11.26|
;;;987      }
;;;988      else
;;;989      {
;;;990        ep = &hpcd->OUT_ep[ep_addr];
00001a  ebc201c2          RSB      r1,r2,r2,LSL #3
00001e  eb040181          ADD      r1,r4,r1,LSL #2
000022  f50171ea          ADD      r1,r1,#0x1d4
                  |L11.38|
;;;991      }
;;;992      
;;;993      ep->is_stall = 0;
000026  2500              MOVS     r5,#0
000028  708d              STRB     r5,[r1,#2]
;;;994      ep->num   = ep_addr & 0x7F;
00002a  7008              STRB     r0,[r1,#0]
;;;995      ep->is_in = ((ep_addr & 0x80) == 0x80);
00002c  09d0              LSRS     r0,r2,#7
00002e  7048              STRB     r0,[r1,#1]
;;;996      
;;;997      __HAL_LOCK(hpcd); 
000030  f8940378          LDRB     r0,[r4,#0x378]
000034  2801              CMP      r0,#1
000036  d009              BEQ      |L11.76|
000038  2001              MOVS     r0,#1
00003a  f8840378          STRB     r0,[r4,#0x378]
;;;998      USB_EPClearStall(hpcd->Instance , ep);
00003e  6820              LDR      r0,[r4,#0]
000040  f7fffffe          BL       USB_EPClearStall
;;;999      __HAL_UNLOCK(hpcd); 
000044  f8845378          STRB     r5,[r4,#0x378]
;;;1000       
;;;1001     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;1002   }
00004a  bd70              POP      {r4-r6,pc}
                  |L11.76|
00004c  2002              MOVS     r0,#2                 ;997
00004e  bd70              POP      {r4-r6,pc}
;;;1003   
                          ENDP


                          AREA ||i.HAL_PCD_EP_Flush||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Flush PROC
;;;1009     */
;;;1010   HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b510              PUSH     {r4,lr}
;;;1011   {
000002  4604              MOV      r4,r0
;;;1012     __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d00a              BEQ      |L12.34|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;1013     
;;;1014     if ((ep_addr & 0x80) == 0x80)
000012  0608              LSLS     r0,r1,#24
000014  d507              BPL      |L12.38|
;;;1015     {
;;;1016       USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7F);
000016  f001017f          AND      r1,r1,#0x7f
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       USB_FlushTxFifo
000020  e004              B        |L12.44|
                  |L12.34|
000022  2002              MOVS     r0,#2                 ;1012
;;;1017     }
;;;1018     else
;;;1019     {
;;;1020       USB_FlushRxFifo(hpcd->Instance);
;;;1021     }
;;;1022     
;;;1023     __HAL_UNLOCK(hpcd); 
;;;1024       
;;;1025     return HAL_OK;
;;;1026   }
000024  bd10              POP      {r4,pc}
                  |L12.38|
000026  6820              LDR      r0,[r4,#0]            ;1020
000028  f7fffffe          BL       USB_FlushRxFifo
                  |L12.44|
00002c  2000              MOVS     r0,#0                 ;1023
00002e  f8840378          STRB     r0,[r4,#0x378]        ;1023
000032  bd10              POP      {r4,pc}
;;;1027   
                          ENDP


                          AREA ||i.HAL_PCD_EP_GetRxCount||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_GetRxCount PROC
;;;893      */
;;;894    uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  f001017f          AND      r1,r1,#0x7f
;;;895    {
;;;896      return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
000004  ebc101c1          RSB      r1,r1,r1,LSL #3
000008  eb000081          ADD      r0,r0,r1,LSL #2
00000c  f8b001ec          LDRH     r0,[r0,#0x1ec]
000010  b280              UXTH     r0,r0
;;;897    }
000012  4770              BX       lr
;;;898    /**
                          ENDP


                          AREA ||i.HAL_PCD_EP_Open||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Open PROC
;;;780      */
;;;781    HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
000000  b570              PUSH     {r4-r6,lr}
;;;782    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;783      HAL_StatusTypeDef  ret = HAL_OK;
;;;784      USB_OTG_EPTypeDef *ep;
;;;785      
;;;786      if ((ep_addr & 0x80) == 0x80)
000006  060e              LSLS     r6,r1,#24
;;;787      {
;;;788        ep = &hpcd->IN_ep[ep_addr & 0x7F];
000008  f001007f          AND      r0,r1,#0x7f
00000c  ebc001c0          RSB      r1,r0,r0,LSL #3
000010  eb040181          ADD      r1,r4,r1,LSL #2
000014  d501              BPL      |L14.26|
000016  3130              ADDS     r1,r1,#0x30           ;782
000018  e001              B        |L14.30|
                  |L14.26|
00001a  f50171ea          ADD      r1,r1,#0x1d4
                  |L14.30|
;;;789      }
;;;790      else
;;;791      {
;;;792        ep = &hpcd->OUT_ep[ep_addr & 0x7F];
;;;793      }
;;;794      ep->num   = ep_addr & 0x7F;
;;;795      
;;;796      ep->is_in = (0x80 & ep_addr) != 0;
00001e  09ed              LSRS     r5,r5,#7
000020  7008              STRB     r0,[r1,#0]            ;794
000022  704d              STRB     r5,[r1,#1]
;;;797      ep->maxpacket = ep_mps;
;;;798      ep->type = ep_type;
000024  608a              STR      r2,[r1,#8]
000026  70cb              STRB     r3,[r1,#3]
;;;799      if (ep->is_in)
000028  d000              BEQ      |L14.44|
;;;800      {
;;;801        /* Assign a Tx FIFO */
;;;802        ep->tx_fifo_num = ep->num;
00002a  80c8              STRH     r0,[r1,#6]
                  |L14.44|
00002c  2500              MOVS     r5,#0
;;;803      }
;;;804      /* Set initial data PID. */
;;;805      if (ep_type == EP_TYPE_BULK )
00002e  2b02              CMP      r3,#2
000030  d100              BNE      |L14.52|
;;;806      {
;;;807        ep->data_pid_start = 0;
000032  710d              STRB     r5,[r1,#4]
                  |L14.52|
;;;808      }
;;;809      
;;;810      __HAL_LOCK(hpcd); 
000034  f8940378          LDRB     r0,[r4,#0x378]
000038  2801              CMP      r0,#1
00003a  d009              BEQ      |L14.80|
00003c  2001              MOVS     r0,#1
00003e  f8840378          STRB     r0,[r4,#0x378]
;;;811      USB_ActivateEndpoint(hpcd->Instance , ep);
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       USB_ActivateEndpoint
;;;812      __HAL_UNLOCK(hpcd);   
000048  4628              MOV      r0,r5
00004a  f8845378          STRB     r5,[r4,#0x378]
;;;813      return ret;
;;;814    }
00004e  bd70              POP      {r4-r6,pc}
                  |L14.80|
000050  2002              MOVS     r0,#2                 ;810
000052  bd70              POP      {r4-r6,pc}
;;;815    
                          ENDP


                          AREA ||i.HAL_PCD_EP_Receive||, CODE, READONLY, ALIGN=2

                  HAL_PCD_EP_Receive PROC
;;;853      */
;;;854    HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;855    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;856      
;;;857      USB_OTG_EPTypeDef *ep;
;;;858      
;;;859      ep = &hpcd->OUT_ep[ep_addr & 0x7F];
000006  f001007f          AND      r0,r1,#0x7f
00000a  ebc001c0          RSB      r1,r0,r0,LSL #3
00000e  eb040181          ADD      r1,r4,r1,LSL #2
;;;860      
;;;861      /*setup and start the Xfer */
;;;862      ep->xfer_buff = pBuf;  
;;;863      ep->xfer_len = len;
;;;864      ep->xfer_count = 0;
000012  2500              MOVS     r5,#0
000014  f8c121e0          STR      r2,[r1,#0x1e0]
000018  e9c1357a          STRD     r3,r5,[r1,#0x1e8]
;;;865      ep->is_in = 0;
00001c  f88151d5          STRB     r5,[r1,#0x1d5]
;;;866      ep->num = ep_addr & 0x7F;
000020  f88101d4          STRB     r0,[r1,#0x1d4]
;;;867      
;;;868      if (hpcd->Init.dma_enable == 1)
000024  6920              LDR      r0,[r4,#0x10]
000026  f50171ea          ADD      r1,r1,#0x1d4
00002a  2801              CMP      r0,#1
00002c  d100              BNE      |L15.48|
;;;869      {
;;;870        ep->dma_addr = (uint32_t)pBuf;  
00002e  610a              STR      r2,[r1,#0x10]
                  |L15.48|
;;;871      }
;;;872      
;;;873      __HAL_LOCK(hpcd); 
000030  f8940378          LDRB     r0,[r4,#0x378]
000034  2801              CMP      r0,#1
000036  d00d              BEQ      |L15.84|
000038  2001              MOVS     r0,#1
00003a  f8840378          STRB     r0,[r4,#0x378]
;;;874      
;;;875      if ((ep_addr & 0x7F) == 0 )
00003e  0670              LSLS     r0,r6,#25
;;;876      {
;;;877        USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
;;;878      }
;;;879      else
;;;880      {
;;;881        USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
000040  7c22              LDRB     r2,[r4,#0x10]
000042  6820              LDR      r0,[r4,#0]            ;873
000044  d008              BEQ      |L15.88|
000046  f7fffffe          BL       USB_EPStartXfer
;;;882      }
;;;883      __HAL_UNLOCK(hpcd); 
00004a  bf00              NOP      
                  |L15.76|
00004c  f8845378          STRB     r5,[r4,#0x378]
;;;884      
;;;885      return HAL_OK;
000050  2000              MOVS     r0,#0
;;;886    }
000052  bd70              POP      {r4-r6,pc}
                  |L15.84|
000054  2002              MOVS     r0,#2                 ;873
000056  bd70              POP      {r4-r6,pc}
                  |L15.88|
000058  f7fffffe          BL       USB_EP0StartXfer
00005c  e7f6              B        |L15.76|
;;;887    
                          ENDP


                          AREA ||i.HAL_PCD_EP_SetStall||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_SetStall PROC
;;;944      */
;;;945    HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;946    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;947      USB_OTG_EPTypeDef *ep;
;;;948      
;;;949      if ((0x80 & ep_addr) == 0x80)
000006  0609              LSLS     r1,r1,#24
;;;950      {
;;;951        ep = &hpcd->IN_ep[ep_addr & 0x7F];
000008  f005007f          AND      r0,r5,#0x7f
00000c  d505              BPL      |L16.26|
00000e  ebc001c0          RSB      r1,r0,r0,LSL #3
000012  eb040181          ADD      r1,r4,r1,LSL #2
000016  3130              ADDS     r1,r1,#0x30
000018  e005              B        |L16.38|
                  |L16.26|
;;;952      }
;;;953      else
;;;954      {
;;;955        ep = &hpcd->OUT_ep[ep_addr];
00001a  ebc501c5          RSB      r1,r5,r5,LSL #3
00001e  eb040181          ADD      r1,r4,r1,LSL #2
000022  f50171ea          ADD      r1,r1,#0x1d4
                  |L16.38|
;;;956      }
;;;957      
;;;958      ep->is_stall = 1;
000026  2201              MOVS     r2,#1
000028  708a              STRB     r2,[r1,#2]
;;;959      ep->num   = ep_addr & 0x7F;
00002a  7008              STRB     r0,[r1,#0]
;;;960      ep->is_in = ((ep_addr & 0x80) == 0x80);
00002c  09e8              LSRS     r0,r5,#7
00002e  7048              STRB     r0,[r1,#1]
;;;961      
;;;962      
;;;963      __HAL_LOCK(hpcd); 
000030  f8940378          LDRB     r0,[r4,#0x378]
000034  2801              CMP      r0,#1
000036  d007              BEQ      |L16.72|
000038  f8842378          STRB     r2,[r4,#0x378]
;;;964      USB_EPSetStall(hpcd->Instance , ep);
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       USB_EPSetStall
;;;965      if((ep_addr & 0x7F) == 0)
000042  0668              LSLS     r0,r5,#25
000044  d002              BEQ      |L16.76|
000046  e007              B        |L16.88|
                  |L16.72|
000048  2002              MOVS     r0,#2                 ;963
;;;966      {
;;;967        USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
;;;968      }
;;;969      __HAL_UNLOCK(hpcd); 
;;;970      
;;;971      return HAL_OK;
;;;972    }
00004a  bd70              POP      {r4-r6,pc}
                  |L16.76|
00004c  7c21              LDRB     r1,[r4,#0x10]         ;967
00004e  f504725f          ADD      r2,r4,#0x37c          ;967
000052  6820              LDR      r0,[r4,#0]            ;967
000054  f7fffffe          BL       USB_EP0_OutStart
                  |L16.88|
000058  2000              MOVS     r0,#0                 ;969
00005a  f8840378          STRB     r0,[r4,#0x378]        ;969
00005e  bd70              POP      {r4-r6,pc}
;;;973    
                          ENDP


                          AREA ||i.HAL_PCD_EP_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_EP_Transmit PROC
;;;905      */
;;;906    HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;907    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;908      USB_OTG_EPTypeDef *ep;
;;;909      ep = &hpcd->IN_ep[ep_addr & 0x7F];
000006  f001007f          AND      r0,r1,#0x7f
00000a  ebc001c0          RSB      r1,r0,r0,LSL #3
00000e  eb040181          ADD      r1,r4,r1,LSL #2
;;;910      
;;;911      /*setup and start the Xfer */
;;;912      ep->xfer_buff = pBuf;  
;;;913      ep->xfer_len = len;
;;;914      ep->xfer_count = 0;
000012  2500              MOVS     r5,#0
000014  63ca              STR      r2,[r1,#0x3c]
000016  e9c13511          STRD     r3,r5,[r1,#0x44]
;;;915      ep->is_in = 1;
00001a  2301              MOVS     r3,#1
00001c  f8813031          STRB     r3,[r1,#0x31]
;;;916      ep->num = ep_addr & 0x7F;
000020  f8010f30          STRB     r0,[r1,#0x30]!
;;;917      
;;;918      if (hpcd->Init.dma_enable == 1)
000024  6920              LDR      r0,[r4,#0x10]
000026  2801              CMP      r0,#1
000028  d100              BNE      |L17.44|
;;;919      {
;;;920        ep->dma_addr = (uint32_t)pBuf;  
00002a  610a              STR      r2,[r1,#0x10]
                  |L17.44|
;;;921      }
;;;922      
;;;923      __HAL_LOCK(hpcd); 
00002c  f8940378          LDRB     r0,[r4,#0x378]
000030  2801              CMP      r0,#1
000032  d00b              BEQ      |L17.76|
000034  f8843378          STRB     r3,[r4,#0x378]
;;;924      
;;;925      if ((ep_addr & 0x7F) == 0 )
000038  0670              LSLS     r0,r6,#25
;;;926      {
;;;927        USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
;;;928      }
;;;929      else
;;;930      {
;;;931        USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
00003a  7c22              LDRB     r2,[r4,#0x10]
00003c  6820              LDR      r0,[r4,#0]            ;923
00003e  d007              BEQ      |L17.80|
000040  f7fffffe          BL       USB_EPStartXfer
                  |L17.68|
;;;932      }
;;;933      
;;;934      __HAL_UNLOCK(hpcd);
000044  f8845378          STRB     r5,[r4,#0x378]
;;;935         
;;;936      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;937    }
00004a  bd70              POP      {r4-r6,pc}
                  |L17.76|
00004c  2002              MOVS     r0,#2                 ;923
00004e  bd70              POP      {r4-r6,pc}
                  |L17.80|
000050  f7fffffe          BL       USB_EP0StartXfer
000054  e7f6              B        |L17.68|
;;;938    
                          ENDP


                          AREA ||i.HAL_PCD_GetState||, CODE, READONLY, ALIGN=1

                  HAL_PCD_GetState PROC
;;;1138     */
;;;1139   PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
000000  f8900379          LDRB     r0,[r0,#0x379]
;;;1140   {
;;;1141     return hpcd->State;
;;;1142   }
000004  4770              BX       lr
;;;1143   /**
                          ENDP


                          AREA ||i.HAL_PCD_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_PCD_IRQHandler PROC
;;;289    //extern void USB_CORE_0x09_Crutch(void);
;;;290    void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;291    	{
000004  4604              MOV      r4,r0
;;;292    	USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
000006  6800              LDR      r0,[r0,#0]
;;;293    	uint32_t i = 0, ep_intr = 0, epint = 0, epnum = 0;
000008  2600              MOVS     r6,#0
00000a  4605              MOV      r5,r0                 ;292
;;;294    	uint32_t fifoemptymsk = 0, temp = 0;
;;;295    	USB_OTG_EPTypeDef *ep;
;;;296    
;;;297    	/* ensure that we are in device mode */
;;;298    	if( USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE )
00000c  f7fffffe          BL       USB_GetMode
000010  2800              CMP      r0,#0
000012  d176              BNE      |L19.258|
;;;299    		{
;;;300    		/* avoid spurious interrupt */
;;;301    		if( __HAL_IS_INVALID_INTERRUPT(hpcd) ) 
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       USB_ReadInterrupts
00001a  2800              CMP      r0,#0
00001c  d071              BEQ      |L19.258|
;;;302    			{
;;;303    			return;
;;;304    			}
;;;305    
;;;306    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS) )
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       USB_ReadInterrupts
000024  0780              LSLS     r0,r0,#30
000026  d504              BPL      |L19.50|
;;;307    			{
;;;308    			/* incorrect mode, acknowledge the interrupt */
;;;309    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
000028  6820              LDR      r0,[r4,#0]
00002a  6941              LDR      r1,[r0,#0x14]
00002c  f0410102          ORR      r1,r1,#2
000030  6141              STR      r1,[r0,#0x14]
                  |L19.50|
;;;310    			}
;;;311    
;;;312    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT) )
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       USB_ReadInterrupts
000038  0301              LSLS     r1,r0,#12
;;;313    			{
;;;314    			epnum = 0;
;;;315    
;;;316    			/* Read in the device interrupt bits */
;;;317    			ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
;;;318    
;;;319    			while( ep_intr )
;;;320    				{
;;;321    				if( ep_intr & 0x1 )
;;;322    					{
;;;323    					epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
;;;324    
;;;325    					if( (epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC )
;;;326    						{
;;;327    						CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
;;;328    
;;;329    						ep = &hpcd->OUT_ep[ epnum ];
;;;330    
;;;331    						if( hpcd->Init.dma_enable == 1 )
;;;332    							{
;;;333    							ep->xfer_count = ep->maxpacket - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
;;;334    							ep->xfer_buff += ep->maxpacket;            
;;;335    							}
;;;336    
;;;337    						HAL_PCD_DataOutStageCallback(hpcd, epnum);
;;;338    						if( hpcd->Init.dma_enable == 1 )
;;;339    							{
;;;340    							if( (epnum == 0) && (ep->xfer_len == 0) )
;;;341    								{
;;;342    								/* this is ZLP, so prepare EP0 for next setup */
;;;343    								USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
00003a  f504705f          ADD      r0,r4,#0x37c
00003e  f04f0a01          MOV      r10,#1                ;327
;;;344    								}              
;;;345    							}
;;;346    						}
;;;347    
;;;348    					if( (epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP )
;;;349    						{
;;;350    						/* Inform the upper layer that a setup packet is available */
;;;351    						HAL_PCD_SetupStageCallback(hpcd);
;;;352    						CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
000042  f04f0b08          MOV      r11,#8
000046  9000              STR      r0,[sp,#0]            ;312
000048  d54e              BPL      |L19.232|
00004a  6820              LDR      r0,[r4,#0]            ;317
00004c  f7fffffe          BL       USB_ReadDevAllOutEpInterrupt
000050  4607              MOV      r7,r0                 ;317
000052  e047              B        |L19.228|
                  |L19.84|
000054  07f8              LSLS     r0,r7,#31             ;321
000056  d043              BEQ      |L19.224|
000058  b2f1              UXTB     r1,r6                 ;323
00005a  6820              LDR      r0,[r4,#0]            ;323
00005c  f7fffffe          BL       USB_ReadDevOutEPInterrupt
000060  4680              MOV      r8,r0                 ;323
000062  07c0              LSLS     r0,r0,#31             ;325
000064  d02a              BEQ      |L19.188|
000066  eb051046          ADD      r0,r5,r6,LSL #5       ;327
00006a  f8c0ab08          STR      r10,[r0,#0xb08]       ;327
00006e  ebc601c6          RSB      r1,r6,r6,LSL #3       ;329
000072  eb040181          ADD      r1,r4,r1,LSL #2       ;329
000076  f50179ea          ADD      r9,r1,#0x1d4          ;329
00007a  6921              LDR      r1,[r4,#0x10]         ;331
00007c  2901              CMP      r1,#1                 ;331
00007e  d10d              BNE      |L19.156|
000080  f8d91008          LDR      r1,[r9,#8]            ;333
000084  f8d00b10          LDR      r0,[r0,#0xb10]        ;333
000088  f3c00012          UBFX     r0,r0,#0,#19          ;333
00008c  1a09              SUBS     r1,r1,r0              ;333
00008e  f8c91018          STR      r1,[r9,#0x18]         ;333
000092  e9d90102          LDRD     r0,r1,[r9,#8]         ;333
000096  4401              ADD      r1,r1,r0              ;334
000098  f8c9100c          STR      r1,[r9,#0xc]          ;334
                  |L19.156|
00009c  b2f1              UXTB     r1,r6                 ;337
00009e  4620              MOV      r0,r4                 ;337
0000a0  f7fffffe          BL       HAL_PCD_DataOutStageCallback
0000a4  6920              LDR      r0,[r4,#0x10]         ;338
0000a6  2801              CMP      r0,#1                 ;338
0000a8  d108              BNE      |L19.188|
0000aa  b93e              CBNZ     r6,|L19.188|
0000ac  f8d90014          LDR      r0,[r9,#0x14]         ;340
0000b0  b920              CBNZ     r0,|L19.188|
0000b2  6820              LDR      r0,[r4,#0]            ;343
0000b4  2101              MOVS     r1,#1                 ;343
0000b6  9a00              LDR      r2,[sp,#0]            ;343
0000b8  f7fffffe          BL       USB_EP0_OutStart
                  |L19.188|
0000bc  ea5f7008          LSLS     r0,r8,#28             ;348
0000c0  d506              BPL      |L19.208|
0000c2  4620              MOV      r0,r4                 ;351
0000c4  f7fffffe          BL       HAL_PCD_SetupStageCallback
0000c8  eb051146          ADD      r1,r5,r6,LSL #5
0000cc  f8c1bb08          STR      r11,[r1,#0xb08]
                  |L19.208|
;;;353    						}
;;;354    
;;;355    					if( (epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS )
0000d0  ea5f60c8          LSLS     r0,r8,#27
0000d4  d504              BPL      |L19.224|
;;;356    						{
;;;357    						CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
0000d6  eb051146          ADD      r1,r5,r6,LSL #5
0000da  2010              MOVS     r0,#0x10
0000dc  f8c10b08          STR      r0,[r1,#0xb08]
                  |L19.224|
;;;358    						}
;;;359    					}
;;;360    				epnum++;
;;;361    				ep_intr >>= 1;
0000e0  087f              LSRS     r7,r7,#1
0000e2  1c76              ADDS     r6,r6,#1
                  |L19.228|
0000e4  2f00              CMP      r7,#0                 ;319
0000e6  d1b5              BNE      |L19.84|
                  |L19.232|
;;;362    				}
;;;363    			}
;;;364    
;;;365    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT) )
0000e8  6820              LDR      r0,[r4,#0]
0000ea  f7fffffe          BL       USB_ReadInterrupts
0000ee  0340              LSLS     r0,r0,#13
;;;366    			{
;;;367    			/* Read in the device interrupt bits */
;;;368    			ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
;;;369    
;;;370    			epnum = 0;
;;;371    
;;;372    			while( ep_intr )
;;;373    				{
;;;374    				if( ep_intr & 0x1 ) /* In ITR */
;;;375    					{
;;;376    					epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
;;;377    
;;;378    					if( (epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC )
;;;379    						{
;;;380    						fifoemptymsk = (0x1 << epnum);
;;;381    						USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
;;;382    
;;;383    						CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
;;;384    
;;;385    						ep = &hpcd->IN_ep[ epnum ];
;;;386    						if( hpcd->Init.dma_enable == 1 )
;;;387    							{
;;;388    							ep->xfer_buff += ep->maxpacket; 
;;;389    							}
;;;390    
;;;391    						HAL_PCD_DataInStageCallback(hpcd, epnum);
;;;392    
;;;393    						if( hpcd->Init.dma_enable == 1 )
;;;394    							{
;;;395    							/* this is ZLP, so prepare EP0 for next setup */
;;;396    							if( (epnum == 0) && (ep->xfer_len == 0) )
;;;397    								{
;;;398    								/* prepare to rx more setup packets */
;;;399    								USB_EP0_OutStart(hpcd->Instance, 1, (uint8_t *)hpcd->Setup);
;;;400    								}
;;;401    							}           
;;;402    						}
;;;403    						
;;;404    					if( (epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC )
;;;405    						{
;;;406    						CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
;;;407    						}
;;;408    						
;;;409    					if( (epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE )
;;;410    						{					
;;;411    						CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
;;;412    						}
;;;413    						
;;;414    					if( (epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE )
;;;415    						{
;;;416    						CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
0000f0  f04f0940          MOV      r9,#0x40
0000f4  d562              BPL      |L19.444|
0000f6  6820              LDR      r0,[r4,#0]            ;368
0000f8  f7fffffe          BL       USB_ReadDevAllInEpInterrupt
0000fc  4607              MOV      r7,r0                 ;368
0000fe  2600              MOVS     r6,#0                 ;370
000100  e05a              B        |L19.440|
                  |L19.258|
000102  e17e              B        |L19.1026|
                  |L19.260|
000104  07f8              LSLS     r0,r7,#31             ;374
000106  d055              BEQ      |L19.436|
000108  b2f1              UXTB     r1,r6                 ;376
00010a  6820              LDR      r0,[r4,#0]            ;376
00010c  f7fffffe          BL       USB_ReadDevInEPInterrupt
000110  4680              MOV      r8,r0                 ;376
000112  07c0              LSLS     r0,r0,#31             ;378
000114  d029              BEQ      |L19.362|
000116  f8d51834          LDR      r1,[r5,#0x834]        ;381
00011a  fa0af006          LSL      r0,r10,r6             ;380
00011e  4381              BICS     r1,r1,r0              ;381
000120  f8c51834          STR      r1,[r5,#0x834]        ;381
000124  eb051046          ADD      r0,r5,r6,LSL #5       ;383
000128  f8c0a908          STR      r10,[r0,#0x908]       ;383
00012c  ebc600c6          RSB      r0,r6,r6,LSL #3       ;385
000130  eb040080          ADD      r0,r4,r0,LSL #2       ;385
000134  3030              ADDS     r0,r0,#0x30           ;385
000136  9001              STR      r0,[sp,#4]            ;386
000138  6920              LDR      r0,[r4,#0x10]         ;386
00013a  2801              CMP      r0,#1                 ;386
00013c  d105              BNE      |L19.330|
00013e  9801              LDR      r0,[sp,#4]            ;388
000140  68c1              LDR      r1,[r0,#0xc]          ;388
000142  6880              LDR      r0,[r0,#8]            ;388
000144  4401              ADD      r1,r1,r0              ;388
000146  9801              LDR      r0,[sp,#4]            ;388
000148  60c1              STR      r1,[r0,#0xc]          ;388
                  |L19.330|
00014a  b2f1              UXTB     r1,r6                 ;391
00014c  4620              MOV      r0,r4                 ;391
00014e  f7fffffe          BL       HAL_PCD_DataInStageCallback
000152  6920              LDR      r0,[r4,#0x10]         ;393
000154  2801              CMP      r0,#1                 ;393
000156  d108              BNE      |L19.362|
000158  b93e              CBNZ     r6,|L19.362|
00015a  9801              LDR      r0,[sp,#4]            ;396
00015c  6940              LDR      r0,[r0,#0x14]         ;396
00015e  b920              CBNZ     r0,|L19.362|
000160  6820              LDR      r0,[r4,#0]            ;399
000162  2101              MOVS     r1,#1                 ;399
000164  9a00              LDR      r2,[sp,#0]            ;399
000166  f7fffffe          BL       USB_EP0_OutStart
                  |L19.362|
00016a  ea5f7008          LSLS     r0,r8,#28             ;404
00016e  d503              BPL      |L19.376|
000170  eb051146          ADD      r1,r5,r6,LSL #5       ;406
000174  f8c1b908          STR      r11,[r1,#0x908]       ;406
                  |L19.376|
000178  ea5f60c8          LSLS     r0,r8,#27             ;409
00017c  d504              BPL      |L19.392|
00017e  eb051146          ADD      r1,r5,r6,LSL #5       ;411
000182  2010              MOVS     r0,#0x10              ;411
000184  f8c10908          STR      r0,[r1,#0x908]        ;411
                  |L19.392|
000188  ea5f6048          LSLS     r0,r8,#25             ;414
00018c  d503              BPL      |L19.406|
00018e  eb051146          ADD      r1,r5,r6,LSL #5
000192  f8c19908          STR      r9,[r1,#0x908]
                  |L19.406|
;;;417    						}
;;;418    						
;;;419    					if( (epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD )
000196  ea5f7088          LSLS     r0,r8,#30
00019a  d504              BPL      |L19.422|
;;;420    						{
;;;421    						CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
00019c  eb051146          ADD      r1,r5,r6,LSL #5
0001a0  2002              MOVS     r0,#2
0001a2  f8c10908          STR      r0,[r1,#0x908]
                  |L19.422|
;;;422    						} 
;;;423    						
;;;424    					if( (epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE )
0001a6  ea5f6008          LSLS     r0,r8,#24
0001aa  d503              BPL      |L19.436|
;;;425    						{
;;;426    						PCD_WriteEmptyTxFifo(hpcd , epnum);
0001ac  4631              MOV      r1,r6
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       PCD_WriteEmptyTxFifo
                  |L19.436|
;;;427    						}
;;;428    					}
;;;429    				epnum++;
;;;430    				ep_intr >>= 1;
0001b4  087f              LSRS     r7,r7,#1
0001b6  1c76              ADDS     r6,r6,#1
                  |L19.440|
0001b8  2f00              CMP      r7,#0                 ;372
0001ba  d1a3              BNE      |L19.260|
                  |L19.444|
;;;431    				}
;;;432    			}
;;;433    
;;;434    		/* Handle Resume Interrupt */
;;;435    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT) )
0001bc  6820              LDR      r0,[r4,#0]
0001be  f7fffffe          BL       USB_ReadInterrupts
0001c2  2800              CMP      r0,#0
0001c4  da0d              BGE      |L19.482|
;;;436    			{    
;;;437    			/* Clear the Remote Wake-up Signaling */
;;;438    			USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
0001c6  f8d50804          LDR      r0,[r5,#0x804]
0001ca  f0200001          BIC      r0,r0,#1
0001ce  f8c50804          STR      r0,[r5,#0x804]
;;;439    
;;;440    			HAL_PCD_ResumeCallback(hpcd);
0001d2  4620              MOV      r0,r4
0001d4  f7fffffe          BL       HAL_PCD_ResumeCallback
;;;441    
;;;442    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
0001d8  6820              LDR      r0,[r4,#0]
0001da  6941              LDR      r1,[r0,#0x14]
0001dc  f0414100          ORR      r1,r1,#0x80000000
0001e0  6141              STR      r1,[r0,#0x14]
                  |L19.482|
;;;443    			}
;;;444    
;;;445    		/* Handle Suspend Interrupt */
;;;446    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP) )
0001e2  6820              LDR      r0,[r4,#0]
0001e4  f7fffffe          BL       USB_ReadInterrupts
0001e8  0500              LSLS     r0,r0,#20
0001ea  d50b              BPL      |L19.516|
;;;447    			{
;;;448    			if( (USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS )
0001ec  f8d50808          LDR      r0,[r5,#0x808]
0001f0  07c0              LSLS     r0,r0,#31
0001f2  d002              BEQ      |L19.506|
;;;449    				{ 
;;;450    				HAL_PCD_SuspendCallback(hpcd);
0001f4  4620              MOV      r0,r4
0001f6  f7fffffe          BL       HAL_PCD_SuspendCallback
                  |L19.506|
;;;451    				}
;;;452    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
0001fa  6820              LDR      r0,[r4,#0]
0001fc  6941              LDR      r1,[r0,#0x14]
0001fe  f4416100          ORR      r1,r1,#0x800
000202  6141              STR      r1,[r0,#0x14]
                  |L19.516|
;;;453    			}
;;;454    
;;;455    		/* Handle Reset Interrupt */
;;;456    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST) )
000204  6820              LDR      r0,[r4,#0]
000206  f7fffffe          BL       USB_ReadInterrupts
00020a  04c0              LSLS     r0,r0,#19
00020c  d54b              BPL      |L19.678|
;;;457    			{
;;;458    			USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
00020e  f8d50804          LDR      r0,[r5,#0x804]
000212  f0200001          BIC      r0,r0,#1
000216  f8c50804          STR      r0,[r5,#0x804]
;;;459    			USB_FlushTxFifo(hpcd->Instance ,  0 );
00021a  2100              MOVS     r1,#0
00021c  6820              LDR      r0,[r4,#0]
00021e  f7fffffe          BL       USB_FlushTxFifo
;;;460    
;;;461    			for( i = 0; i < hpcd->Init.dev_endpoints; i++ )
000222  2000              MOVS     r0,#0
;;;462    				{
;;;463    				USBx_INEP(i)->DIEPINT = 0xFF;
000224  21ff              MOVS     r1,#0xff
000226  e006              B        |L19.566|
                  |L19.552|
000228  eb051240          ADD      r2,r5,r0,LSL #5
00022c  f8c21908          STR      r1,[r2,#0x908]
;;;464    				USBx_OUTEP(i)->DOEPINT = 0xFF;
000230  f8c21b08          STR      r1,[r2,#0xb08]
000234  1c40              ADDS     r0,r0,#1
                  |L19.566|
000236  6862              LDR      r2,[r4,#4]            ;461
000238  4282              CMP      r2,r0                 ;461
00023a  d8f5              BHI      |L19.552|
;;;465    				}
;;;466    			USBx_DEVICE->DAINT = 0xFFFFFFFF;
00023c  f04f30ff          MOV      r0,#0xffffffff
000240  f8c50818          STR      r0,[r5,#0x818]
;;;467    			USBx_DEVICE->DAINTMSK |= 0x10001;
000244  f8d5081c          LDR      r0,[r5,#0x81c]
000248  f0401001          ORR      r0,r0,#0x10001
00024c  f8c5081c          STR      r0,[r5,#0x81c]
;;;468    
;;;469    			if( hpcd->Init.use_dedicated_ep1 )
000250  6aa0              LDR      r0,[r4,#0x28]
000252  b160              CBZ      r0,|L19.622|
;;;470    				{
;;;471    				USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
000254  f8d50884          LDR      r0,[r5,#0x884]
000258  f040000b          ORR      r0,r0,#0xb
00025c  f8c50884          STR      r0,[r5,#0x884]
;;;472    				USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
000260  f8d50844          LDR      r0,[r5,#0x844]
000264  f040000b          ORR      r0,r0,#0xb
000268  f8c50844          STR      r0,[r5,#0x844]
00026c  e00b              B        |L19.646|
                  |L19.622|
;;;473    				}
;;;474    			else
;;;475    				{
;;;476    				USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
00026e  f8d50814          LDR      r0,[r5,#0x814]
000272  f040000b          ORR      r0,r0,#0xb
000276  f8c50814          STR      r0,[r5,#0x814]
;;;477    				USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
00027a  f8d50810          LDR      r0,[r5,#0x810]
00027e  f040000b          ORR      r0,r0,#0xb
000282  f8c50810          STR      r0,[r5,#0x810]
                  |L19.646|
;;;478    				}
;;;479    
;;;480    			/* Set Default Address to 0 */
;;;481    			USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
000286  f8d50800          LDR      r0,[r5,#0x800]
00028a  f42060fe          BIC      r0,r0,#0x7f0
00028e  f8c50800          STR      r0,[r5,#0x800]
;;;482    
;;;483    			/* setup EP0 to receive SETUP packets */
;;;484    			USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
000292  7c21              LDRB     r1,[r4,#0x10]
000294  6820              LDR      r0,[r4,#0]
000296  9a00              LDR      r2,[sp,#0]
000298  f7fffffe          BL       USB_EP0_OutStart
;;;485    
;;;486    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
00029c  6820              LDR      r0,[r4,#0]
00029e  6941              LDR      r1,[r0,#0x14]
0002a0  f4415180          ORR      r1,r1,#0x1000
0002a4  6141              STR      r1,[r0,#0x14]
                  |L19.678|
;;;487    			}
;;;488    
;;;489    		/* Handle Enumeration done Interrupt */
;;;490    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE) )
0002a6  6820              LDR      r0,[r4,#0]
0002a8  f7fffffe          BL       USB_ReadInterrupts
0002ac  0480              LSLS     r0,r0,#18
0002ae  d51c              BPL      |L19.746|
;;;491    			{
;;;492    			USB_ActivateSetup(hpcd->Instance);
0002b0  6820              LDR      r0,[r4,#0]
0002b2  f7fffffe          BL       USB_ActivateSetup
;;;493    			hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
0002b6  6820              LDR      r0,[r4,#0]
0002b8  68c1              LDR      r1,[r0,#0xc]
0002ba  f4215170          BIC      r1,r1,#0x3c00
0002be  60c1              STR      r1,[r0,#0xc]
;;;494    
;;;495    			if( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH )
0002c0  6820              LDR      r0,[r4,#0]
0002c2  f7fffffe          BL       USB_GetDevSpeed
0002c6  b358              CBZ      r0,|L19.800|
;;;496    				{
;;;497    				hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
;;;498    				hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
;;;499    				hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_3);
;;;500    				}
;;;501    			else
;;;502    				{
;;;503    				hpcd->Init.speed            = USB_OTG_SPEED_FULL;
0002c8  2003              MOVS     r0,#3
;;;504    				hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
;;;505    				hpcd->Instance->GUSBCFG |= (USB_OTG_GUSBCFG_TRDT_0 | USB_OTG_GUSBCFG_TRDT_2);
0002ca  f8c49014          STR      r9,[r4,#0x14]
0002ce  60e0              STR      r0,[r4,#0xc]
0002d0  6820              LDR      r0,[r4,#0]
0002d2  68c1              LDR      r1,[r0,#0xc]
0002d4  f44151a0          ORR      r1,r1,#0x1400
                  |L19.728|
0002d8  60c1              STR      r1,[r0,#0xc]
;;;506    				}
;;;507    
;;;508    			HAL_PCD_ResetCallback(hpcd);
0002da  4620              MOV      r0,r4
0002dc  f7fffffe          BL       HAL_PCD_ResetCallback
;;;509    
;;;510    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
0002e0  6820              LDR      r0,[r4,#0]
0002e2  6941              LDR      r1,[r0,#0x14]
0002e4  f4415100          ORR      r1,r1,#0x2000
0002e8  6141              STR      r1,[r0,#0x14]
                  |L19.746|
;;;511    			}
;;;512    
;;;513    
;;;514    		/* Handle RxQLevel Interrupt */
;;;515    		if(__HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
0002ea  6820              LDR      r0,[r4,#0]
0002ec  f7fffffe          BL       USB_ReadInterrupts
0002f0  06c0              LSLS     r0,r0,#27
0002f2  d540              BPL      |L19.886|
;;;516    			{
;;;517    			USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
0002f4  6820              LDR      r0,[r4,#0]
0002f6  6981              LDR      r1,[r0,#0x18]
0002f8  f0210110          BIC      r1,r1,#0x10
0002fc  6181              STR      r1,[r0,#0x18]
;;;518    			temp = USBx->GRXSTSP;
0002fe  f8d58020          LDR      r8,[r5,#0x20]
;;;519    			ep = &hpcd->OUT_ep[ temp & USB_OTG_GRXSTSP_EPNUM ];
000302  f008000f          AND      r0,r8,#0xf
000306  ebc000c0          RSB      r0,r0,r0,LSL #3
00030a  eb040780          ADD      r7,r4,r0,LSL #2
;;;520    
;;;521    			if( ((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT )
00030e  f3c84043          UBFX     r0,r8,#17,#4
000312  f50777ea          ADD      r7,r7,#0x1d4
000316  2802              CMP      r0,#2
000318  d00c              BEQ      |L19.820|
;;;522    				{
;;;523    				if( (temp & USB_OTG_GRXSTSP_BCNT) != 0 )
;;;524    					{
;;;525    					USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4);
;;;526    					ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
;;;527    					ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
;;;528    					}
;;;529    				}
;;;530    			else if( ((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT )
00031a  2806              CMP      r0,#6
00031c  d01c              BEQ      |L19.856|
00031e  e025              B        |L19.876|
                  |L19.800|
000320  2000              MOVS     r0,#0                 ;497
000322  60e0              STR      r0,[r4,#0xc]          ;498
000324  f44f7000          MOV      r0,#0x200             ;498
000328  6160              STR      r0,[r4,#0x14]         ;499
00032a  6820              LDR      r0,[r4,#0]            ;499
00032c  68c1              LDR      r1,[r0,#0xc]          ;499
00032e  f4415110          ORR      r1,r1,#0x2400         ;499
000332  e7d1              B        |L19.728|
                  |L19.820|
000334  f64771f0          MOV      r1,#0x7ff0            ;523
000338  ea180f01          TST      r8,r1                 ;523
00033c  d016              BEQ      |L19.876|
00033e  f3c8120a          UBFX     r2,r8,#4,#11          ;525
000342  4690              MOV      r8,r2                 ;525
000344  4628              MOV      r0,r5                 ;525
000346  68f9              LDR      r1,[r7,#0xc]          ;525
000348  f7fffffe          BL       USB_ReadPacket
00034c  68f8              LDR      r0,[r7,#0xc]          ;526
00034e  4440              ADD      r0,r0,r8              ;526
000350  60f8              STR      r0,[r7,#0xc]          ;527
000352  69b8              LDR      r0,[r7,#0x18]         ;527
000354  4440              ADD      r0,r0,r8              ;527
000356  e008              B        |L19.874|
                  |L19.856|
;;;531    				{
;;;532    				USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8);
000358  2208              MOVS     r2,#8
00035a  4628              MOV      r0,r5
00035c  9900              LDR      r1,[sp,#0]
00035e  f7fffffe          BL       USB_ReadPacket
;;;533    				ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
000362  69b9              LDR      r1,[r7,#0x18]
000364  f3c8100a          UBFX     r0,r8,#4,#11
000368  4408              ADD      r0,r0,r1
                  |L19.874|
00036a  61b8              STR      r0,[r7,#0x18]
                  |L19.876|
;;;534    				}
;;;535    			USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
00036c  6820              LDR      r0,[r4,#0]
00036e  6981              LDR      r1,[r0,#0x18]
000370  f0410110          ORR      r1,r1,#0x10
000374  6181              STR      r1,[r0,#0x18]
                  |L19.886|
;;;536    			}
;;;537    
;;;538    		/* Handle SOF Interrupt */
;;;539    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF) )
000376  6820              LDR      r0,[r4,#0]
000378  f7fffffe          BL       USB_ReadInterrupts
00037c  0700              LSLS     r0,r0,#28
00037e  d507              BPL      |L19.912|
;;;540    			{
;;;541    			HAL_PCD_SOFCallback(hpcd);
000380  4620              MOV      r0,r4
000382  f7fffffe          BL       HAL_PCD_SOFCallback
;;;542    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
000386  6820              LDR      r0,[r4,#0]
000388  6941              LDR      r1,[r0,#0x14]
00038a  f0410108          ORR      r1,r1,#8
00038e  6141              STR      r1,[r0,#0x14]
                  |L19.912|
;;;543    			}
;;;544    
;;;545    		/* Handle Incomplete ISO IN Interrupt */
;;;546    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR) )
000390  6820              LDR      r0,[r4,#0]
000392  f7fffffe          BL       USB_ReadInterrupts
000396  02c0              LSLS     r0,r0,#11
000398  d508              BPL      |L19.940|
;;;547    			{
;;;548    			HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
00039a  b2f1              UXTB     r1,r6
00039c  4620              MOV      r0,r4
00039e  f7fffffe          BL       HAL_PCD_ISOINIncompleteCallback
;;;549    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
0003a2  6820              LDR      r0,[r4,#0]
0003a4  6941              LDR      r1,[r0,#0x14]
0003a6  f4411180          ORR      r1,r1,#0x100000
0003aa  6141              STR      r1,[r0,#0x14]
                  |L19.940|
;;;550    			} 
;;;551    
;;;552    		/* Handle Incomplete ISO OUT Interrupt */
;;;553    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT) )
0003ac  6820              LDR      r0,[r4,#0]
0003ae  f7fffffe          BL       USB_ReadInterrupts
0003b2  0280              LSLS     r0,r0,#10
0003b4  d508              BPL      |L19.968|
;;;554    			{
;;;555    			HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
0003b6  b2f1              UXTB     r1,r6
0003b8  4620              MOV      r0,r4
0003ba  f7fffffe          BL       HAL_PCD_ISOOUTIncompleteCallback
;;;556    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
0003be  6820              LDR      r0,[r4,#0]
0003c0  6941              LDR      r1,[r0,#0x14]
0003c2  f4411100          ORR      r1,r1,#0x200000
0003c6  6141              STR      r1,[r0,#0x14]
                  |L19.968|
;;;557    			} 
;;;558    
;;;559    		/* Handle Connection event Interrupt */
;;;560    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT) )
0003c8  6820              LDR      r0,[r4,#0]
0003ca  f7fffffe          BL       USB_ReadInterrupts
0003ce  0040              LSLS     r0,r0,#1
0003d0  d507              BPL      |L19.994|
;;;561    			{
;;;562    			HAL_PCD_ConnectCallback(hpcd);
0003d2  4620              MOV      r0,r4
0003d4  f7fffffe          BL       HAL_PCD_ConnectCallback
;;;563    			__HAL_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
0003d8  6820              LDR      r0,[r4,#0]
0003da  6941              LDR      r1,[r0,#0x14]
0003dc  f0414180          ORR      r1,r1,#0x40000000
0003e0  6141              STR      r1,[r0,#0x14]
                  |L19.994|
;;;564    			} 
;;;565    
;;;566    		/* Handle Disconnection event Interrupt */
;;;567    		if( __HAL_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT) )
0003e2  6820              LDR      r0,[r4,#0]
0003e4  f7fffffe          BL       USB_ReadInterrupts
0003e8  0740              LSLS     r0,r0,#29
0003ea  d50a              BPL      |L19.1026|
;;;568    			{
;;;569    			temp = hpcd->Instance->GOTGINT;
0003ec  6820              LDR      r0,[r4,#0]
0003ee  6845              LDR      r5,[r0,#4]
;;;570    
;;;571    			if( (temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET )
0003f0  0768              LSLS     r0,r5,#29
0003f2  d502              BPL      |L19.1018|
;;;572    				{
;;;573    				HAL_PCD_DisconnectCallback(hpcd);
0003f4  4620              MOV      r0,r4
0003f6  f7fffffe          BL       HAL_PCD_DisconnectCallback
                  |L19.1018|
;;;574    				}
;;;575    			hpcd->Instance->GOTGINT |= temp;
0003fa  6820              LDR      r0,[r4,#0]
0003fc  6841              LDR      r1,[r0,#4]
0003fe  4329              ORRS     r1,r1,r5
000400  6041              STR      r1,[r0,#4]
                  |L19.1026|
;;;576    			}
;;;577    		}
;;;578    	}
000402  e8bd9ffc          POP      {r2-r12,pc}
;;;579    
                          ENDP


                          AREA ||i.HAL_PCD_ISOINIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOINIncompleteCallback PROC
;;;679      */
;;;680     __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;681    {
;;;682      /* NOTE : This function Should not be modified, when the callback is needed,
;;;683                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;684       */ 
;;;685    }
;;;686    
                          ENDP


                          AREA ||i.HAL_PCD_ISOOUTIncompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ISOOUTIncompleteCallback PROC
;;;667      */
;;;668     __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
000000  4770              BX       lr
;;;669    {
;;;670      /* NOTE : This function Should not be modified, when the callback is needed,
;;;671                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;672       */ 
;;;673    }
;;;674    
                          ENDP


                          AREA ||i.HAL_PCD_Init||, CODE, READONLY, ALIGN=2

                  HAL_PCD_Init PROC
;;;121      */
;;;122    HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;123    { 
000002  b089              SUB      sp,sp,#0x24
000004  0004              MOVS     r4,r0
;;;124      uint32_t i = 0;
000006  f04f0700          MOV      r7,#0
00000a  d056              BEQ      |L22.186|
;;;125      
;;;126      /* Check the PCD handle allocation */
;;;127      if(hpcd == NULL)
;;;128      {
;;;129        return HAL_ERROR;
;;;130      }
;;;131      
;;;132      /* Check the parameters */
;;;133      assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
;;;134    
;;;135      hpcd->State = PCD_BUSY;
00000c  2002              MOVS     r0,#2
00000e  f8840379          STRB     r0,[r4,#0x379]
;;;136      
;;;137      /* Init the low level hardware : GPIO, CLOCK, NVIC... */
;;;138      HAL_PCD_MspInit(hpcd);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_PCD_MspInit
;;;139    
;;;140      /* Disable the Interrupts */
;;;141     __HAL_PCD_DISABLE(hpcd);
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       USB_DisableGlobalInt
;;;142     
;;;143     /*Init the Core (common init.) */
;;;144     USB_CoreInit(hpcd->Instance, hpcd->Init);
00001e  f1040110          ADD      r1,r4,#0x10
000022  2220              MOVS     r2,#0x20
000024  460e              MOV      r6,r1
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       __aeabi_memcpy4
00002c  e894000f          LDM      r4,{r0-r3}
000030  f7fffffe          BL       USB_CoreInit
;;;145     
;;;146     /* Force Device Mode*/
;;;147     USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
000034  2100              MOVS     r1,#0
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       USB_SetCurrentMode
00003c  2101              MOVS     r1,#1                 ;129
00003e  2500              MOVS     r5,#0                 ;129
                  |L22.64|
;;;148     
;;;149     /* Init endpoints structures */
;;;150     for (i = 0; i < 15 ; i++)
;;;151     {
;;;152       /* Init ep structure */
;;;153       hpcd->IN_ep[i].is_in = 1;
000040  ebc700c7          RSB      r0,r7,r7,LSL #3
000044  eb040080          ADD      r0,r4,r0,LSL #2
000048  f8801031          STRB     r1,[r0,#0x31]
;;;154       hpcd->IN_ep[i].num = i;
00004c  f8007f30          STRB     r7,[r0,#0x30]!
;;;155       hpcd->IN_ep[i].tx_fifo_num = i;
000050  80c7              STRH     r7,[r0,#6]
;;;156       /* Control until ep is actvated */
;;;157       hpcd->IN_ep[i].type = EP_TYPE_CTRL;
000052  70c5              STRB     r5,[r0,#3]
;;;158       hpcd->IN_ep[i].maxpacket =  0;
;;;159       hpcd->IN_ep[i].xfer_buff = 0;
000054  6085              STR      r5,[r0,#8]
;;;160       hpcd->IN_ep[i].xfer_len = 0;
000056  60c5              STR      r5,[r0,#0xc]
000058  1c7f              ADDS     r7,r7,#1
00005a  6145              STR      r5,[r0,#0x14]         ;150
00005c  2f0f              CMP      r7,#0xf               ;150
00005e  d3ef              BCC      |L22.64|
;;;161     }
;;;162     
;;;163     for (i = 0; i < 15 ; i++)
000060  2000              MOVS     r0,#0
;;;164     {
;;;165       hpcd->OUT_ep[i].is_in = 0;
;;;166       hpcd->OUT_ep[i].num = i;
;;;167       hpcd->IN_ep[i].tx_fifo_num = i;
;;;168       /* Control until ep is activated */
;;;169       hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
;;;170       hpcd->OUT_ep[i].maxpacket = 0;
;;;171       hpcd->OUT_ep[i].xfer_buff = 0;
;;;172       hpcd->OUT_ep[i].xfer_len = 0;
;;;173       
;;;174       hpcd->Instance->DIEPTXF[i] = 0;
000062  f44f7282          MOV      r2,#0x104
000066  bf00              NOP                            ;165
                  |L22.104|
000068  ebc001c0          RSB      r1,r0,r0,LSL #3       ;165
00006c  eb040181          ADD      r1,r4,r1,LSL #2       ;165
000070  eb020380          ADD      r3,r2,r0,LSL #2
000074  f88151d5          STRB     r5,[r1,#0x1d5]        ;165
000078  f88101d4          STRB     r0,[r1,#0x1d4]        ;166
00007c  86c8              STRH     r0,[r1,#0x36]         ;167
00007e  f88151d7          STRB     r5,[r1,#0x1d7]        ;169
000082  f8c151dc          STR      r5,[r1,#0x1dc]        ;171
000086  f8c151e0          STR      r5,[r1,#0x1e0]        ;172
00008a  f8c151e8          STR      r5,[r1,#0x1e8]
00008e  6821              LDR      r1,[r4,#0]
000090  50cd              STR      r5,[r1,r3]
000092  1c40              ADDS     r0,r0,#1
000094  280f              CMP      r0,#0xf               ;163
000096  d3e7              BCC      |L22.104|
;;;175     }
;;;176     
;;;177     /* Init Device */
;;;178     USB_DevInit(hpcd->Instance, hpcd->Init);
000098  2220              MOVS     r2,#0x20
00009a  4631              MOV      r1,r6
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       __aeabi_memcpy4
0000a2  e894000f          LDM      r4,{r0-r3}
0000a6  f7fffffe          BL       USB_DevInit
;;;179     
;;;180     hpcd->State= PCD_READY;
0000aa  f8845379          STRB     r5,[r4,#0x379]
;;;181     
;;;182     USB_DevDisconnect (hpcd->Instance);  
0000ae  6820              LDR      r0,[r4,#0]
0000b0  f7fffffe          BL       USB_DevDisconnect
;;;183     return HAL_OK;
0000b4  2000              MOVS     r0,#0
                  |L22.182|
;;;184    }
0000b6  b009              ADD      sp,sp,#0x24
0000b8  bdf0              POP      {r4-r7,pc}
                  |L22.186|
0000ba  2001              MOVS     r0,#1                 ;129
0000bc  e7fb              B        |L22.182|
;;;185    
                          ENDP


                          AREA ||i.HAL_PCD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_MspDeInit PROC
;;;228      */
;;;229    __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;230    {
;;;231      /* NOTE : This function Should not be modified, when the callback is needed,
;;;232                the HAL_PCD_MspDeInit could be implenetd in the user file
;;;233       */
;;;234    }
;;;235    
                          ENDP


                          AREA ||i.HAL_PCD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_PCD_MspInit PROC
;;;216      */
;;;217    __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;218    {
;;;219      /* NOTE : This function Should not be modified, when the callback is needed,
;;;220                the HAL_PCD_MspInit could be implenetd in the user file
;;;221       */
;;;222    }
;;;223    
                          ENDP


                          AREA ||i.HAL_PCD_ResetCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResetCallback PROC
;;;631      */
;;;632     __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;633    {
;;;634      /* NOTE : This function Should not be modified, when the callback is needed,
;;;635                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;636       */ 
;;;637    }
;;;638    
                          ENDP


                          AREA ||i.HAL_PCD_ResumeCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_ResumeCallback PROC
;;;655      */
;;;656     __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;657    {
;;;658      /* NOTE : This function Should not be modified, when the callback is needed,
;;;659                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;660       */ 
;;;661    }
;;;662    
                          ENDP


                          AREA ||i.HAL_PCD_SOFCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SOFCallback PROC
;;;619      */
;;;620     __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;621    {
;;;622      /* NOTE : This function Should not be modified, when the callback is needed,
;;;623                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;624       */ 
;;;625    }
;;;626    
                          ENDP


                          AREA ||i.HAL_PCD_SetAddress||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetAddress PROC
;;;765      */
;;;766    HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
000000  b510              PUSH     {r4,lr}
;;;767    {
000002  4604              MOV      r4,r0
;;;768      __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L28.32|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;769      USB_SetDevAddress(hpcd->Instance, address);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USB_SetDevAddress
;;;770      __HAL_UNLOCK(hpcd);   
000018  2000              MOVS     r0,#0
00001a  f8840378          STRB     r0,[r4,#0x378]
;;;771      return HAL_OK;
;;;772    }
00001e  bd10              POP      {r4,pc}
                  |L28.32|
000020  2002              MOVS     r0,#2                 ;768
000022  bd10              POP      {r4,pc}
;;;773    /**
                          ENDP


                          AREA ||i.HAL_PCD_SetRxFiFo||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetRxFiFo PROC
;;;1075     */
;;;1076   HAL_StatusTypeDef HAL_PCD_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
000000  6800              LDR      r0,[r0,#0]
;;;1077   {
;;;1078     
;;;1079     hpcd->Instance->GRXFSIZ = size;
000002  6241              STR      r1,[r0,#0x24]
;;;1080     
;;;1081     return HAL_OK;
000004  2000              MOVS     r0,#0
;;;1082   }
000006  4770              BX       lr
;;;1083   
                          ENDP


                          AREA ||i.HAL_PCD_SetTxFiFo||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetTxFiFo PROC
;;;1032     */
;;;1033   HAL_StatusTypeDef HAL_PCD_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1034   {
;;;1035     uint8_t i = 0;
;;;1036     uint32_t Tx_Offset = 0;
;;;1037     
;;;1038     
;;;1039     /*  TXn min size = 16 words. (n  : Transmit FIFO index)
;;;1040     *   When a TxFIFO is not used, the Configuration should be as follows: 
;;;1041     *       case 1 :  n > m    and Txn is not used    (n,m  : Transmit FIFO indexes)
;;;1042     *       --> Txm can use the space allocated for Txn.
;;;1043     *       case2  :  n < m    and Txn is not used    (n,m  : Transmit FIFO indexes)
;;;1044     *       --> Txn should be configured with the minimum space of 16 words
;;;1045     *  The FIFO is used optimally when used TxFIFOs are allocated in the top 
;;;1046     *       of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
;;;1047     *   When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
;;;1048     
;;;1049     Tx_Offset = hpcd->Instance->GRXFSIZ;
000002  6800              LDR      r0,[r0,#0]
000004  2300              MOVS     r3,#0                 ;1035
000006  6a44              LDR      r4,[r0,#0x24]
000008  b131              CBZ      r1,|L30.24|
;;;1050     
;;;1051     if(fifo == 0)
;;;1052     {
;;;1053       hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (size << 16) | Tx_Offset;
;;;1054     }
;;;1055     else
;;;1056     {
;;;1057       Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
00000a  6a85              LDR      r5,[r0,#0x28]
;;;1058       for (i = 0; i < (fifo - 1); i++)
;;;1059       {
;;;1060         Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
00000c  f44f7682          MOV      r6,#0x104
000010  eb044415          ADD      r4,r4,r5,LSR #16      ;1057
000014  1e4d              SUBS     r5,r1,#1              ;1058
000016  e00a              B        |L30.46|
                  |L30.24|
000018  ea444102          ORR      r1,r4,r2,LSL #16      ;1053
00001c  6281              STR      r1,[r0,#0x28]         ;1053
00001e  e00f              B        |L30.64|
                  |L30.32|
000020  eb060783          ADD      r7,r6,r3,LSL #2
000024  59c7              LDR      r7,[r0,r7]
000026  1c5b              ADDS     r3,r3,#1
000028  eb044417          ADD      r4,r4,r7,LSR #16
00002c  b2db              UXTB     r3,r3                 ;1058
                  |L30.46|
00002e  42ab              CMP      r3,r5                 ;1058
000030  dbf6              BLT      |L30.32|
;;;1061       }
;;;1062       
;;;1063       /* Multiply Tx_Size by 2 to get higher performance */
;;;1064       hpcd->Instance->DIEPTXF[fifo - 1] = (size << 16) | Tx_Offset;
000032  f44f7380          MOV      r3,#0x100
000036  eb030181          ADD      r1,r3,r1,LSL #2
00003a  ea444202          ORR      r2,r4,r2,LSL #16
00003e  5042              STR      r2,[r0,r1]
                  |L30.64|
;;;1065       
;;;1066     }
;;;1067     
;;;1068     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1069   }
000042  bdf0              POP      {r4-r7,pc}
;;;1070   
                          ENDP


                          AREA ||i.HAL_PCD_SetupStageCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SetupStageCallback PROC
;;;607      */
;;;608     __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;609    {
;;;610      /* NOTE : This function Should not be modified, when the callback is needed,
;;;611                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;612       */ 
;;;613    }
;;;614    
                          ENDP


                          AREA ||i.HAL_PCD_Start||, CODE, READONLY, ALIGN=1

                  HAL_PCD_Start PROC
;;;259      */
;;;260    HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;261    { 
000002  4604              MOV      r4,r0
;;;262      __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L32.38|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;263      USB_DevConnect (hpcd->Instance);  
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USB_DevConnect
;;;264      __HAL_PCD_ENABLE(hpcd);
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       USB_EnableGlobalInt
;;;265      __HAL_UNLOCK(hpcd); 
00001e  2000              MOVS     r0,#0
000020  f8840378          STRB     r0,[r4,#0x378]
;;;266      return HAL_OK;
;;;267    }
000024  bd10              POP      {r4,pc}
                  |L32.38|
000026  2002              MOVS     r0,#2                 ;262
000028  bd10              POP      {r4,pc}
;;;268    
                          ENDP


                          AREA ||i.HAL_PCD_Stop||, CODE, READONLY, ALIGN=1

                  HAL_PCD_Stop PROC
;;;273      */
;;;274    HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
000000  b510              PUSH     {r4,lr}
;;;275    { 
000002  4604              MOV      r4,r0
;;;276      __HAL_LOCK(hpcd); 
000004  f8900378          LDRB     r0,[r0,#0x378]
000008  2801              CMP      r0,#1
00000a  d00f              BEQ      |L33.44|
00000c  2001              MOVS     r0,#1
00000e  f8840378          STRB     r0,[r4,#0x378]
;;;277      __HAL_PCD_DISABLE(hpcd);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       USB_DisableGlobalInt
;;;278      USB_StopDevice(hpcd->Instance);
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       USB_StopDevice
;;;279      USB_DevDisconnect (hpcd->Instance);
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       USB_DevDisconnect
;;;280      __HAL_UNLOCK(hpcd); 
000024  2000              MOVS     r0,#0
000026  f8840378          STRB     r0,[r4,#0x378]
;;;281      return HAL_OK;
;;;282    }
00002a  bd10              POP      {r4,pc}
                  |L33.44|
00002c  2002              MOVS     r0,#2                 ;276
00002e  bd10              POP      {r4,pc}
;;;283    
                          ENDP


                          AREA ||i.HAL_PCD_SuspendCallback||, CODE, READONLY, ALIGN=1

                  HAL_PCD_SuspendCallback PROC
;;;643      */
;;;644     __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
000000  4770              BX       lr
;;;645    {
;;;646      /* NOTE : This function Should not be modified, when the callback is needed,
;;;647                the HAL_PCD_DataOutStageCallback could be implenetd in the user file
;;;648       */ 
;;;649    }
;;;650    
                          ENDP


                          AREA ||i.PCD_WriteEmptyTxFifo||, CODE, READONLY, ALIGN=1

                  PCD_WriteEmptyTxFifo PROC
;;;1152     */
;;;1153   static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1154   {
000004  460f              MOV      r7,r1
;;;1155     USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
;;;1156     USB_OTG_EPTypeDef *ep;
;;;1157     int32_t len = 0;
;;;1158     uint32_t len32b;
;;;1159     uint32_t fifoemptymsk = 0;
;;;1160   
;;;1161     ep = &hpcd->IN_ep[epnum];
000006  ebc101c7          RSB      r1,r1,r7,LSL #3
00000a  eb000581          ADD      r5,r0,r1,LSL #2
00000e  4682              MOV      r10,r0                ;1154
000010  6806              LDR      r6,[r0,#0]
000012  e9d50111          LDRD     r0,r1,[r5,#0x44]
;;;1162     len = ep->xfer_len - ep->xfer_count;
000016  1a44              SUBS     r4,r0,r1
;;;1163     
;;;1164     if (len > ep->maxpacket)
000018  6ba8              LDR      r0,[r5,#0x38]
00001a  3530              ADDS     r5,r5,#0x30
00001c  42a0              CMP      r0,r4
00001e  d200              BCS      |L35.34|
;;;1165     {
;;;1166       len = ep->maxpacket;
000020  4604              MOV      r4,r0
                  |L35.34|
;;;1167     }
;;;1168     
;;;1169     len32b = (len + 3) / 4;
000022  1ce0              ADDS     r0,r4,#3
000024  17c1              ASRS     r1,r0,#31
000026  eb007091          ADD      r0,r0,r1,LSR #30
00002a  ea4f08a0          ASR      r8,r0,#2
;;;1170    
;;;1171     while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
00002e  eb061947          ADD      r9,r6,r7,LSL #5
000032  e019              B        |L35.104|
                  |L35.52|
;;;1172             ep->xfer_count < ep->xfer_len &&
;;;1173               ep->xfer_len != 0)
;;;1174     {
;;;1175       /* Write the FIFO */
;;;1176       len = ep->xfer_len - ep->xfer_count;
000034  1a44              SUBS     r4,r0,r1
;;;1177       
;;;1178       if (len > ep->maxpacket)
000036  68a8              LDR      r0,[r5,#8]
000038  42a0              CMP      r0,r4
00003a  d200              BCS      |L35.62|
;;;1179       {
;;;1180         len = ep->maxpacket;
00003c  4604              MOV      r4,r0
                  |L35.62|
;;;1181       }
;;;1182       len32b = (len + 3) / 4;
00003e  1ce0              ADDS     r0,r4,#3
000040  17c1              ASRS     r1,r0,#31
000042  eb007091          ADD      r0,r0,r1,LSR #30
000046  ea4f08a0          ASR      r8,r0,#2
;;;1183       
;;;1184       USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
00004a  f89a0010          LDRB     r0,[r10,#0x10]
00004e  9000              STR      r0,[sp,#0]
000050  b2a3              UXTH     r3,r4
000052  b2fa              UXTB     r2,r7
000054  4630              MOV      r0,r6
000056  68e9              LDR      r1,[r5,#0xc]
000058  f7fffffe          BL       USB_WritePacket
;;;1185       
;;;1186       ep->xfer_buff  += len;
00005c  68e8              LDR      r0,[r5,#0xc]
00005e  4420              ADD      r0,r0,r4
;;;1187       ep->xfer_count += len;
000060  60e8              STR      r0,[r5,#0xc]
000062  69a8              LDR      r0,[r5,#0x18]
000064  4420              ADD      r0,r0,r4
000066  61a8              STR      r0,[r5,#0x18]
                  |L35.104|
000068  f8d90918          LDR      r0,[r9,#0x918]        ;1171
00006c  b281              UXTH     r1,r0                 ;1171
00006e  4541              CMP      r1,r8                 ;1171
000070  d905              BLS      |L35.126|
000072  e9d50105          LDRD     r0,r1,[r5,#0x14]      ;1171
000076  4281              CMP      r1,r0                 ;1172
000078  d201              BCS      |L35.126|
00007a  2800              CMP      r0,#0                 ;1173
00007c  d1da              BNE      |L35.52|
                  |L35.126|
;;;1188     }
;;;1189     
;;;1190     if(len <= 0)
00007e  2c00              CMP      r4,#0
000080  dc06              BGT      |L35.144|
;;;1191     {
;;;1192       fifoemptymsk = 0x1 << epnum;
000082  2001              MOVS     r0,#1
;;;1193       USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;   
000084  f8d61834          LDR      r1,[r6,#0x834]
000088  40b8              LSLS     r0,r0,r7              ;1192
00008a  4381              BICS     r1,r1,r0
00008c  f8c61834          STR      r1,[r6,#0x834]
                  |L35.144|
;;;1194     }
;;;1195     
;;;1196     return HAL_OK;  
000090  2000              MOVS     r0,#0
;;;1197   }
000092  e8bd8ff8          POP      {r3-r11,pc}
;;;1198   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_pcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_pcd_c_3a5cb0d3____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_pcd_c_3a5cb0d3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_pcd_c_3a5cb0d3____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_pcd_c_3a5cb0d3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
