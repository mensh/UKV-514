; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_rcc.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_rcc.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_rcc.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CCSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CCSCallback PROC
;;;1178     */
;;;1179   __weak void HAL_RCC_CCSCallback(void)
000000  4770              BX       lr
;;;1180   {
;;;1181     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1182               the HAL_RCC_CCSCallback could be implemented in the user file
;;;1183      */ 
;;;1184   }
;;;1185   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;592      */
;;;593    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;594    {
;;;595    
;;;596      uint32_t timeout = 0;   
;;;597     
;;;598      /* Check the parameters */
;;;599      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;600      assert_param(IS_FLASH_LATENCY(FLatency));
;;;601     
;;;602      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;603        must be correctly programmed according to the frequency of the CPU clock 
;;;604        (HCLK) and the supply voltage of the device. */
;;;605      
;;;606      /* Increasing the CPU frequency */
;;;607      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  f8df91b8          LDR      r9,|L2.448|
000008  4605              MOV      r5,r0                 ;594
00000a  460e              MOV      r6,r1                 ;594
00000c  f8d90000          LDR      r0,[r9,#0]
;;;608      {    
;;;609        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;610        __HAL_FLASH_SET_LATENCY(FLatency);
;;;611        
;;;612        /* Check that the new number of wait states is taken into account to access the Flash
;;;613        memory by reading the FLASH_ACR register */
;;;614        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;615        {
;;;616          return HAL_ERROR;
;;;617        }
;;;618    
;;;619        /*-------------------------- HCLK Configuration --------------------------*/
;;;620        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
;;;621        {
;;;622          assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;623          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
000010  4c6c              LDR      r4,|L2.452|
000012  f0000107          AND      r1,r0,#7              ;607
;;;624        }
;;;625    
;;;626        /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;627        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
;;;628        {    
;;;629          assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;630          
;;;631          /* HSE is selected as System Clock Source */
;;;632          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
;;;633          {
;;;634            /* Check the HSE ready flag */  
;;;635            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000016  486b              LDR      r0,|L2.452|
000018  3408              ADDS     r4,r4,#8              ;623
00001a  f00608ff          AND      r8,r6,#0xff           ;610
;;;636            {
;;;637              return HAL_ERROR;
;;;638            }
;;;639          }
;;;640          /* PLL is selected as System Clock Source */
;;;641          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;642          {
;;;643            /* Check the PLL ready flag */  
;;;644            if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;645            {
;;;646              return HAL_ERROR;
;;;647            }
;;;648          }
;;;649          /* HSI is selected as System Clock Source */
;;;650          else
;;;651          {
;;;652            /* Check the HSI ready flag */  
;;;653            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;654            {
;;;655              return HAL_ERROR;
;;;656            }
;;;657          }
;;;658          MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
;;;659     
;;;660          /* Get timeout */
;;;661          timeout = HAL_GetTick() + CLOCKSWITCH_TIMEOUT_VALUE;
00001e  f2413788          MOV      r7,#0x1388
000022  42b1              CMP      r1,r6                 ;607
000024  d24d              BCS      |L2.194|
000026  f8898000          STRB     r8,[r9,#0]            ;610
00002a  f8d91000          LDR      r1,[r9,#0]            ;614
00002e  f0010107          AND      r1,r1,#7              ;614
000032  42b1              CMP      r1,r6                 ;614
000034  d178              BNE      |L2.296|
000036  7829              LDRB     r1,[r5,#0]            ;620
000038  0789              LSLS     r1,r1,#30             ;620
00003a  d505              BPL      |L2.72|
00003c  6821              LDR      r1,[r4,#0]            ;623
00003e  68aa              LDR      r2,[r5,#8]            ;623
000040  f02101f0          BIC      r1,r1,#0xf0           ;623
000044  4311              ORRS     r1,r1,r2              ;623
000046  6021              STR      r1,[r4,#0]            ;623
                  |L2.72|
000048  7829              LDRB     r1,[r5,#0]            ;627
00004a  07c9              LSLS     r1,r1,#31             ;627
00004c  d025              BEQ      |L2.154|
00004e  6869              LDR      r1,[r5,#4]            ;632
000050  2901              CMP      r1,#1                 ;632
000052  d013              BEQ      |L2.124|
000054  6800              LDR      r0,[r0,#0]            ;653
000056  2902              CMP      r1,#2                 ;641
000058  d013              BEQ      |L2.130|
00005a  0780              LSLS     r0,r0,#30             ;653
                  |L2.92|
00005c  2800              CMP      r0,#0                 ;653
00005e  da63              BGE      |L2.296|
000060  6820              LDR      r0,[r4,#0]            ;658
000062  f0200003          BIC      r0,r0,#3              ;658
000066  4308              ORRS     r0,r0,r1              ;658
000068  6020              STR      r0,[r4,#0]            ;658
00006a  f7fffffe          BL       HAL_GetTick
00006e  19c6              ADDS     r6,r0,r7
;;;662          
;;;663          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000070  6868              LDR      r0,[r5,#4]
000072  2801              CMP      r0,#1
000074  d00c              BEQ      |L2.144|
;;;664          {
;;;665            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
;;;666            {
;;;667              if(HAL_GetTick() >= timeout)
;;;668              {
;;;669                return HAL_TIMEOUT;
;;;670              } 
;;;671            }
;;;672          }
;;;673          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000076  2802              CMP      r0,#2
000078  d014              BEQ      |L2.164|
00007a  e01d              B        |L2.184|
                  |L2.124|
00007c  6800              LDR      r0,[r0,#0]            ;635
00007e  0380              LSLS     r0,r0,#14             ;635
000080  e7ec              B        |L2.92|
                  |L2.130|
000082  0180              LSLS     r0,r0,#6              ;644
000084  e7ea              B        |L2.92|
000086  bf00              NOP                            ;667
                  |L2.136|
000088  f7fffffe          BL       HAL_GetTick
00008c  42b0              CMP      r0,r6                 ;667
00008e  d25b              BCS      |L2.328|
                  |L2.144|
000090  6820              LDR      r0,[r4,#0]            ;665
000092  f3c00081          UBFX     r0,r0,#2,#2           ;665
000096  2801              CMP      r0,#1                 ;665
000098  d1f6              BNE      |L2.136|
                  |L2.154|
00009a  e066              B        |L2.362|
                  |L2.156|
;;;674          {
;;;675            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
;;;676            {
;;;677              if(HAL_GetTick() >= timeout)
00009c  f7fffffe          BL       HAL_GetTick
0000a0  42b0              CMP      r0,r6
0000a2  d251              BCS      |L2.328|
                  |L2.164|
0000a4  6820              LDR      r0,[r4,#0]            ;675
0000a6  f3c00081          UBFX     r0,r0,#2,#2           ;675
0000aa  2802              CMP      r0,#2                 ;675
0000ac  d1f6              BNE      |L2.156|
0000ae  e05c              B        |L2.362|
                  |L2.176|
;;;678              {
;;;679                return HAL_TIMEOUT;
;;;680              } 
;;;681            }
;;;682          }
;;;683          else
;;;684          {
;;;685            while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
;;;686            {
;;;687              if(HAL_GetTick() >= timeout)
0000b0  f7fffffe          BL       HAL_GetTick
0000b4  42b0              CMP      r0,r6
0000b6  d247              BCS      |L2.328|
                  |L2.184|
0000b8  6820              LDR      r0,[r4,#0]            ;685
0000ba  f0100f0c          TST      r0,#0xc               ;685
0000be  d1f7              BNE      |L2.176|
0000c0  e053              B        |L2.362|
                  |L2.194|
;;;688              {
;;;689                return HAL_TIMEOUT;
;;;690              }
;;;691            }
;;;692          }
;;;693        }    
;;;694      }
;;;695      /* Decreasing the CPU frequency */
;;;696      else
;;;697      {
;;;698        /*-------------------------- HCLK Configuration --------------------------*/
;;;699        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
0000c2  7829              LDRB     r1,[r5,#0]
0000c4  0789              LSLS     r1,r1,#30
0000c6  d505              BPL      |L2.212|
;;;700        {
;;;701          assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;702          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
0000c8  6821              LDR      r1,[r4,#0]
0000ca  68aa              LDR      r2,[r5,#8]
0000cc  f02101f0          BIC      r1,r1,#0xf0
0000d0  4311              ORRS     r1,r1,r2
0000d2  6021              STR      r1,[r4,#0]
                  |L2.212|
;;;703        }
;;;704    
;;;705        /*------------------------- SYSCLK Configuration -------------------------*/
;;;706        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
0000d4  7829              LDRB     r1,[r5,#0]
0000d6  07c9              LSLS     r1,r1,#31
0000d8  d03d              BEQ      |L2.342|
;;;707        {    
;;;708          assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;709          
;;;710          /* HSE is selected as System Clock Source */
;;;711          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
0000da  6869              LDR      r1,[r5,#4]
0000dc  2901              CMP      r1,#1
0000de  d013              BEQ      |L2.264|
;;;712          {
;;;713            /* Check the HSE ready flag */  
;;;714            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;715            {
;;;716              return HAL_ERROR;
;;;717            }
;;;718          }
;;;719          /* PLL is selected as System Clock Source */
;;;720          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;721          {
;;;722            /* Check the PLL ready flag */  
;;;723            if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;724            {
;;;725              return HAL_ERROR;
;;;726            }
;;;727          }
;;;728          /* HSI is selected as System Clock Source */
;;;729          else
;;;730          {
;;;731            /* Check the HSI ready flag */  
;;;732            if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
0000e0  6800              LDR      r0,[r0,#0]
0000e2  2902              CMP      r1,#2                 ;720
0000e4  d013              BEQ      |L2.270|
0000e6  0780              LSLS     r0,r0,#30
                  |L2.232|
0000e8  2800              CMP      r0,#0
0000ea  da3c              BGE      |L2.358|
;;;733            {
;;;734              return HAL_ERROR;
;;;735            }
;;;736          }
;;;737          MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
0000ec  6820              LDR      r0,[r4,#0]
0000ee  f0200003          BIC      r0,r0,#3
0000f2  4308              ORRS     r0,r0,r1
0000f4  6020              STR      r0,[r4,#0]
;;;738          
;;;739          /* Get timeout */
;;;740          timeout = HAL_GetTick() + CLOCKSWITCH_TIMEOUT_VALUE;
0000f6  f7fffffe          BL       HAL_GetTick
0000fa  4407              ADD      r7,r7,r0
;;;741          
;;;742          if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
0000fc  6868              LDR      r0,[r5,#4]
0000fe  2801              CMP      r0,#1
000100  d00c              BEQ      |L2.284|
;;;743          {
;;;744            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
;;;745            {
;;;746              if(HAL_GetTick() >= timeout)
;;;747              {
;;;748                return HAL_TIMEOUT;
;;;749              } 
;;;750            }
;;;751          }
;;;752          else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000102  2802              CMP      r0,#2
000104  d016              BEQ      |L2.308|
000106  e022              B        |L2.334|
                  |L2.264|
000108  6800              LDR      r0,[r0,#0]            ;714
00010a  0380              LSLS     r0,r0,#14             ;714
00010c  e7ec              B        |L2.232|
                  |L2.270|
00010e  0180              LSLS     r0,r0,#6              ;723
000110  e7ea              B        |L2.232|
000112  bf00              NOP                            ;746
                  |L2.276|
000114  f7fffffe          BL       HAL_GetTick
000118  42b8              CMP      r0,r7                 ;746
00011a  d215              BCS      |L2.328|
                  |L2.284|
00011c  6820              LDR      r0,[r4,#0]            ;744
00011e  f3c00081          UBFX     r0,r0,#2,#2           ;744
000122  2801              CMP      r0,#1                 ;744
000124  d1f6              BNE      |L2.276|
000126  e016              B        |L2.342|
                  |L2.296|
000128  e01d              B        |L2.358|
;;;753          {
;;;754            while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
;;;755            {
;;;756              if(HAL_GetTick() >= timeout)
00012a  bf00              NOP      
                  |L2.300|
00012c  f7fffffe          BL       HAL_GetTick
000130  42b8              CMP      r0,r7
000132  d209              BCS      |L2.328|
                  |L2.308|
000134  6820              LDR      r0,[r4,#0]            ;754
000136  f3c00081          UBFX     r0,r0,#2,#2           ;754
00013a  2802              CMP      r0,#2                 ;754
00013c  d1f6              BNE      |L2.300|
00013e  e00a              B        |L2.342|
                  |L2.320|
;;;757              {
;;;758                return HAL_TIMEOUT;
;;;759              } 
;;;760            }
;;;761          }
;;;762          else
;;;763          {
;;;764            while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
;;;765            {
;;;766              if(HAL_GetTick() >= timeout)
000140  f7fffffe          BL       HAL_GetTick
000144  42b8              CMP      r0,r7
000146  d302              BCC      |L2.334|
                  |L2.328|
;;;767              {
;;;768                return HAL_TIMEOUT;
000148  2003              MOVS     r0,#3
                  |L2.330|
;;;769              }  
;;;770            }
;;;771          }
;;;772        }
;;;773        
;;;774        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;775        __HAL_FLASH_SET_LATENCY(FLatency);
;;;776        
;;;777        /* Check that the new number of wait states is taken into account to access the Flash
;;;778        memory by reading the FLASH_ACR register */
;;;779        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;780        {
;;;781          return HAL_ERROR;
;;;782        }
;;;783     }
;;;784    
;;;785      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;786      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;787      {
;;;788        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;789        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;790      }
;;;791      
;;;792      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;793      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;794      {
;;;795        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;796        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;797      }
;;;798    
;;;799      /* Setup SysTick Timer for 1 msec interrupts.
;;;800         ------------------------------------------
;;;801        The SysTick_Config() function is a CMSIS function which configure:
;;;802           - The SysTick Reload register with value passed as function parameter.
;;;803           - Configure the SysTick IRQ priority to the lowest value (0x0F).
;;;804           - Reset the SysTick Counter register.
;;;805           - Configure the SysTick Counter clock source to be Core Clock Source (HCLK).
;;;806           - Enable the SysTick Interrupt.
;;;807           - Start the SysTick Counter.*/
;;;808      SysTick_Config(HAL_RCC_GetHCLKFreq() / 1000);
;;;809      
;;;810      return HAL_OK;
;;;811    }
00014a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.334|
00014e  6820              LDR      r0,[r4,#0]            ;764
000150  f0100f0c          TST      r0,#0xc               ;764
000154  d1f4              BNE      |L2.320|
                  |L2.342|
000156  f8898000          STRB     r8,[r9,#0]            ;775
00015a  f8d90000          LDR      r0,[r9,#0]            ;779
00015e  f0000007          AND      r0,r0,#7              ;779
000162  42b0              CMP      r0,r6                 ;779
000164  d001              BEQ      |L2.362|
                  |L2.358|
000166  2001              MOVS     r0,#1                 ;781
000168  e7ef              B        |L2.330|
                  |L2.362|
00016a  7828              LDRB     r0,[r5,#0]            ;786
00016c  0740              LSLS     r0,r0,#29             ;786
00016e  d505              BPL      |L2.380|
000170  6820              LDR      r0,[r4,#0]            ;789
000172  68e9              LDR      r1,[r5,#0xc]          ;789
000174  f42050e0          BIC      r0,r0,#0x1c00         ;789
000178  4308              ORRS     r0,r0,r1              ;789
00017a  6020              STR      r0,[r4,#0]            ;789
                  |L2.380|
00017c  7828              LDRB     r0,[r5,#0]            ;793
00017e  0700              LSLS     r0,r0,#28             ;793
000180  d506              BPL      |L2.400|
000182  6820              LDR      r0,[r4,#0]            ;796
000184  6929              LDR      r1,[r5,#0x10]         ;796
000186  f4204060          BIC      r0,r0,#0xe000         ;796
00018a  ea4000c1          ORR      r0,r0,r1,LSL #3       ;796
00018e  6020              STR      r0,[r4,#0]            ;796
                  |L2.400|
000190  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000194  f44f717a          MOV      r1,#0x3e8             ;808
000198  fbb0f0f1          UDIV     r0,r0,r1              ;808
00019c  1e40              SUBS     r0,r0,#1              ;808
00019e  f1b07f80          CMP      r0,#0x1000000         ;808
0001a2  d20a              BCS      |L2.442|
0001a4  f04f21e0          MOV      r1,#0xe000e000        ;808
0001a8  6148              STR      r0,[r1,#0x14]         ;808
0001aa  4a07              LDR      r2,|L2.456|
0001ac  20f0              MOVS     r0,#0xf0              ;808
0001ae  f8820d14          STRB     r0,[r2,#0xd14]        ;808
0001b2  2000              MOVS     r0,#0                 ;808
0001b4  6188              STR      r0,[r1,#0x18]         ;808
0001b6  2007              MOVS     r0,#7                 ;808
0001b8  6108              STR      r0,[r1,#0x10]         ;808
                  |L2.442|
0001ba  2000              MOVS     r0,#0                 ;810
0001bc  e7c5              B        |L2.330|
;;;812    
                          ENDP

0001be  0000              DCW      0x0000
                  |L2.448|
                          DCD      0x40023c00
                  |L2.452|
                          DCD      0x40023800
                  |L2.456|
                          DCD      0xe000e00f

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;216      */
;;;217    void HAL_RCC_DeInit(void)
000000  4811              LDR      r0,|L3.72|
;;;218    {
000002  b510              PUSH     {r4,lr}
;;;219      /* Set HSION bit */
;;;220      SET_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSITRIM_4); 
000004  6801              LDR      r1,[r0,#0]
000006  f0410181          ORR      r1,r1,#0x81
00000a  6001              STR      r1,[r0,#0]
;;;221      
;;;222      /* Reset CFGR register */
;;;223      CLEAR_REG(RCC->CFGR);
00000c  4a0e              LDR      r2,|L3.72|
00000e  2100              MOVS     r1,#0
000010  3208              ADDS     r2,r2,#8
000012  6011              STR      r1,[r2,#0]
;;;224      
;;;225      /* Reset HSEON, CSSON, PLLON, PLLI2S */
;;;226      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON| RCC_CR_PLLI2SON); 
000014  6802              LDR      r2,[r0,#0]
000016  4b0d              LDR      r3,|L3.76|
000018  401a              ANDS     r2,r2,r3
00001a  6002              STR      r2,[r0,#0]
;;;227      
;;;228      /* Reset PLLCFGR register */
;;;229      CLEAR_REG(RCC->PLLCFGR);
00001c  1d02              ADDS     r2,r0,#4
00001e  6011              STR      r1,[r2,#0]
;;;230      SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2); 
000020  6813              LDR      r3,[r2,#0]
000022  4c0b              LDR      r4,|L3.80|
000024  4323              ORRS     r3,r3,r4
000026  6013              STR      r3,[r2,#0]
;;;231      
;;;232      /* Reset PLLI2SCFGR register */
;;;233      CLEAR_REG(RCC->PLLI2SCFGR);
000028  4a07              LDR      r2,|L3.72|
00002a  3284              ADDS     r2,r2,#0x84
00002c  6011              STR      r1,[r2,#0]
;;;234      SET_BIT(RCC->PLLI2SCFGR,  RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1);
00002e  6813              LDR      r3,[r2,#0]
000030  4c08              LDR      r4,|L3.84|
000032  4323              ORRS     r3,r3,r4
000034  6013              STR      r3,[r2,#0]
;;;235      
;;;236      /* Reset HSEBYP bit */
;;;237      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
000036  6802              LDR      r2,[r0,#0]
000038  f4222280          BIC      r2,r2,#0x40000
00003c  6002              STR      r2,[r0,#0]
;;;238      
;;;239      /* Disable all interrupts */
;;;240      CLEAR_REG(RCC->CIR); 
00003e  4802              LDR      r0,|L3.72|
000040  300c              ADDS     r0,r0,#0xc
000042  6001              STR      r1,[r0,#0]
;;;241    }
000044  bd10              POP      {r4,pc}
;;;242    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x40023800
                  |L3.76|
                          DCD      0xfaf6ffff
                  |L3.80|
                          DCD      0x04003010
                  |L3.84|
                          DCD      0x20003000

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;922      */
;;;923    void HAL_RCC_DisableCSS(void)
000000  4901              LDR      r1,|L4.8|
;;;924    {
;;;925      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)DISABLE;
000002  2000              MOVS     r0,#0
000004  64c8              STR      r0,[r1,#0x4c]
;;;926    }
000006  4770              BX       lr
;;;927    
                          ENDP

                  |L4.8|
                          DCD      0x42470000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;912      */
;;;913    void HAL_RCC_EnableCSS(void)
000000  4901              LDR      r1,|L5.8|
;;;914    {
;;;915      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)ENABLE;
000002  2001              MOVS     r0,#1
000004  64c8              STR      r0,[r1,#0x4c]
;;;916    }
000006  4770              BX       lr
;;;917    
                          ENDP

                  |L5.8|
                          DCD      0x42470000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1133     */
;;;1134   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1135   {
;;;1136     /* Set all possible values for the Clock type parameter --------------------*/
;;;1137     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1138      
;;;1139     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1140     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6813              LDR      r3,[r2,#0]
000008  f0030303          AND      r3,r3,#3
;;;1141     
;;;1142     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1143     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6813              LDR      r3,[r2,#0]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1144     
;;;1145     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1146     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6813              LDR      r3,[r2,#0]
000018  f40353e0          AND      r3,r3,#0x1c00
;;;1147     
;;;1148     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1149     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6812              LDR      r2,[r2,#0]
;;;1150     
;;;1151     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1152     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1153   }
000020  f44f53e0          MOV      r3,#0x1c00
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1152
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1152
00002e  f0000007          AND      r0,r0,#7              ;1152
000032  6008              STR      r0,[r1,#0]            ;1152
000034  4770              BX       lr
;;;1154   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40023808
                  |L6.60|
                          DCD      0x40023c00

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1015     */
;;;1016   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  b500              PUSH     {lr}
;;;1017   {
;;;1018     SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
000002  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000006  4908              LDR      r1,|L7.40|
000008  6809              LDR      r1,[r1,#0]
00000a  22f0              MOVS     r2,#0xf0
00000c  fa92f2a2          RBIT     r2,r2
000010  f00101f0          AND      r1,r1,#0xf0
000014  fab2f282          CLZ      r2,r2
000018  40d1              LSRS     r1,r1,r2
00001a  4a04              LDR      r2,|L7.44|
00001c  5c51              LDRB     r1,[r2,r1]
00001e  40c8              LSRS     r0,r0,r1
000020  4903              LDR      r1,|L7.48|
000022  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;1019     return SystemCoreClock;
;;;1020   }
000024  bd00              POP      {pc}
;;;1021   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40023808
                  |L7.44|
                          DCD      ||.constdata||
                  |L7.48|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1054     */
;;;1055   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1056   {
;;;1057     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1058     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1059     
;;;1060     /* Get the HSE configuration -----------------------------------------------*/
;;;1061     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000002  4b36              LDR      r3,|L8.220|
000004  210f              MOVS     r1,#0xf               ;1058
000006  6001              STR      r1,[r0,#0]
000008  6819              LDR      r1,[r3,#0]
;;;1062     {
;;;1063       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
00000a  f04f0405          MOV      r4,#5
00000e  034d              LSLS     r5,r1,#13             ;1061
000010  f04f0200          MOV      r2,#0
;;;1064     }
;;;1065     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
;;;1066     {
;;;1067       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
000014  f04f0101          MOV      r1,#1
000018  d501              BPL      |L8.30|
00001a  6044              STR      r4,[r0,#4]            ;1063
00001c  e005              B        |L8.42|
                  |L8.30|
00001e  681d              LDR      r5,[r3,#0]            ;1065
000020  03ed              LSLS     r5,r5,#15             ;1065
000022  d501              BPL      |L8.40|
000024  6041              STR      r1,[r0,#4]
000026  e000              B        |L8.42|
                  |L8.40|
;;;1068     }
;;;1069     else
;;;1070     {
;;;1071       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000028  6042              STR      r2,[r0,#4]
                  |L8.42|
;;;1072     }
;;;1073     
;;;1074     /* Get the HSI configuration -----------------------------------------------*/
;;;1075     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
00002a  681d              LDR      r5,[r3,#0]
00002c  07ed              LSLS     r5,r5,#31
00002e  d001              BEQ      |L8.52|
;;;1076     {
;;;1077       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000030  60c1              STR      r1,[r0,#0xc]
000032  e000              B        |L8.54|
                  |L8.52|
;;;1078     }
;;;1079     else
;;;1080     {
;;;1081       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000034  60c2              STR      r2,[r0,#0xc]
                  |L8.54|
;;;1082     }
;;;1083     
;;;1084     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
000036  681d              LDR      r5,[r3,#0]
000038  26f8              MOVS     r6,#0xf8
00003a  fa96f6a6          RBIT     r6,r6
00003e  f00505f8          AND      r5,r5,#0xf8
000042  fab6f686          CLZ      r6,r6
000046  40f5              LSRS     r5,r5,r6
;;;1085     
;;;1086     /* Get the LSE configuration -----------------------------------------------*/
;;;1087     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000048  6105              STR      r5,[r0,#0x10]
00004a  4d24              LDR      r5,|L8.220|
00004c  3570              ADDS     r5,r5,#0x70
00004e  682e              LDR      r6,[r5,#0]
000050  0776              LSLS     r6,r6,#29
000052  d501              BPL      |L8.88|
;;;1088     {
;;;1089       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000054  6084              STR      r4,[r0,#8]
000056  e005              B        |L8.100|
                  |L8.88|
;;;1090     }
;;;1091     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
000058  682c              LDR      r4,[r5,#0]
00005a  07e4              LSLS     r4,r4,#31
00005c  d001              BEQ      |L8.98|
;;;1092     {
;;;1093       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
00005e  6081              STR      r1,[r0,#8]
000060  e000              B        |L8.100|
                  |L8.98|
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
000062  6082              STR      r2,[r0,#8]
                  |L8.100|
;;;1098     }
;;;1099     
;;;1100     /* Get the LSI configuration -----------------------------------------------*/
;;;1101     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000064  4c1d              LDR      r4,|L8.220|
000066  3474              ADDS     r4,r4,#0x74
000068  6824              LDR      r4,[r4,#0]
00006a  07e4              LSLS     r4,r4,#31
00006c  d001              BEQ      |L8.114|
;;;1102     {
;;;1103       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
00006e  6141              STR      r1,[r0,#0x14]
000070  e000              B        |L8.116|
                  |L8.114|
;;;1104     }
;;;1105     else
;;;1106     {
;;;1107       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000072  6142              STR      r2,[r0,#0x14]
                  |L8.116|
;;;1108     }
;;;1109     
;;;1110     /* Get the PLL configuration -----------------------------------------------*/
;;;1111     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000074  681a              LDR      r2,[r3,#0]
000076  01d2              LSLS     r2,r2,#7
000078  d500              BPL      |L8.124|
;;;1112     {
;;;1113       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00007a  2102              MOVS     r1,#2
                  |L8.124|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
;;;1118     }
;;;1119     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
00007c  6181              STR      r1,[r0,#0x18]
00007e  4917              LDR      r1,|L8.220|
000080  1d09              ADDS     r1,r1,#4
000082  680a              LDR      r2,[r1,#0]
000084  f4020280          AND      r2,r2,#0x400000
;;;1120     RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
000088  61c2              STR      r2,[r0,#0x1c]
00008a  680a              LDR      r2,[r1,#0]
00008c  f002023f          AND      r2,r2,#0x3f
;;;1121     RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
000090  6202              STR      r2,[r0,#0x20]
000092  680a              LDR      r2,[r1,#0]
000094  f64773c0          MOV      r3,#0x7fc0
000098  401a              ANDS     r2,r2,r3
00009a  fa93f3a3          RBIT     r3,r3
00009e  fab3f383          CLZ      r3,r3
0000a2  40da              LSRS     r2,r2,r3
;;;1122     RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> POSITION_VAL(RCC_PLLCFGR_PLLP));
0000a4  6242              STR      r2,[r0,#0x24]
0000a6  680a              LDR      r2,[r1,#0]
0000a8  f44f3340          MOV      r3,#0x30000
0000ac  f4023240          AND      r2,r2,#0x30000
0000b0  f5023280          ADD      r2,r2,#0x10000
0000b4  fa93f3a3          RBIT     r3,r3
0000b8  0052              LSLS     r2,r2,#1
0000ba  fab3f383          CLZ      r3,r3
0000be  40da              LSRS     r2,r2,r3
;;;1123     RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> POSITION_VAL(RCC_PLLCFGR_PLLQ));
0000c0  6282              STR      r2,[r0,#0x28]
0000c2  6809              LDR      r1,[r1,#0]
0000c4  f04f6270          MOV      r2,#0xf000000
0000c8  fa92f2a2          RBIT     r2,r2
0000cc  f0016170          AND      r1,r1,#0xf000000
0000d0  fab2f282          CLZ      r2,r2
0000d4  40d1              LSRS     r1,r1,r2
0000d6  62c1              STR      r1,[r0,#0x2c]
;;;1124   }
0000d8  bd70              POP      {r4-r6,pc}
;;;1125   
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1028     */
;;;1029   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  b500              PUSH     {lr}
;;;1030   {  
;;;1031     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1032     return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4907              LDR      r1,|L9.36|
000008  6809              LDR      r1,[r1,#0]
00000a  f44f52e0          MOV      r2,#0x1c00
00000e  fa92f2a2          RBIT     r2,r2
000012  f40151e0          AND      r1,r1,#0x1c00
000016  fab2f282          CLZ      r2,r2
00001a  40d1              LSRS     r1,r1,r2
00001c  4a02              LDR      r2,|L9.40|
00001e  5c51              LDRB     r1,[r2,r1]
000020  40c8              LSRS     r0,r0,r1
;;;1033   }
000022  bd00              POP      {pc}
;;;1034   
                          ENDP

                  |L9.36|
                          DCD      0x40023808
                  |L9.40|
                          DCD      ||.constdata||

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1041     */
;;;1042   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  b500              PUSH     {lr}
;;;1043   {
;;;1044     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1045     return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
000002  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000006  4907              LDR      r1,|L10.36|
000008  6809              LDR      r1,[r1,#0]
00000a  f44f4260          MOV      r2,#0xe000
00000e  fa92f2a2          RBIT     r2,r2
000012  f4014160          AND      r1,r1,#0xe000
000016  fab2f282          CLZ      r2,r2
00001a  40d1              LSRS     r1,r1,r2
00001c  4a02              LDR      r2,|L10.40|
00001e  5c51              LDRB     r1,[r2,r1]
000020  40c8              LSRS     r0,r0,r1
;;;1046   } 
000022  bd00              POP      {pc}
;;;1047   
                          ENDP

                  |L10.36|
                          DCD      0x40023808
                  |L10.40|
                          DCD      ||.constdata||

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;958      */
;;;959    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  b530              PUSH     {r4,r5,lr}
;;;960    {
;;;961      uint32_t pllm = 0, pllvco = 0, pllp = 0;
;;;962      uint32_t sysclockfreq = 0;
;;;963    
;;;964      /* Get SYSCLK source -------------------------------------------------------*/
;;;965      switch (RCC->CFGR & RCC_CFGR_SWS)
000002  481d              LDR      r0,|L11.120|
000004  6800              LDR      r0,[r0,#0]
000006  f010010c          ANDS     r1,r0,#0xc
;;;966      {
;;;967        case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
;;;968        {
;;;969          sysclockfreq = HSI_VALUE;
00000a  481c              LDR      r0,|L11.124|
00000c  d01a              BEQ      |L11.68|
;;;970           break;
;;;971        }
;;;972        case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
;;;973        {
;;;974          sysclockfreq = HSE_VALUE;
00000e  1044              ASRS     r4,r0,#1
000010  2904              CMP      r1,#4                 ;965
000012  d016              BEQ      |L11.66|
000014  2908              CMP      r1,#8                 ;965
000016  d115              BNE      |L11.68|
;;;975          break;
;;;976        }
;;;977        case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
;;;978        {
;;;979          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;980          SYSCLK = PLL_VCO / PLLP */
;;;981          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000018  4917              LDR      r1,|L11.120|
00001a  1f09              SUBS     r1,r1,#4
00001c  680a              LDR      r2,[r1,#0]
00001e  f002033f          AND      r3,r2,#0x3f
;;;982          if (__RCC_PLLSRC() != 0)
000022  680a              LDR      r2,[r1,#0]
000024  f4020580          AND      r5,r2,#0x400000
000028  f44f0280          MOV      r2,#0x400000
00002c  fa92f2a2          RBIT     r2,r2
000030  fab2f282          CLZ      r2,r2
000034  40d5              LSRS     r5,r5,r2
;;;983          {
;;;984            /* HSE used as PLL clock source */
;;;985            pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
000036  f64772c0          MOV      r2,#0x7fc0
00003a  d004              BEQ      |L11.70|
00003c  fbb4f0f3          UDIV     r0,r4,r3
000040  e003              B        |L11.74|
                  |L11.66|
000042  4620              MOV      r0,r4                 ;974
                  |L11.68|
;;;986          }
;;;987          else
;;;988          {
;;;989            /* HSI used as PLL clock source */
;;;990            pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
;;;991          }
;;;992          pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
;;;993          
;;;994          sysclockfreq = pllvco/pllp;
;;;995          break;
;;;996        }
;;;997        default:
;;;998        {
;;;999          sysclockfreq = HSI_VALUE;
;;;1000         break;
;;;1001       }
;;;1002     }
;;;1003     return sysclockfreq;
;;;1004   }
000044  bd30              POP      {r4,r5,pc}
                  |L11.70|
000046  fbb0f0f3          UDIV     r0,r0,r3              ;990
                  |L11.74|
00004a  680b              LDR      r3,[r1,#0]            ;990
00004c  6809              LDR      r1,[r1,#0]            ;992
00004e  4013              ANDS     r3,r3,r2              ;990
000050  fa92f2a2          RBIT     r2,r2                 ;990
000054  fab2f282          CLZ      r2,r2                 ;990
000058  40d3              LSRS     r3,r3,r2              ;990
00005a  4358              MULS     r0,r3,r0              ;990
00005c  f44f3240          MOV      r2,#0x30000           ;992
000060  fa92f2a2          RBIT     r2,r2                 ;992
000064  f4013140          AND      r1,r1,#0x30000        ;992
000068  fab2f282          CLZ      r2,r2                 ;992
00006c  40d1              LSRS     r1,r1,r2              ;992
00006e  1c49              ADDS     r1,r1,#1              ;992
000070  0049              LSLS     r1,r1,#1              ;992
000072  fbb0f0f1          UDIV     r0,r0,r1              ;994
000076  bd30              POP      {r4,r5,pc}
;;;1005   
                          ENDP

                  |L11.120|
                          DCD      0x40023808
                  |L11.124|
                          DCD      0x00f42400

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;857      */
;;;858    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;859    {
000002  460d              MOV      r5,r1
;;;860      GPIO_InitTypeDef GPIO_InitStruct;
;;;861      /* Check the parameters */
;;;862      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;863      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;864      /* RCC_MCO1 */
;;;865      if(RCC_MCOx == RCC_MCO1)
;;;866      {
;;;867        assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;868        
;;;869        /* MCO1 Clock Enable */
;;;870        __MCO1_CLK_ENABLE();
;;;871        
;;;872        /* Configue the MCO1 pin in alternate function mode */    
;;;873        GPIO_InitStruct.Pin = MCO1_PIN;
;;;874        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;875        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;876        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;877        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;878        HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
;;;879        
;;;880        /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
;;;881        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
000004  4c18              LDR      r4,|L12.104|
000006  4616              MOV      r6,r2                 ;859
000008  4917              LDR      r1,|L12.104|
00000a  2300              MOVS     r3,#0                 ;859
00000c  2202              MOVS     r2,#2                 ;874
00000e  2703              MOVS     r7,#3                 ;875
000010  3c28              SUBS     r4,r4,#0x28
000012  2800              CMP      r0,#0                 ;865
;;;882      }
;;;883      else
;;;884      {
;;;885        assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
;;;886        
;;;887        /* MCO2 Clock Enable */
;;;888        __MCO2_CLK_ENABLE();
000014  6808              LDR      r0,[r1,#0]
000016  b085              SUB      sp,sp,#0x14           ;859
000018  d013              BEQ      |L12.66|
00001a  f0400004          ORR      r0,r0,#4
00001e  6008              STR      r0,[r1,#0]
;;;889        
;;;890        /* Configue the MCO2 pin in alternate function mode */
;;;891        GPIO_InitStruct.Pin = MCO2_PIN;
000020  1548              ASRS     r0,r1,#21
000022  e88d008d          STM      sp,{r0,r2,r3,r7}
;;;892        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;893        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;894        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;895        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;896        HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
000026  4669              MOV      r1,sp
000028  4810              LDR      r0,|L12.108|
00002a  9304              STR      r3,[sp,#0x10]
00002c  f7fffffe          BL       HAL_GPIO_Init
;;;897        
;;;898        /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
;;;899        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
000030  6820              LDR      r0,[r4,#0]
000032  ea4501c6          ORR      r1,r5,r6,LSL #3
000036  f0204078          BIC      r0,r0,#0xf8000000
00003a  4308              ORRS     r0,r0,r1
                  |L12.60|
00003c  6020              STR      r0,[r4,#0]            ;881
;;;900      }
;;;901    }
00003e  b005              ADD      sp,sp,#0x14
000040  bdf0              POP      {r4-r7,pc}
                  |L12.66|
000042  f0400001          ORR      r0,r0,#1              ;870
000046  6008              STR      r0,[r1,#0]            ;870
000048  f44f7080          MOV      r0,#0x100             ;873
00004c  e88d008d          STM      sp,{r0,r2,r3,r7}      ;873
000050  4669              MOV      r1,sp                 ;878
000052  4807              LDR      r0,|L12.112|
000054  9304              STR      r3,[sp,#0x10]         ;878
000056  f7fffffe          BL       HAL_GPIO_Init
00005a  6820              LDR      r0,[r4,#0]            ;881
00005c  4335              ORRS     r5,r5,r6              ;881
00005e  f02060ec          BIC      r0,r0,#0x7600000      ;881
000062  4328              ORRS     r0,r0,r5              ;881
000064  e7ea              B        |L12.60|
;;;902    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
                          DCD      0x40023830
                  |L12.108|
                          DCD      0x40020800
                  |L12.112|
                          DCD      0x40020000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1160     */
;;;1161   void HAL_RCC_NMI_IRQHandler(void)
000000  4805              LDR      r0,|L13.24|
;;;1162   {
000002  b510              PUSH     {r4,lr}
;;;1163     /* Check RCC CSSF flag  */
;;;1164     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000004  6800              LDR      r0,[r0,#0]
000006  0600              LSLS     r0,r0,#24
000008  d505              BPL      |L13.22|
;;;1165     {
;;;1166       /* RCC Clock Security System interrupt user callback */
;;;1167       HAL_RCC_CCSCallback();
00000a  f7fffffe          BL       HAL_RCC_CCSCallback
;;;1168   
;;;1169       /* Clear RCC CSS pending bit */
;;;1170       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  4902              LDR      r1,|L13.24|
000010  2080              MOVS     r0,#0x80
000012  1c89              ADDS     r1,r1,#2
000014  7008              STRB     r0,[r1,#0]
                  |L13.22|
;;;1171     }
;;;1172   }
000016  bd10              POP      {r4,pc}
;;;1173   
                          ENDP

                  |L13.24|
                          DCD      0x4002380c

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;250      */
;;;251    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;252    {
000004  4604              MOV      r4,r0
;;;253    
;;;254      uint32_t timeout = 0;   
;;;255     
;;;256      /* Check the parameters */
;;;257      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;258      /*------------------------------- HSE Configuration ------------------------*/ 
;;;259      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;260      {
;;;261        /* Check the parameters */
;;;262        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;263        /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
;;;264        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
000008  f8df92fc          LDR      r9,|L14.776|
;;;265        {
;;;266          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState != RCC_HSE_ON))
00000c  4dbf              LDR      r5,|L14.780|
00000e  07c0              LSLS     r0,r0,#31             ;259
000010  f04f0600          MOV      r6,#0                 ;264
000014  d049              BEQ      |L14.170|
000016  f8d91000          LDR      r1,[r9,#0]            ;264
00001a  4648              MOV      r0,r9                 ;264
00001c  f3c10181          UBFX     r1,r1,#2,#2           ;264
000020  2901              CMP      r1,#1                 ;264
000022  d008              BEQ      |L14.54|
000024  6800              LDR      r0,[r0,#0]            ;264
000026  f3c00081          UBFX     r0,r0,#2,#2           ;264
00002a  2802              CMP      r0,#2                 ;264
00002c  d10a              BNE      |L14.68|
00002e  1d28              ADDS     r0,r5,#4              ;264
000030  6800              LDR      r0,[r0,#0]            ;264
000032  0240              LSLS     r0,r0,#9              ;264
000034  d506              BPL      |L14.68|
                  |L14.54|
000036  6828              LDR      r0,[r5,#0]
000038  0380              LSLS     r0,r0,#14
00003a  d536              BPL      |L14.170|
00003c  6860              LDR      r0,[r4,#4]
00003e  2801              CMP      r0,#1
                  |L14.64|
000040  d174              BNE      |L14.300|
000042  e032              B        |L14.170|
                  |L14.68|
;;;267          {
;;;268            return HAL_ERROR;
;;;269          }
;;;270        }
;;;271        else
;;;272        {
;;;273          /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
;;;274          __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
000044  f8dfa2c4          LDR      r10,|L14.780|
000048  f10a0a02          ADD      r10,r10,#2
00004c  f88a6000          STRB     r6,[r10,#0]
;;;275          
;;;276          /* Get timeout */
;;;277          timeout = HAL_GetTick() + HSE_TIMEOUT_VALUE;
000050  f7fffffe          BL       HAL_GetTick
000054  f2413788          MOV      r7,#0x1388
000058  eb000807          ADD      r8,r0,r7
;;;278          
;;;279          /* Wait till HSE is disabled */  
;;;280          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
00005c  e004              B        |L14.104|
;;;281          {
;;;282            if(HAL_GetTick() >= timeout)
00005e  bf00              NOP      
                  |L14.96|
000060  f7fffffe          BL       HAL_GetTick
000064  4540              CMP      r0,r8
                  |L14.102|
000066  d27b              BCS      |L14.352|
                  |L14.104|
000068  6828              LDR      r0,[r5,#0]            ;280
00006a  0380              LSLS     r0,r0,#14             ;280
00006c  d4f8              BMI      |L14.96|
;;;283            {
;;;284              return HAL_TIMEOUT;
;;;285            }      
;;;286          }
;;;287          
;;;288          /* Set the new HSE configuration ---------------------------------------*/
;;;289          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
00006e  7920              LDRB     r0,[r4,#4]
000070  f88a0000          STRB     r0,[r10,#0]
;;;290          
;;;291          /* Check the HSE State */
;;;292          if((RCC_OscInitStruct->HSEState) == RCC_HSE_ON)
000074  6860              LDR      r0,[r4,#4]
000076  2801              CMP      r0,#1
000078  d003              BEQ      |L14.130|
;;;293          {
;;;294            /* Get timeout */
;;;295            timeout = HAL_GetTick() + HSE_TIMEOUT_VALUE;
;;;296          
;;;297            /* Wait till HSE is ready */  
;;;298            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;299            {
;;;300              if(HAL_GetTick() >= timeout)
;;;301              {
;;;302                return HAL_TIMEOUT;
;;;303              }
;;;304            }
;;;305          }
;;;306          else
;;;307          {
;;;308            /* Get timeout */
;;;309            timeout = HAL_GetTick() + HSE_TIMEOUT_VALUE;
00007a  f7fffffe          BL       HAL_GetTick
00007e  4407              ADD      r7,r7,r0
;;;310    
;;;311            /* Wait till HSE is bypassed or disabled */
;;;312            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
000080  e010              B        |L14.164|
                  |L14.130|
000082  f7fffffe          BL       HAL_GetTick
000086  4407              ADD      r7,r7,r0              ;295
000088  e004              B        |L14.148|
00008a  bf00              NOP                            ;300
                  |L14.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  42b8              CMP      r0,r7                 ;300
000092  d2e8              BCS      |L14.102|
                  |L14.148|
000094  6828              LDR      r0,[r5,#0]            ;298
000096  0380              LSLS     r0,r0,#14             ;298
000098  d5f8              BPL      |L14.140|
00009a  e006              B        |L14.170|
                  |L14.156|
;;;313            {
;;;314              if(HAL_GetTick() >= timeout)
00009c  f7fffffe          BL       HAL_GetTick
0000a0  42b8              CMP      r0,r7
0000a2  d2e0              BCS      |L14.102|
                  |L14.164|
0000a4  6828              LDR      r0,[r5,#0]            ;312
0000a6  0380              LSLS     r0,r0,#14             ;312
0000a8  d4f8              BMI      |L14.156|
                  |L14.170|
;;;315              {
;;;316                return HAL_TIMEOUT;
;;;317              }
;;;318            }
;;;319          }
;;;320        }
;;;321      }
;;;322      /*----------------------------- HSI Configuration --------------------------*/
;;;323      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000aa  7820              LDRB     r0,[r4,#0]
;;;324      {
;;;325        /* Check the parameters */
;;;326        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;327        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;328        
;;;329        /* When the HSI is used as system clock it will not disabled */
;;;330        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
;;;331        {
;;;332          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;333          {
;;;334            return HAL_ERROR;
;;;335          }
;;;336        }
;;;337        else
;;;338        {
;;;339          /* Check the HSI State */
;;;340          if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
;;;341          {
;;;342            /* Enable the Internal High Speed oscillator (HSI). */
;;;343            __HAL_RCC_HSI_ENABLE();
0000ac  4f98              LDR      r7,|L14.784|
0000ae  0780              LSLS     r0,r0,#30             ;323
0000b0  f04f0b01          MOV      r11,#1                ;266
0000b4  d543              BPL      |L14.318|
0000b6  f8d91000          LDR      r1,[r9,#0]            ;330
0000ba  4648              MOV      r0,r9                 ;330
0000bc  f0110f0c          TST      r1,#0xc               ;330
0000c0  d009              BEQ      |L14.214|
0000c2  6800              LDR      r0,[r0,#0]            ;330
0000c4  f3c00081          UBFX     r0,r0,#2,#2           ;330
0000c8  2802              CMP      r0,#2                 ;330
0000ca  d10b              BNE      |L14.228|
0000cc  488e              LDR      r0,|L14.776|
0000ce  1f00              SUBS     r0,r0,#4              ;330
0000d0  6800              LDR      r0,[r0,#0]            ;330
0000d2  0240              LSLS     r0,r0,#9              ;330
0000d4  d406              BMI      |L14.228|
                  |L14.214|
0000d6  6828              LDR      r0,[r5,#0]            ;332
0000d8  0780              LSLS     r0,r0,#30             ;332
0000da  d530              BPL      |L14.318|
0000dc  68e0              LDR      r0,[r4,#0xc]          ;332
0000de  2801              CMP      r0,#1                 ;332
0000e0  d1ae              BNE      |L14.64|
0000e2  e02c              B        |L14.318|
                  |L14.228|
0000e4  68e0              LDR      r0,[r4,#0xc]          ;340
0000e6  b1d8              CBZ      r0,|L14.288|
0000e8  f8c7b000          STR      r11,[r7,#0]
;;;344    
;;;345            /* Get timeout */
;;;346            timeout = HAL_GetTick() + HSI_TIMEOUT_VALUE;
0000ec  f7fffffe          BL       HAL_GetTick
0000f0  f1000864          ADD      r8,r0,#0x64
;;;347    
;;;348            /* Wait till HSI is ready */  
;;;349            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
0000f4  e004              B        |L14.256|
;;;350            {
;;;351              if(HAL_GetTick() >= timeout)
0000f6  bf00              NOP      
                  |L14.248|
0000f8  f7fffffe          BL       HAL_GetTick
0000fc  4540              CMP      r0,r8
0000fe  d2b2              BCS      |L14.102|
                  |L14.256|
000100  6828              LDR      r0,[r5,#0]            ;349
000102  0780              LSLS     r0,r0,#30             ;349
000104  d5f8              BPL      |L14.248|
;;;352              {
;;;353                return HAL_TIMEOUT;
;;;354              }      
;;;355            } 
;;;356                    
;;;357            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;358            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
000106  6828              LDR      r0,[r5,#0]
000108  22f8              MOVS     r2,#0xf8
00010a  fa92f2a2          RBIT     r2,r2
00010e  6921              LDR      r1,[r4,#0x10]
000110  fab2f282          CLZ      r2,r2
000114  f02000f8          BIC      r0,r0,#0xf8
000118  4091              LSLS     r1,r1,r2
00011a  4308              ORRS     r0,r0,r1
00011c  6028              STR      r0,[r5,#0]
00011e  e00e              B        |L14.318|
                  |L14.288|
;;;359          }
;;;360          else
;;;361          {
;;;362            /* Disable the Internal High Speed oscillator (HSI). */
;;;363            __HAL_RCC_HSI_DISABLE();
000120  603e              STR      r6,[r7,#0]
;;;364    
;;;365            /* Get timeout */
;;;366            timeout = HAL_GetTick() + HSI_TIMEOUT_VALUE;
000122  f7fffffe          BL       HAL_GetTick
000126  f1000864          ADD      r8,r0,#0x64
;;;367          
;;;368            /* Wait till HSI is ready */  
;;;369            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
00012a  e005              B        |L14.312|
                  |L14.300|
00012c  e0ea              B        |L14.772|
;;;370            {
;;;371              if(HAL_GetTick() >= timeout)
00012e  bf00              NOP      
                  |L14.304|
000130  f7fffffe          BL       HAL_GetTick
000134  4540              CMP      r0,r8
000136  d213              BCS      |L14.352|
                  |L14.312|
000138  6828              LDR      r0,[r5,#0]            ;369
00013a  0780              LSLS     r0,r0,#30             ;369
00013c  d4f8              BMI      |L14.304|
                  |L14.318|
;;;372              {
;;;373                return HAL_TIMEOUT;
;;;374              }
;;;375            } 
;;;376          }
;;;377        }
;;;378      }
;;;379      /*------------------------------ LSI Configuration -------------------------*/
;;;380      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
00013e  7820              LDRB     r0,[r4,#0]
000140  0700              LSLS     r0,r0,#28
000142  d527              BPL      |L14.404|
;;;381      {
;;;382        /* Check the parameters */
;;;383        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;384    
;;;385        /* Check the LSI State */
;;;386        if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
;;;387        {
;;;388          /* Enable the Internal Low Speed oscillator (LSI). */
;;;389          __HAL_RCC_LSI_ENABLE();
;;;390    
;;;391          /* Get timeout */
;;;392          timeout = HAL_GetTick() + LSI_TIMEOUT_VALUE;
;;;393    
;;;394          /* Wait till LSI is ready */
;;;395          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
000144  f8dfa1c0          LDR      r10,|L14.776|
000148  4872              LDR      r0,|L14.788|
00014a  6961              LDR      r1,[r4,#0x14]         ;386
00014c  f10a0a6c          ADD      r10,r10,#0x6c
000150  b189              CBZ      r1,|L14.374|
000152  f8c0b000          STR      r11,[r0,#0]           ;389
000156  f7fffffe          BL       HAL_GetTick
00015a  f1000864          ADD      r8,r0,#0x64           ;392
00015e  e005              B        |L14.364|
                  |L14.352|
000160  e07e              B        |L14.608|
;;;396          {
;;;397            if(HAL_GetTick() >= timeout)
000162  bf00              NOP      
                  |L14.356|
000164  f7fffffe          BL       HAL_GetTick
000168  4540              CMP      r0,r8
00016a  d279              BCS      |L14.608|
                  |L14.364|
00016c  f8da0000          LDR      r0,[r10,#0]           ;395
000170  0780              LSLS     r0,r0,#30             ;395
000172  d5f7              BPL      |L14.356|
000174  e00e              B        |L14.404|
                  |L14.374|
;;;398            {
;;;399              return HAL_TIMEOUT;
;;;400            }
;;;401          }
;;;402        }
;;;403        else
;;;404        {
;;;405          /* Disable the Internal Low Speed oscillator (LSI). */
;;;406          __HAL_RCC_LSI_DISABLE();
000176  6006              STR      r6,[r0,#0]
;;;407    
;;;408          /* Get timeout */
;;;409          timeout = HAL_GetTick() + LSI_TIMEOUT_VALUE;
000178  f7fffffe          BL       HAL_GetTick
00017c  f1000864          ADD      r8,r0,#0x64
;;;410          
;;;411          /* Wait till LSI is ready */  
;;;412          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
000180  e004              B        |L14.396|
;;;413          {
;;;414            if(HAL_GetTick() >= timeout)
000182  bf00              NOP      
                  |L14.388|
000184  f7fffffe          BL       HAL_GetTick
000188  4540              CMP      r0,r8
00018a  d269              BCS      |L14.608|
                  |L14.396|
00018c  f8da0000          LDR      r0,[r10,#0]           ;412
000190  0780              LSLS     r0,r0,#30             ;412
000192  d4f7              BMI      |L14.388|
                  |L14.404|
;;;415            {
;;;416              return HAL_TIMEOUT;
;;;417            }      
;;;418          } 
;;;419        }
;;;420      }
;;;421      /*------------------------------ LSE Configuration -------------------------*/ 
;;;422      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
000194  7820              LDRB     r0,[r4,#0]
000196  0740              LSLS     r0,r0,#29
000198  d552              BPL      |L14.576|
;;;423      {
;;;424        /* Check the parameters */
;;;425        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;426        
;;;427        /* Enable Power Clock*/
;;;428        __PWR_CLK_ENABLE();
00019a  485b              LDR      r0,|L14.776|
00019c  3038              ADDS     r0,r0,#0x38
00019e  6801              LDR      r1,[r0,#0]
0001a0  f0415180          ORR      r1,r1,#0x10000000
0001a4  6001              STR      r1,[r0,#0]
;;;429        
;;;430        /* Enable write access to Backup domain */
;;;431        PWR->CR |= PWR_CR_DBP;
0001a6  f8dfa170          LDR      r10,|L14.792|
0001aa  f8da1000          LDR      r1,[r10,#0]
0001ae  f4417180          ORR      r1,r1,#0x100
0001b2  f8ca1000          STR      r1,[r10,#0]
;;;432        
;;;433        /* Wait for Backup domain Write protection disable */
;;;434        timeout = HAL_GetTick() + DBP_TIMEOUT_VALUE;
0001b6  f7fffffe          BL       HAL_GetTick
0001ba  f1000864          ADD      r8,r0,#0x64
;;;435        
;;;436        while((PWR->CR & PWR_CR_DBP) == RESET)
0001be  e003              B        |L14.456|
                  |L14.448|
;;;437        {
;;;438          if(HAL_GetTick() >= timeout)
0001c0  f7fffffe          BL       HAL_GetTick
0001c4  4540              CMP      r0,r8
0001c6  d24b              BCS      |L14.608|
                  |L14.456|
0001c8  f8da0000          LDR      r0,[r10,#0]           ;436
0001cc  05c0              LSLS     r0,r0,#23             ;436
0001ce  d5f7              BPL      |L14.448|
;;;439          {
;;;440            return HAL_TIMEOUT;
;;;441          }      
;;;442        }
;;;443        /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
;;;444        __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
0001d0  f8df8134          LDR      r8,|L14.776|
0001d4  f1080868          ADD      r8,r8,#0x68
0001d8  f8886000          STRB     r6,[r8,#0]
;;;445        
;;;446        /* Get timeout */
;;;447        timeout = HAL_GetTick() + LSE_TIMEOUT_VALUE;
0001dc  f7fffffe          BL       HAL_GetTick
0001e0  f2413a88          MOV      r10,#0x1388
0001e4  4450              ADD      r0,r0,r10
;;;448          
;;;449        /* Wait till LSE is ready */  
;;;450        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0001e6  9000              STR      r0,[sp,#0]
0001e8  e005              B        |L14.502|
;;;451        {
;;;452          if(HAL_GetTick() >= timeout)
0001ea  bf00              NOP      
                  |L14.492|
0001ec  f7fffffe          BL       HAL_GetTick
0001f0  9900              LDR      r1,[sp,#0]
0001f2  4288              CMP      r0,r1
0001f4  d27e              BCS      |L14.756|
                  |L14.502|
0001f6  f8d80000          LDR      r0,[r8,#0]            ;450
0001fa  0780              LSLS     r0,r0,#30             ;450
0001fc  d4f6              BMI      |L14.492|
;;;453          {
;;;454            return HAL_TIMEOUT;
;;;455          }      
;;;456        } 
;;;457        
;;;458        /* Set the new LSE configuration -----------------------------------------*/
;;;459        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
0001fe  7a20              LDRB     r0,[r4,#8]
000200  f8880000          STRB     r0,[r8,#0]
;;;460        /* Check the LSE State */
;;;461        if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
000204  68a0              LDR      r0,[r4,#8]
000206  2801              CMP      r0,#1
000208  d003              BEQ      |L14.530|
;;;462        {
;;;463          /* Get timeout */
;;;464          timeout = HAL_GetTick() + LSE_TIMEOUT_VALUE;
;;;465          
;;;466          /* Wait till LSE is ready */  
;;;467          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;468          {
;;;469            if(HAL_GetTick() >= timeout)
;;;470            {
;;;471              return HAL_TIMEOUT;
;;;472            }      
;;;473          }
;;;474        }
;;;475        else
;;;476        {
;;;477          /* Get timeout */
;;;478          timeout = HAL_GetTick() + LSE_TIMEOUT_VALUE;
00020a  f7fffffe          BL       HAL_GetTick
00020e  4482              ADD      r10,r10,r0
;;;479          
;;;480          /* Wait till LSE is ready */  
;;;481          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
000210  e012              B        |L14.568|
                  |L14.530|
000212  f7fffffe          BL       HAL_GetTick
000216  4482              ADD      r10,r10,r0            ;464
000218  e004              B        |L14.548|
00021a  bf00              NOP                            ;469
                  |L14.540|
00021c  f7fffffe          BL       HAL_GetTick
000220  4550              CMP      r0,r10                ;469
000222  d267              BCS      |L14.756|
                  |L14.548|
000224  f8d80000          LDR      r0,[r8,#0]            ;467
000228  0780              LSLS     r0,r0,#30             ;467
00022a  d5f7              BPL      |L14.540|
00022c  e008              B        |L14.576|
;;;482          {
;;;483            if(HAL_GetTick() >= timeout)
00022e  bf00              NOP      
                  |L14.560|
000230  f7fffffe          BL       HAL_GetTick
000234  4550              CMP      r0,r10
000236  d25d              BCS      |L14.756|
                  |L14.568|
000238  f8d80000          LDR      r0,[r8,#0]            ;481
00023c  0780              LSLS     r0,r0,#30             ;481
00023e  d4f7              BMI      |L14.560|
                  |L14.576|
;;;484            {
;;;485              return HAL_TIMEOUT;
;;;486            }      
;;;487          }
;;;488        }
;;;489      }
;;;490      /*-------------------------------- PLL Configuration -----------------------*/
;;;491      /* Check the parameters */
;;;492      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;493      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
000240  69a0              LDR      r0,[r4,#0x18]
000242  b3e8              CBZ      r0,|L14.704|
;;;494      {
;;;495        /* Check if the PLL is used as system clock or not */
;;;496        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000244  f8d91000          LDR      r1,[r9,#0]
000248  f3c10181          UBFX     r1,r1,#2,#2
00024c  2902              CMP      r1,#2
00024e  d059              BEQ      |L14.772|
;;;497        { 
;;;498          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
000250  2802              CMP      r0,#2
;;;499          {
;;;500            /* Check the parameters */
;;;501            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;502            assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;503            assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;504            assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;505            assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;506            
;;;507            /* Disable the main PLL. */
;;;508            __HAL_RCC_PLL_DISABLE();
;;;509    
;;;510            /* Get timeout */
;;;511            timeout = HAL_GetTick() + PLL_TIMEOUT_VALUE;
;;;512          
;;;513            /* Wait till PLL is ready */  
;;;514            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;515            {
;;;516              if(HAL_GetTick() >= timeout)
;;;517              {
;;;518                return HAL_TIMEOUT;
;;;519              }      
;;;520            }        
;;;521    
;;;522            /* Configure the main PLL clock source, multiplication and division factors. */
;;;523            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;524                                 RCC_OscInitStruct->PLL.PLLM,
;;;525                                 RCC_OscInitStruct->PLL.PLLN,
;;;526                                 RCC_OscInitStruct->PLL.PLLP,
;;;527                                 RCC_OscInitStruct->PLL.PLLQ);
;;;528            /* Enable the main PLL. */
;;;529            __HAL_RCC_PLL_ENABLE();
;;;530    
;;;531            /* Get timeout */
;;;532            timeout = HAL_GetTick() + PLL_TIMEOUT_VALUE;
;;;533          
;;;534            /* Wait till PLL is ready */  
;;;535            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;536            {
;;;537              if(HAL_GetTick() >= timeout)
;;;538              {
;;;539                return HAL_TIMEOUT;
;;;540              }      
;;;541            }
;;;542          }
;;;543          else
;;;544          {
;;;545            /* Disable the main PLL. */
;;;546            __HAL_RCC_PLL_DISABLE();
000252  663e              STR      r6,[r7,#0x60]
000254  d005              BEQ      |L14.610|
;;;547            /* Get timeout */
;;;548            timeout = HAL_GetTick() + PLL_TIMEOUT_VALUE;
000256  f7fffffe          BL       HAL_GetTick
00025a  f1000464          ADD      r4,r0,#0x64
;;;549          
;;;550            /* Wait till PLL is ready */  
;;;551            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
00025e  e04c              B        |L14.762|
                  |L14.608|
000260  e048              B        |L14.756|
                  |L14.610|
000262  f7fffffe          BL       HAL_GetTick
000266  f1000664          ADD      r6,r0,#0x64           ;511
00026a  e003              B        |L14.628|
                  |L14.620|
00026c  f7fffffe          BL       HAL_GetTick
000270  42b0              CMP      r0,r6                 ;516
000272  d23f              BCS      |L14.756|
                  |L14.628|
000274  6828              LDR      r0,[r5,#0]            ;514
000276  0180              LSLS     r0,r0,#6              ;514
000278  d4f8              BMI      |L14.620|
00027a  e9d41007          LDRD     r1,r0,[r4,#0x1c]      ;514
00027e  4308              ORRS     r0,r0,r1              ;523
000280  f64772c0          MOV      r2,#0x7fc0            ;523
000284  fa92f2a2          RBIT     r2,r2                 ;523
000288  6a61              LDR      r1,[r4,#0x24]         ;523
00028a  fab2f282          CLZ      r2,r2                 ;523
00028e  4091              LSLS     r1,r1,r2              ;523
000290  6aa2              LDR      r2,[r4,#0x28]         ;523
000292  f04f33ff          MOV      r3,#0xffffffff        ;523
000296  eb030252          ADD      r2,r3,r2,LSR #1       ;523
00029a  f44f3340          MOV      r3,#0x30000           ;523
00029e  fa93f3a3          RBIT     r3,r3                 ;523
0002a2  fab3f383          CLZ      r3,r3                 ;523
0002a6  409a              LSLS     r2,r2,r3              ;523
0002a8  4311              ORRS     r1,r1,r2              ;523
0002aa  4308              ORRS     r0,r0,r1              ;523
0002ac  f04f6270          MOV      r2,#0xf000000         ;523
0002b0  fa92f2a2          RBIT     r2,r2                 ;523
0002b4  6ae1              LDR      r1,[r4,#0x2c]         ;523
0002b6  fab2f282          CLZ      r2,r2                 ;523
0002ba  4091              LSLS     r1,r1,r2              ;523
0002bc  4308              ORRS     r0,r0,r1              ;523
0002be  e000              B        |L14.706|
                  |L14.704|
0002c0  e01e              B        |L14.768|
                  |L14.706|
0002c2  f0405100          ORR      r1,r0,#0x20000000     ;523
0002c6  4810              LDR      r0,|L14.776|
0002c8  1f00              SUBS     r0,r0,#4              ;523
0002ca  6001              STR      r1,[r0,#0]            ;523
0002cc  f8c7b060          STR      r11,[r7,#0x60]        ;529
0002d0  f7fffffe          BL       HAL_GetTick
0002d4  f1000464          ADD      r4,r0,#0x64           ;532
0002d8  e004              B        |L14.740|
0002da  bf00              NOP                            ;537
                  |L14.732|
0002dc  f7fffffe          BL       HAL_GetTick
0002e0  42a0              CMP      r0,r4                 ;537
0002e2  d207              BCS      |L14.756|
                  |L14.740|
0002e4  6828              LDR      r0,[r5,#0]            ;535
0002e6  0180              LSLS     r0,r0,#6              ;535
0002e8  d5f8              BPL      |L14.732|
0002ea  e009              B        |L14.768|
                  |L14.748|
;;;552            {
;;;553              if(HAL_GetTick() >= timeout)
0002ec  f7fffffe          BL       HAL_GetTick
0002f0  42a0              CMP      r0,r4
0002f2  d302              BCC      |L14.762|
                  |L14.756|
;;;554              {
;;;555                return HAL_TIMEOUT;
0002f4  2003              MOVS     r0,#3
                  |L14.758|
;;;556              }      
;;;557            }
;;;558          }
;;;559        }
;;;560        else
;;;561        {
;;;562          return HAL_ERROR;
;;;563        }
;;;564      }
;;;565      return HAL_OK;
;;;566    }
0002f6  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.762|
0002fa  6828              LDR      r0,[r5,#0]            ;551
0002fc  0180              LSLS     r0,r0,#6              ;551
0002fe  d4f5              BMI      |L14.748|
                  |L14.768|
000300  2000              MOVS     r0,#0                 ;565
000302  e7f8              B        |L14.758|
                  |L14.772|
000304  2001              MOVS     r0,#1                 ;562
000306  e7f6              B        |L14.758|
;;;567     
                          ENDP

                  |L14.776|
                          DCD      0x40023808
                  |L14.780|
                          DCD      0x40023800
                  |L14.784|
                          DCD      0x42470000
                  |L14.788|
                          DCD      0x42470e80
                  |L14.792|
                          DCD      0x40007000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_rcc_c_c7d3f187____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_rcc_c_c7d3f187____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_rcc_c_c7d3f187____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_rcc_c_c7d3f187____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
