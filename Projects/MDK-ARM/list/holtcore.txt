; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\holtcore.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\holtcore.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\holtcore.crf" ..\..\Src\core\holtCore.c]
                          THUMB

                          AREA ||i.HOLT_CORE_ReedAvailableData||, CODE, READONLY, ALIGN=2

                  HOLT_CORE_ReedAvailableData PROC
;;;214    
;;;215    tdStatus HOLT_CORE_ReedAvailableData(tdSpiDevice *_pDevice, tdArinc *_pArinc, uint8_t *_pBuffer, uint32_t *_pCurrentSize, uint32_t _maxSize)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;216    	{
000004  4689              MOV      r9,r1
000006  4682              MOV      r10,r0
;;;217    	tdStatus status = Ok;
;;;218    	uint8_t flagsStatus;
;;;219    	uint8_t tryes;
;;;220    
;;;221    	if( !(*_pCurrentSize < _maxSize) )
000008  9f0c              LDR      r7,[sp,#0x30]
00000a  6819              LDR      r1,[r3,#0]
00000c  2001              MOVS     r0,#1                 ;217
00000e  461d              MOV      r5,r3                 ;216
000010  4690              MOV      r8,r2                 ;216
000012  42b9              CMP      r1,r7
000014  d302              BCC      |L1.28|
;;;222    		return ProcessBreak;
000016  2004              MOVS     r0,#4
                  |L1.24|
;;;223    
;;;224    	tryes = 0;
;;;225    	flagsStatus = HOLT_DRIVER_CHANNELS_READY;
;;;226    	while( flagsStatus != 0 && tryes++ < 4 )
;;;227    		{
;;;228    		status = HOLT_CORE_handleFifoEvents(_pDevice, _pArinc, flagsStatus, HOLT_DRIVER_HI3598_DATA_RECEIVER_FIFO_ONE_WORD, _pBuffer, _pCurrentSize, _maxSize);
;;;229    		flagsStatus = HOLT_DRIVER_CHANNELS_READY;
;;;230    		}
;;;231    
;;;232    	return status;
;;;233    	}
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.28|
00001c  2400              MOVS     r4,#0                 ;224
00001e  4e0a              LDR      r6,|L1.72|
000020  e008              B        |L1.52|
                  |L1.34|
000022  f8cd8000          STR      r8,[sp,#0]            ;228
000026  e9cd5701          STRD     r5,r7,[sp,#4]         ;228
00002a  2301              MOVS     r3,#1                 ;228
00002c  4649              MOV      r1,r9                 ;228
00002e  4650              MOV      r0,r10                ;228
000030  f7fffffe          BL       HOLT_CORE_handleFifoEvents
                  |L1.52|
000034  6831              LDR      r1,[r6,#0]            ;225
000036  f01102ff          ANDS     r2,r1,#0xff           ;225
00003a  d0ed              BEQ      |L1.24|
00003c  4621              MOV      r1,r4                 ;226
00003e  1c64              ADDS     r4,r4,#1              ;226
000040  b2e4              UXTB     r4,r4                 ;226
000042  2904              CMP      r1,#4                 ;226
000044  d3ed              BCC      |L1.34|
000046  e7e7              B        |L1.24|
;;;234    
                          ENDP

                  |L1.72|
                          DCD      0x40021410

                          AREA ||i.HOLT_CORE_configurateChannel||, CODE, READONLY, ALIGN=1

                  HOLT_CORE_configurateChannel PROC
;;;135    
;;;136    tdStatus HOLT_CORE_configurateChannel(tdSpiDevice *_pDevice, uint8_t _channel, uint16_t _configuration)
000000  b5f8              PUSH     {r3-r7,lr}
;;;137    	{
000002  4606              MOV      r6,r0
;;;138    	uint16_t readBackConfiguration = 0x0000;
000004  2000              MOVS     r0,#0
000006  4614              MOV      r4,r2                 ;137
000008  460d              MOV      r5,r1                 ;137
00000a  f8ad0000          STRH     r0,[sp,#0]
                  |L2.14|
;;;139    
;;;140    	while( HOLT_DRIVER_setConfiguration(_pDevice, _channel, _configuration) == Busy ); // Trying to set configuration until status not equal Busy (Ok - if success or TimeOut ). If Busy - try again;
00000e  4622              MOV      r2,r4
000010  4629              MOV      r1,r5
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       HOLT_DRIVER_setConfiguration
000018  2800              CMP      r0,#0
00001a  d0f8              BEQ      |L2.14|
                  |L2.28|
;;;141    
;;;142    	while( HOLT_DRIVER_readConfiguration(_pDevice, _channel, &readBackConfiguration) == Busy ); // Trying to read configuration until status not equal Busy (Ok - if success or TimeOut ). If Busy - try again;
00001c  466a              MOV      r2,sp
00001e  4629              MOV      r1,r5
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       HOLT_DRIVER_readConfiguration
000026  2800              CMP      r0,#0
000028  d0f8              BEQ      |L2.28|
;;;143    
;;;144    	if( _configuration != readBackConfiguration )
00002a  f8bd0000          LDRH     r0,[sp,#0]
00002e  4284              CMP      r4,r0
000030  d001              BEQ      |L2.54|
;;;145    		{
;;;146    		return Fail;
000032  2002              MOVS     r0,#2
;;;147    		}
;;;148    
;;;149    	return Ok;
;;;150    	}
000034  bdf8              POP      {r3-r7,pc}
                  |L2.54|
000036  2001              MOVS     r0,#1                 ;149
000038  bdf8              POP      {r3-r7,pc}
;;;151    
                          ENDP


                          AREA ||i.HOLT_CORE_generateReversedLabels||, CODE, READONLY, ALIGN=2

                  HOLT_CORE_generateReversedLabels PROC
;;;234    
;;;235    tdStatus HOLT_CORE_generateReversedLabels(tdArinc *_pArinc)
000000  b570              PUSH     {r4-r6,lr}
;;;236    	{
;;;237    	uint16_t lable;
;;;238    	uint32_t S, T;
;;;239    	for( lable = 0; lable < HOLT_CORE_LABELS_AMOUNT; lable++ )
;;;240    		{
;;;241    		S = (lable * 0x02020202) & 0x84422010;
000002  4c10              LDR      r4,|L3.68|
000004  2100              MOVS     r1,#0                 ;239
;;;242    		T = (lable * 8) & 0x00000420;
000006  f44f6584          MOV      r5,#0x420
;;;243    		_pArinc->reversedLabels[ (((S + T) % 1023) & (HOLT_CORE_LABELS_AMOUNT - 1)) ] = (uint8_t)lable;
00000a  f24036ff          MOV      r6,#0x3ff
00000e  bf00              NOP                            ;241
                  |L3.16|
000010  eb014201          ADD      r2,r1,r1,LSL #16      ;241
000014  eb022202          ADD      r2,r2,r2,LSL #8       ;241
000018  ea040342          AND      r3,r4,r2,LSL #1       ;241
00001c  ea0502c1          AND      r2,r5,r1,LSL #3       ;242
000020  441a              ADD      r2,r2,r3
000022  fbb2f3f6          UDIV     r3,r2,r6
000026  fb062213          MLS      r2,r6,r3,r2
00002a  b2d2              UXTB     r2,r2
00002c  4402              ADD      r2,r2,r0
00002e  f5025200          ADD      r2,r2,#0x2000
000032  f8821084          STRB     r1,[r2,#0x84]
000036  1c49              ADDS     r1,r1,#1
000038  b289              UXTH     r1,r1                 ;239
00003a  29ff              CMP      r1,#0xff              ;239
00003c  d9e8              BLS      |L3.16|
;;;244    		}
;;;245    
;;;246    	return Ok;
00003e  2001              MOVS     r0,#1
;;;247    	}
000040  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      0x84422010

                          AREA ||i.HOLT_CORE_handleFifoEvents||, CODE, READONLY, ALIGN=1

                  HOLT_CORE_handleFifoEvents PROC
;;;191    
;;;192    tdStatus HOLT_CORE_handleFifoEvents(tdSpiDevice *_pDevice, tdArinc *_pArinc, uint8_t _events, uint8_t _wordsToRead, uint8_t *_pBuffer, uint32_t *_pCurrentSize, uint32_t _maxSize)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;193    	{
000004  4683              MOV      r11,r0
000006  e9dd760d          LDRD     r7,r6,[sp,#0x34]
;;;194    	uint8_t channel;
;;;195    
;;;196    	if( !(*_pCurrentSize < _maxSize) )
00000a  f8dd8030          LDR      r8,[sp,#0x30]
00000e  6838              LDR      r0,[r7,#0]
000010  4699              MOV      r9,r3                 ;193
000012  4614              MOV      r4,r2                 ;193
000014  468a              MOV      r10,r1                ;193
000016  42b0              CMP      r0,r6
000018  d210              BCS      |L4.60|
;;;197    		return ProcessBreak;
;;;198    
;;;199    	channel = 1;
00001a  2501              MOVS     r5,#1
;;;200    	while( _events )
00001c  e014              B        |L4.72|
                  |L4.30|
;;;201    		{
;;;202    		if( _events & 0x01 )
00001e  07e0              LSLS     r0,r4,#31
000020  d00f              BEQ      |L4.66|
;;;203    			{
;;;204    			HOLT_CORE_readWordsFormChannel(_pDevice, _pArinc, channel, _wordsToRead, _pBuffer, _pCurrentSize, _maxSize);
000022  f8cd8000          STR      r8,[sp,#0]
000026  e9cd7601          STRD     r7,r6,[sp,#4]
00002a  464b              MOV      r3,r9
00002c  462a              MOV      r2,r5
00002e  4651              MOV      r1,r10
000030  4658              MOV      r0,r11
000032  f7fffffe          BL       HOLT_CORE_readWordsFormChannel
;;;205    
;;;206    			if( !(*_pCurrentSize < _maxSize) )
000036  6838              LDR      r0,[r7,#0]
000038  42b0              CMP      r0,r6
00003a  d302              BCC      |L4.66|
                  |L4.60|
;;;207    				return ProcessBreak;
00003c  2004              MOVS     r0,#4
                  |L4.62|
;;;208    			}
;;;209    		_events >>= 1;
;;;210    		channel++;
;;;211    		}
;;;212    	return Ok;
;;;213    	}
00003e  e8bd8ffe          POP      {r1-r11,pc}
                  |L4.66|
000042  0864              LSRS     r4,r4,#1              ;209
000044  1c6d              ADDS     r5,r5,#1              ;209
000046  b2ed              UXTB     r5,r5                 ;210
                  |L4.72|
000048  2c00              CMP      r4,#0                 ;200
00004a  d1e8              BNE      |L4.30|
00004c  2001              MOVS     r0,#1                 ;212
00004e  e7f6              B        |L4.62|
;;;214    
                          ENDP


                          AREA ||i.HOLT_CORE_handleSlotTD||, CODE, READONLY, ALIGN=2

                  HOLT_CORE_handleSlotTD PROC
;;;63     
;;;64     tdArincConfigurationStatus HOLT_CORE_handleSlotTD(tdArinc *_pArinc, uint8_t *_pData, uint8_t _slotsAmount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65     	{
;;;66     	tdArincChannel *pChannel;
;;;67     	uint8_t channelIndex;
;;;68     	uint8_t slot;
;;;69     	uint8_t freq;
;;;70     	tdArincConfigurationStatus status;
;;;71     
;;;72     	if( _slotsAmount > HOLT_CORE_CHANNELS_AMOUNT )
000004  2a08              CMP      r2,#8
000006  d902              BLS      |L5.14|
;;;73     		return configAmountError;
000008  2004              MOVS     r0,#4
                  |L5.10|
;;;74     
;;;75     	pChannel = &_pArinc->channel[ 0 ];
;;;76     	for( channelIndex = 0; channelIndex < HOLT_CORE_CHANNELS_AMOUNT; channelIndex++ )
;;;77     		{
;;;78     		pChannel->status.enable = 0;
;;;79     		pChannel->freq = frequency_notSet;
;;;80     		pChannel++;
;;;81     		}
;;;82     
;;;83     	status = configOk;
;;;84     	for( slot = 0; slot < _slotsAmount; slot++ )
;;;85     		{
;;;86     		channelIndex = *(_pData + HOLT_CORE_USB_SLOT_TD_ICHN_SHIFT);
;;;87     		freq = *(_pData + HOLT_CORE_USB_SLOT_TD_FREQ_SHIFT);
;;;88     
;;;89     		if( channelIndex > HOLT_CORE_CHANNELS_AMOUNT - 1 )
;;;90     			{
;;;91     			status = configIndexError;
;;;92     			break;
;;;93     			}
;;;94     
;;;95     		if( freq != frequency_100_kHz && freq != frequency_12_5_kHz )
;;;96     			{
;;;97     			status = configFreqError;
;;;98     			break;
;;;99     			}
;;;100    
;;;101    		pChannel = &_pArinc->channel[ channelIndex ];
;;;102    
;;;103    		if( pChannel->status.enable == 1 ) // we trying to configurate channel once more
;;;104    			{
;;;105    			status = configDuplicateChannels;
;;;106    			break;
;;;107    			}
;;;108    
;;;109    		pChannel->status.enable = 1;
;;;110    		pChannel->freq = (tdArincFreq)freq;
;;;111    
;;;112    		_pData += HOLT_CORE_USB_SLOT_TD_SIZE;
;;;113    		}
;;;114    
;;;115    	if( status == configOk /*|| status == configDuplicateChannels*/ )
;;;116    		{
;;;117    		_pArinc->enabledChannels = 0;
;;;118    		pChannel = &_pArinc->channel[ 0 ];
;;;119    		for( channelIndex = 0; channelIndex < HOLT_CORE_CHANNELS_AMOUNT; channelIndex++ )
;;;120    			{
;;;121    			if( pChannel->status.enable == 1 )
;;;122    				_pArinc->enabledChannels++;
;;;123    			pChannel++;
;;;124    			}
;;;125    
;;;126    		FILE_SYSTEM_saveHoltConfiguration(_pArinc);
;;;127    		}
;;;128    	else
;;;129    		{
;;;130    		FILE_SYSTEM_readHoltConfiguration(_pArinc);
;;;131    		}
;;;132    
;;;133    	return status;
;;;134    	}
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.14|
00000e  2400              MOVS     r4,#0                 ;76
000010  1d03              ADDS     r3,r0,#4              ;75
000012  4626              MOV      r6,r4                 ;76
000014  f05f0503          MOVS.W   r5,#3                 ;79
                  |L5.24|
000018  f8836408          STRB     r6,[r3,#0x408]        ;78
00001c  1c64              ADDS     r4,r4,#1              ;79
00001e  f883540c          STRB     r5,[r3,#0x40c]        ;79
000022  b2e4              UXTB     r4,r4                 ;76
000024  f5036382          ADD      r3,r3,#0x410          ;76
000028  2c08              CMP      r4,#8                 ;76
00002a  d3f5              BCC      |L5.24|
00002c  2400              MOVS     r4,#0                 ;83
00002e  4623              MOV      r3,r4                 ;84
000030  f04f0c01          MOV      r12,#1                ;91
000034  e01b              B        |L5.110|
                  |L5.54|
000036  780d              LDRB     r5,[r1,#0]            ;86
000038  784f              LDRB     r7,[r1,#1]            ;87
00003a  2d07              CMP      r5,#7                 ;89
00003c  d901              BLS      |L5.66|
00003e  2401              MOVS     r4,#1                 ;91
000040  e024              B        |L5.140|
                  |L5.66|
000042  b11f              CBZ      r7,|L5.76|
000044  2f02              CMP      r7,#2                 ;95
000046  d001              BEQ      |L5.76|
000048  2402              MOVS     r4,#2                 ;97
00004a  e01f              B        |L5.140|
                  |L5.76|
00004c  eb051585          ADD      r5,r5,r5,LSL #6       ;101
000050  eb001505          ADD      r5,r0,r5,LSL #4       ;101
000054  f895e40c          LDRB     lr,[r5,#0x40c]        ;103
000058  1d2d              ADDS     r5,r5,#4              ;103
00005a  f1be0f01          CMP      lr,#1                 ;103
00005e  d014              BEQ      |L5.138|
000060  1c5b              ADDS     r3,r3,#1              ;110
000062  f885c408          STRB     r12,[r5,#0x408]       ;109
000066  f885740c          STRB     r7,[r5,#0x40c]        ;110
00006a  b2db              UXTB     r3,r3                 ;84
00006c  1c89              ADDS     r1,r1,#2              ;84
                  |L5.110|
00006e  4293              CMP      r3,r2                 ;84
000070  d3e1              BCC      |L5.54|
000072  f5005300          ADD      r3,r0,#0x2000         ;117
000076  1d01              ADDS     r1,r0,#4              ;118
000078  f8836184          STRB     r6,[r3,#0x184]        ;117
00007c  f05f0200          MOVS.W   r2,#0                 ;119
                  |L5.128|
000080  f8915408          LDRB     r5,[r1,#0x408]        ;121
000084  2d01              CMP      r5,#1                 ;121
000086  d005              BEQ      |L5.148|
000088  e009              B        |L5.158|
                  |L5.138|
00008a  2405              MOVS     r4,#5                 ;105
                  |L5.140|
00008c  f7fffffe          BL       FILE_SYSTEM_readHoltConfiguration
                  |L5.144|
000090  4620              MOV      r0,r4                 ;133
000092  e7ba              B        |L5.10|
                  |L5.148|
000094  f8935184          LDRB     r5,[r3,#0x184]        ;122
000098  1c6d              ADDS     r5,r5,#1              ;122
00009a  f8835184          STRB     r5,[r3,#0x184]        ;122
                  |L5.158|
00009e  1c52              ADDS     r2,r2,#1              ;122
0000a0  b2d2              UXTB     r2,r2                 ;119
0000a2  f5016182          ADD      r1,r1,#0x410          ;119
0000a6  2a08              CMP      r2,#8                 ;119
0000a8  d3ea              BCC      |L5.128|
0000aa  f7fffffe          BL       FILE_SYSTEM_saveHoltConfiguration
0000ae  e7ef              B        |L5.144|
;;;135    
                          ENDP


                          AREA ||i.HOLT_CORE_holtSelfTest||, CODE, READONLY, ALIGN=2

                  HOLT_CORE_holtSelfTest PROC
;;;252    #define TMP_TEST_DATA 0x9DB6692A
;;;253    tdStatus HOLT_CORE_holtSelfTest(tdSpiDevice *_pDevice, tdArincReceiverFaild *_pFailStats)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;254    	{
000004  b08b              SUB      sp,sp,#0x2c
;;;255    	volatile tdStatus status;
;;;256    	uint8_t channel;
;;;257    	uint8_t test;
;;;258    	uint8_t trys;
;;;259    	uint8_t testSpeedHigh;
;;;260    	void (*pCurrentCallback)(void);
;;;261    	tdHoltStatus holtStatus;
;;;262    	uint16_t currentConfiguration[ HOLT_CORE_CHANNELS_AMOUNT ];
;;;263    	uint32_t loopBackData;
;;;264    	volatile uint8_t failureStatsus[ TMP_SPEED_AMOUNT ] = { 0x00, 0x00 };
000006  f04f0b00          MOV      r11,#0
00000a  468a              MOV      r10,r1                ;254
00000c  f8cdb000          STR      r11,[sp,#0]
;;;265    	uint16_t testCfg[ TMP_SPEED_AMOUNT ] = { (HOLT_DRIVER_HI3598_CONFIGURATION_SELF_TEST_ENABLE | HOLT_DRIVER_HI3598_CONFIGURATION_SPEED_LOW),
000010  484e              LDR      r0,|L6.332|
000012  6800              LDR      r0,[r0,#0]  ; <Data2>
;;;266    																					 (HOLT_DRIVER_HI3598_CONFIGURATION_SELF_TEST_ENABLE | HOLT_DRIVER_HI3598_CONFIGURATION_SPEED_HIGH) };
;;;267    
;;;268    	if( _pDevice == NULL )
000014  9009              STR      r0,[sp,#0x24]
000016  980b              LDR      r0,[sp,#0x2c]         ;254
000018  b3d0              CBZ      r0,|L6.144|
;;;269    		return Fail;
;;;270    
;;;271    	// Saving current configuration
;;;272    	TIM_CORE_getCallback(&htim7, &pCurrentCallback); // getData callback. to prevent loose of data for this test.
00001a  a907              ADD      r1,sp,#0x1c
00001c  484c              LDR      r0,|L6.336|
00001e  f7fffffe          BL       TIM_CORE_getCallback
;;;273    	for( channel = 0; channel < HOLT_CORE_CHANNELS_AMOUNT; channel++ ) // Holt Configuration
000022  2400              MOVS     r4,#0
000024  ae02              ADD      r6,sp,#8              ;262
                  |L6.38|
;;;274    		{
;;;275    		while( HOLT_DRIVER_readConfiguration(_pDevice, channel + 1, &currentConfiguration[ channel ]) == Busy );
000026  1c65              ADDS     r5,r4,#1
000028  46b0              MOV      r8,r6
00002a  eb060244          ADD      r2,r6,r4,LSL #1
00002e  b2e9              UXTB     r1,r5
000030  980b              LDR      r0,[sp,#0x2c]
000032  f7fffffe          BL       HOLT_DRIVER_readConfiguration
000036  2800              CMP      r0,#0
000038  d0f5              BEQ      |L6.38|
00003a  b2ec              UXTB     r4,r5                 ;273
00003c  2c08              CMP      r4,#8                 ;273
00003e  d3f2              BCC      |L6.38|
;;;276    		}
;;;277    
;;;278    	TIM_CORE_setCallback(&htim7, NULL); // Disable getData callback;
000040  2100              MOVS     r1,#0
000042  4843              LDR      r0,|L6.336|
000044  f7fffffe          BL       TIM_CORE_setCallback
;;;279    
;;;280    	for( test = 0; test < TMP_SPEED_AMOUNT; test++ )
000048  2400              MOVS     r4,#0
;;;281    		{
;;;282    		// test configuration
;;;283    		for( channel = 0; channel < HOLT_CORE_CHANNELS_AMOUNT; channel++ )
;;;284    			{
;;;285    			if( HOLT_CORE_configurateChannel(_pDevice, channel + 1, testCfg[ test ]) != Ok )
;;;286    				{
;;;287    				failureStatsus[ test ] |= ( 1 << channel );
00004a  2501              MOVS     r5,#1
                  |L6.76|
00004c  2600              MOVS     r6,#0                 ;283
00004e  f10d0924          ADD      r9,sp,#0x24           ;265
000052  bf00              NOP                            ;285
                  |L6.84|
000054  1c77              ADDS     r7,r6,#1              ;285
000056  f8392014          LDRH     r2,[r9,r4,LSL #1]     ;285
00005a  b2f9              UXTB     r1,r7                 ;285
00005c  980b              LDR      r0,[sp,#0x2c]         ;285
00005e  f7fffffe          BL       HOLT_CORE_configurateChannel
000062  2801              CMP      r0,#1                 ;285
000064  d006              BEQ      |L6.116|
000066  f81d1004          LDRB     r1,[sp,r4]
00006a  fa05f206          LSL      r2,r5,r6
00006e  4311              ORRS     r1,r1,r2
000070  f80d1004          STRB     r1,[sp,r4]
                  |L6.116|
000074  b2fe              UXTB     r6,r7                 ;283
000076  2e08              CMP      r6,#8                 ;283
000078  d3ec              BCC      |L6.84|
;;;288    				}
;;;289    			}
;;;290    
;;;291    		testSpeedHigh = (testCfg[ test ] & HOLT_DRIVER_HI3598_CONFIGURATION_SPEED_HIGH) ? 1 : 0;
;;;292    
;;;293    		HOLT_DRIVER_writeLoopBackFifoWord(_pDevice, testSpeedHigh, TMP_TEST_DATA);
00007a  f8df90d8          LDR      r9,|L6.340|
00007e  2100              MOVS     r1,#0                 ;291
000080  464a              MOV      r2,r9
000082  980b              LDR      r0,[sp,#0x2c]
000084  f7fffffe          BL       HOLT_DRIVER_writeLoopBackFifoWord
;;;294    
;;;295    		holtStatus.notEmpty = 0;
000088  f88db004          STRB     r11,[sp,#4]
;;;296    		trys = 10;
00008c  260a              MOVS     r6,#0xa
;;;297    
;;;298    		while( holtStatus.notEmpty == 0 && trys-- )
00008e  e00b              B        |L6.168|
                  |L6.144|
000090  e7ff              B        |L6.146|
                  |L6.146|
000092  2002              MOVS     r0,#2                 ;269
                  |L6.148|
;;;299    			{
;;;300    			HOLT_DRIVER_readStatus(_pDevice, &holtStatus);
;;;301    			}
;;;302    
;;;303    		for( channel = 0; channel < HOLT_CORE_CHANNELS_AMOUNT; channel++ )
;;;304    			{
;;;305    			if( holtStatus.notEmpty & ( 1 << channel ) )
;;;306    				{
;;;307    				status = HOLT_DRIVER_readFifoWord(_pDevice, channel + 1, &loopBackData);
;;;308    				if( status != Ok || loopBackData != TMP_TEST_DATA )
;;;309    					{
;;;310    					failureStatsus[ test ] |= ( 1 << channel );
;;;311    					}
;;;312    				}
;;;313    			else
;;;314    				{
;;;315    				failureStatsus[ test ] |= ( 1 << channel );
;;;316    				}
;;;317    			}
;;;318    		}
;;;319    
;;;320    	// Returning previous configuration
;;;321    	TIM_CORE_setCallback(&htim7, pCurrentCallback);
;;;322    	for( channel = 0; channel < HOLT_CORE_CHANNELS_AMOUNT; channel++ )
;;;323    		{
;;;324    		if( HOLT_CORE_configurateChannel(_pDevice, channel + 1, currentConfiguration[ channel ]) != Ok )
;;;325    			{
;;;326    			failureStatsus[ TMP_SPEED_HIGH ] |= ( 1 << channel );
;;;327    			failureStatsus[ TMP_SPEED_LOW ] |= ( 1 << channel );
;;;328    			}
;;;329    		}
;;;330    
;;;331    	if( _pFailStats != NULL )
;;;332    		{
;;;333    		_pFailStats->high = failureStatsus[ TMP_SPEED_HIGH ];
;;;334    		_pFailStats->low = failureStatsus[ TMP_SPEED_LOW ];
;;;335    		}
;;;336    
;;;337    	return Ok;
;;;338    	}
000094  b00d              ADD      sp,sp,#0x34
000096  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.154|
00009a  a901              ADD      r1,sp,#4              ;300
00009c  980b              LDR      r0,[sp,#0x2c]         ;300
00009e  f7fffffe          BL       HOLT_DRIVER_readStatus
0000a2  f89d0004          LDRB     r0,[sp,#4]            ;298
0000a6  b910              CBNZ     r0,|L6.174|
                  |L6.168|
0000a8  1e76              SUBS     r6,r6,#1              ;298
0000aa  b2f6              UXTB     r6,r6                 ;298
0000ac  d2f5              BCS      |L6.154|
                  |L6.174|
0000ae  2600              MOVS     r6,#0                 ;303
                  |L6.176|
0000b0  f89d0004          LDRB     r0,[sp,#4]            ;305
0000b4  fa05f706          LSL      r7,r5,r6              ;305
0000b8  4238              TST      r0,r7                 ;305
0000ba  d00e              BEQ      |L6.218|
0000bc  1c70              ADDS     r0,r6,#1              ;307
0000be  b2c1              UXTB     r1,r0                 ;307
0000c0  aa08              ADD      r2,sp,#0x20           ;307
0000c2  980b              LDR      r0,[sp,#0x2c]         ;307
0000c4  f7fffffe          BL       HOLT_DRIVER_readFifoWord
0000c8  f88d0018          STRB     r0,[sp,#0x18]         ;307
0000cc  f89d0018          LDRB     r0,[sp,#0x18]         ;308
0000d0  2801              CMP      r0,#1                 ;308
0000d2  d102              BNE      |L6.218|
0000d4  9908              LDR      r1,[sp,#0x20]         ;308
0000d6  4549              CMP      r1,r9                 ;308
0000d8  d004              BEQ      |L6.228|
                  |L6.218|
0000da  f81d1004          LDRB     r1,[sp,r4]            ;310
0000de  4339              ORRS     r1,r1,r7              ;310
0000e0  f80d1004          STRB     r1,[sp,r4]            ;310
                  |L6.228|
0000e4  1c76              ADDS     r6,r6,#1              ;310
0000e6  b2f6              UXTB     r6,r6                 ;303
0000e8  2e08              CMP      r6,#8                 ;303
0000ea  d3e1              BCC      |L6.176|
0000ec  1c64              ADDS     r4,r4,#1              ;303
0000ee  b2e4              UXTB     r4,r4                 ;280
0000f0  2c02              CMP      r4,#2                 ;280
0000f2  d3ab              BCC      |L6.76|
0000f4  4816              LDR      r0,|L6.336|
0000f6  9907              LDR      r1,[sp,#0x1c]         ;321
0000f8  f7fffffe          BL       TIM_CORE_setCallback
0000fc  2400              MOVS     r4,#0                 ;322
0000fe  4646              MOV      r6,r8                 ;262
                  |L6.256|
000100  1c67              ADDS     r7,r4,#1              ;324
000102  f8362014          LDRH     r2,[r6,r4,LSL #1]     ;324
000106  b2f9              UXTB     r1,r7                 ;324
000108  980b              LDR      r0,[sp,#0x2c]         ;324
00010a  f7fffffe          BL       HOLT_CORE_configurateChannel
00010e  2801              CMP      r0,#1                 ;324
000110  d00b              BEQ      |L6.298|
000112  f89d1001          LDRB     r1,[sp,#1]            ;326
000116  fa05f004          LSL      r0,r5,r4              ;326
00011a  4301              ORRS     r1,r1,r0              ;326
00011c  f88d1001          STRB     r1,[sp,#1]            ;326
000120  f89d1000          LDRB     r1,[sp,#0]            ;327
000124  4301              ORRS     r1,r1,r0              ;327
000126  f88d1000          STRB     r1,[sp,#0]            ;327
                  |L6.298|
00012a  b2fc              UXTB     r4,r7                 ;322
00012c  2c08              CMP      r4,#8                 ;322
00012e  d3e7              BCC      |L6.256|
000130  f1ba0f00          CMP      r10,#0                ;331
000134  d007              BEQ      |L6.326|
000136  f89d1001          LDRB     r1,[sp,#1]            ;333
00013a  f88a1000          STRB     r1,[r10,#0]           ;333
00013e  f89d1000          LDRB     r1,[sp,#0]            ;334
000142  f88a1001          STRB     r1,[r10,#1]           ;334
                  |L6.326|
000146  2001              MOVS     r0,#1                 ;337
000148  e7a4              B        |L6.148|
;;;339    #undef TMP_SPEED_AMOUNT
                          ENDP

00014a  0000              DCW      0x0000
                  |L6.332|
                          DCD      ||.constdata||
                  |L6.336|
                          DCD      htim7
                  |L6.340|
                          DCD      0x9db6692a

                          AREA ||i.HOLT_CORE_init||, CODE, READONLY, ALIGN=2

                  HOLT_CORE_init PROC
;;;9      
;;;10     void HOLT_CORE_init(tdSpiDevice *_pDevice, tdArinc *_pArinc)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;11     	{
000004  4681              MOV      r9,r0
;;;12     	uint8_t channel;
;;;13     	uint16_t configuration;
;;;14     	tdArincChannel *pChannel;
;;;15     	tdSpiCS hot3598ChipSelect;
;;;16     	SPI_HandleTypeDef *pHspi;
;;;17     
;;;18     #ifdef USB_HARDWARE_FS
;;;19     	pHspi = &hspi1;
;;;20     	hot3598ChipSelect.pGPIO = GPIOA;
;;;21     	hot3598ChipSelect.pin = GPIO_PIN_4;
;;;22     #else
;;;23     	pHspi = &hspi3;
;;;24     	hot3598ChipSelect.pGPIO = GPIOC;
000006  4820              LDR      r0,|L7.136|
;;;25     	hot3598ChipSelect.pin = GPIO_PIN_13;
000008  9000              STR      r0,[sp,#0]
00000a  f44f5000          MOV      r0,#0x2000
00000e  460c              MOV      r4,r1                 ;11
;;;26     #endif
;;;27     
;;;28     	_pArinc->activeChannelsAmount = 0;
000010  9001              STR      r0,[sp,#4]
000012  2600              MOVS     r6,#0
000014  491b              LDR      r1,|L7.132|
;;;29     
;;;30     	SPI_DRIVER_initDevice(&HOLT3598, pHspi, &hot3598ChipSelect);
000016  466a              MOV      r2,sp
000018  481c              LDR      r0,|L7.140|
00001a  6026              STR      r6,[r4,#0]
00001c  f7fffffe          BL       SPI_DRIVER_initDevice
;;;31     
;;;32     	HOLT_CORE_holtSelfTest(_pDevice, &holtReceiversStatus);
000020  491b              LDR      r1,|L7.144|
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       HOLT_CORE_holtSelfTest
;;;33     
;;;34     	HOLT_CORE_generateReversedLabels(_pArinc);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       HOLT_CORE_generateReversedLabels
;;;35     
;;;36     	FILE_SYSTEM_readHoltConfiguration(_pArinc);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       FILE_SYSTEM_readHoltConfiguration
;;;37     
;;;38     	channel = 0;
000034  2500              MOVS     r5,#0
;;;39     	pChannel = &_pArinc->channel[ 0 ];
;;;40     	while( channel < HOLT_CORE_CHANNELS_AMOUNT )
;;;41     		{
;;;42     		pChannel->status.active = 0;
;;;43     		pChannel->status.activeTimeEnd = 0;
;;;44     		pChannel->status.state = notActiveState;
;;;45     		if( pChannel->status.enable == 1 )
;;;46     			{
;;;47     			configuration = CORE_HOLT3598_CONFIGURATION;
000036  f44f7708          MOV      r7,#0x220
;;;48     
;;;49     			if( pChannel->freq == frequency_100_kHz )
;;;50     				configuration |= HOLT_DRIVER_HI3598_CONFIGURATION_SPEED_HIGH;
;;;51     			else if( pChannel->freq == frequency_12_5_kHz )
;;;52     				configuration |= HOLT_DRIVER_HI3598_CONFIGURATION_SPEED_LOW;
00003a  f2402821          MOV      r8,#0x221
00003e  1d24              ADDS     r4,r4,#4
                  |L7.64|
000040  f8846409          STRB     r6,[r4,#0x409]        ;42
000044  f8c46404          STR      r6,[r4,#0x404]        ;44
000048  f884640a          STRB     r6,[r4,#0x40a]        ;44
00004c  f8940408          LDRB     r0,[r4,#0x408]        ;45
000050  2801              CMP      r0,#1                 ;45
000052  d10b              BNE      |L7.108|
000054  f894040c          LDRB     r0,[r4,#0x40c]        ;49
000058  463a              MOV      r2,r7                 ;47
00005a  b110              CBZ      r0,|L7.98|
00005c  2802              CMP      r0,#2                 ;51
00005e  d100              BNE      |L7.98|
000060  4642              MOV      r2,r8
                  |L7.98|
;;;53     
;;;54     			HOLT_CORE_configurateChannel(_pDevice, channel + 1, configuration);
000062  1c68              ADDS     r0,r5,#1
000064  b2c1              UXTB     r1,r0
000066  4648              MOV      r0,r9
000068  f7fffffe          BL       HOLT_CORE_configurateChannel
                  |L7.108|
00006c  1c6d              ADDS     r5,r5,#1
;;;55     			}
;;;56     
;;;57     		pChannel++;
;;;58     		channel++;
00006e  b2ed              UXTB     r5,r5
000070  f5046482          ADD      r4,r4,#0x410
000074  2d08              CMP      r5,#8                 ;40
000076  d3e3              BCC      |L7.64|
;;;59     		}
;;;60     
;;;61     	HOLT_DRIVER_masterReset( &HOLT3598 );
000078  4804              LDR      r0,|L7.140|
00007a  f7fffffe          BL       HOLT_DRIVER_masterReset
;;;62     	}
00007e  e8bd87fc          POP      {r2-r10,pc}
;;;63     
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      hspi3
                  |L7.136|
                          DCD      0x40020800
                  |L7.140|
                          DCD      ||.bss||
                  |L7.144|
                          DCD      ||.data||

                          AREA ||i.HOLT_CORE_readWordsFormChannel||, CODE, READONLY, ALIGN=1

                  HOLT_CORE_readWordsFormChannel PROC
;;;151    
;;;152    tdStatus HOLT_CORE_readWordsFormChannel(tdSpiDevice *_pDevice, tdArinc *_pArinc, uint8_t _channel, uint8_t _wordsToRead, uint8_t *_pBuffer, uint32_t *_pCurrentSize, uint32_t _maxSize)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;153    	{
000004  b081              SUB      sp,sp,#4
000006  4689              MOV      r9,r1
000008  a90e              ADD      r1,sp,#0x38
;;;154    	tdArincChannel *pArincChannel;
;;;155    	uint8_t channel;
;;;156    	uint32_t word;
;;;157    	uint8_t lable;
;;;158    
;;;159    	channel = _channel - 1;
00000a  1e50              SUBS     r0,r2,#1
00000c  e8910830          LDM      r1,{r4,r5,r11}        ;153
000010  f00008ff          AND      r8,r0,#0xff
;;;160    	pArincChannel = &_pArinc->channel[ channel ];
000014  eb081188          ADD      r1,r8,r8,LSL #6
000018  eb091601          ADD      r6,r9,r1,LSL #4
00001c  461f              MOV      r7,r3                 ;153
;;;161    
;;;162    	if( pArincChannel->status.enable == 0  )
00001e  f896040c          LDRB     r0,[r6,#0x40c]
000022  4692              MOV      r10,r2                ;153
000024  1d36              ADDS     r6,r6,#4
000026  b3d0              CBZ      r0,|L8.158|
000028  e03c              B        |L8.164|
                  |L8.42|
;;;163    		return Ok;
;;;164    
;;;165    	while( _wordsToRead )
;;;166    		{
;;;167    		if( HOLT_DRIVER_readFifoWord(_pDevice, _channel, &word) == Ok )
00002a  466a              MOV      r2,sp
00002c  4651              MOV      r1,r10
00002e  9801              LDR      r0,[sp,#4]
000030  f7fffffe          BL       HOLT_DRIVER_readFifoWord
000034  2801              CMP      r0,#1
000036  d135              BNE      |L8.164|
;;;168    			{
;;;169    			pArincChannel->okTimeEnd = HAL_GetTick() + BHD2_ARINC_CHANNEL_OK_TIMEOUT_MS;
000038  f7fffffe          BL       HAL_GetTick
00003c  f50060fa          ADD      r0,r0,#0x7d0
;;;170    
;;;171    			lable = _pArinc->reversedLabels[ word & (HOLT_CORE_LABELS_AMOUNT - 1) ]; // (word & 0xFF) - reversed lable
000040  f8c60400          STR      r0,[r6,#0x400]
000044  9900              LDR      r1,[sp,#0]
000046  b2ca              UXTB     r2,r1
000048  eb020009          ADD      r0,r2,r9
00004c  f5005000          ADD      r0,r0,#0x2000
000050  f8900084          LDRB     r0,[r0,#0x84]
;;;172    			pArincChannel->data[ lable ] = word;
000054  f8461020          STR      r1,[r6,r0,LSL #2]
;;;173    
;;;174    			if( pArincChannel->status.active == 1 )
000058  f8960409          LDRB     r0,[r6,#0x409]
00005c  2801              CMP      r0,#1
00005e  d11f              BNE      |L8.160|
;;;175    				{
;;;176    				*(_pBuffer + *_pCurrentSize + 0) = channel;
000060  6829              LDR      r1,[r5,#0]
000062  f8048001          STRB     r8,[r4,r1]
;;;177    				 MWN_M_setValue32ToBuffer(word, _pBuffer, *_pCurrentSize + 1);
000066  9800              LDR      r0,[sp,#0]
000068  682a              LDR      r2,[r5,#0]
00006a  0e01              LSRS     r1,r0,#24
00006c  1d20              ADDS     r0,r4,#4
00006e  5411              STRB     r1,[r2,r0]
000070  9800              LDR      r0,[sp,#0]
000072  682a              LDR      r2,[r5,#0]
000074  0c01              LSRS     r1,r0,#16
000076  1ce0              ADDS     r0,r4,#3
000078  5411              STRB     r1,[r2,r0]
00007a  9800              LDR      r0,[sp,#0]
00007c  682a              LDR      r2,[r5,#0]
00007e  0a01              LSRS     r1,r0,#8
000080  1ca0              ADDS     r0,r4,#2
000082  5411              STRB     r1,[r2,r0]
000084  682a              LDR      r2,[r5,#0]
000086  1c61              ADDS     r1,r4,#1
000088  9800              LDR      r0,[sp,#0]
00008a  5450              STRB     r0,[r2,r1]
;;;178    
;;;179    				*_pCurrentSize += HOLT_CORE_READ_BYTES_AMOUNT;
00008c  6828              LDR      r0,[r5,#0]
00008e  1d40              ADDS     r0,r0,#5
;;;180    
;;;181    				if( !(*_pCurrentSize < _maxSize) )
000090  6028              STR      r0,[r5,#0]
000092  4558              CMP      r0,r11
000094  d304              BCC      |L8.160|
;;;182    					return ProcessBreak;
000096  2004              MOVS     r0,#4
                  |L8.152|
;;;183    				}
;;;184    
;;;185    			_wordsToRead--;
;;;186    			}
;;;187    		}
;;;188    
;;;189    	return Ok;
;;;190    	}
000098  b005              ADD      sp,sp,#0x14
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.158|
00009e  e003              B        |L8.168|
                  |L8.160|
0000a0  1e7f              SUBS     r7,r7,#1
0000a2  b2ff              UXTB     r7,r7                 ;185
                  |L8.164|
0000a4  2f00              CMP      r7,#0                 ;165
0000a6  d1c0              BNE      |L8.42|
                  |L8.168|
0000a8  2001              MOVS     r0,#1                 ;189
0000aa  e7f5              B        |L8.152|
;;;191    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  HOLT3598
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00010000          DCW      0x0001,0x0000

                          AREA ||.data||, DATA, ALIGN=0

                  holtReceiversStatus
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Src\\core\\holtCore.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_holtCore_c_2db9b23c____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_holtCore_c_2db9b23c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_holtCore_c_2db9b23c____REVSH|
#line 144
|__asm___10_holtCore_c_2db9b23c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
