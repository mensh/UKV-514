; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_ll_fsmc.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_ll_fsmc.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_ll_fsmc.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_ll_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_NAND_AttributeSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_AttributeSpace_Timing_Init PROC
;;;491      */
;;;492    HAL_StatusTypeDef FSMC_NAND_AttributeSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;493    {
000002  e9d13400          LDRD     r3,r4,[r1,#0]
;;;494      uint32_t tmppatt = 0;  
;;;495      
;;;496      /* Check the parameters */  
;;;497      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;498      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;499      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;500      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;501      
;;;502      /* Set FSMC_NAND device timing parameters */
;;;503      tmppatt = (uint32_t)(Timing->SetupTime                  |\
000006  ea432304          ORR      r3,r3,r4,LSL #8
00000a  890c              LDRH     r4,[r1,#8]
00000c  7b09              LDRB     r1,[r1,#0xc]
00000e  0424              LSLS     r4,r4,#16
000010  ea446101          ORR      r1,r4,r1,LSL #24
000014  430b              ORRS     r3,r3,r1
;;;504                           ((Timing->WaitSetupTime) << 8)     |\
;;;505                           ((Timing->HoldSetupTime) << 16)    |\
;;;506                           ((Timing->HiZSetupTime) << 24)
;;;507                           );
;;;508                           
;;;509      if(Bank == FSMC_NAND_BANK2)
000016  2a10              CMP      r2,#0x10
000018  d002              BEQ      |L1.32|
;;;510      {
;;;511        /* NAND bank 2 registers configuration */
;;;512        Device->PATT2 = tmppatt;
;;;513      }
;;;514      else
;;;515      {
;;;516        /* NAND bank 3 registers configuration */
;;;517        Device->PATT3 = tmppatt;
00001a  62c3              STR      r3,[r0,#0x2c]
                  |L1.28|
;;;518      }   
;;;519      
;;;520      return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;521    }
00001e  bd10              POP      {r4,pc}
                  |L1.32|
000020  60c3              STR      r3,[r0,#0xc]          ;512
000022  e7fb              B        |L1.28|
;;;522    
                          ENDP


                          AREA ||i.FSMC_NAND_CommonSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_CommonSpace_Timing_Init PROC
;;;452      */
;;;453    HAL_StatusTypeDef FSMC_NAND_CommonSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  e9d13400          LDRD     r3,r4,[r1,#0]
;;;455      uint32_t tmppmem = 0;  
;;;456      
;;;457      /* Check the parameters */
;;;458      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;459      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;460      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;461      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;462      
;;;463      /* Set FSMC_NAND device timing parameters */
;;;464      tmppmem = (uint32_t)(Timing->SetupTime                  |\
000006  ea432304          ORR      r3,r3,r4,LSL #8
00000a  890c              LDRH     r4,[r1,#8]
00000c  7b09              LDRB     r1,[r1,#0xc]
00000e  0424              LSLS     r4,r4,#16
000010  ea446101          ORR      r1,r4,r1,LSL #24
000014  430b              ORRS     r3,r3,r1
;;;465                           ((Timing->WaitSetupTime) << 8)     |\
;;;466                           ((Timing->HoldSetupTime) << 16)    |\
;;;467                           ((Timing->HiZSetupTime) << 24)
;;;468                           );
;;;469                                
;;;470      if(Bank == FSMC_NAND_BANK2)
000016  2a10              CMP      r2,#0x10
000018  d002              BEQ      |L2.32|
;;;471      {
;;;472        /* NAND bank 2 registers configuration */
;;;473        Device->PMEM2 = tmppmem;
;;;474      }
;;;475      else
;;;476      {
;;;477        /* NAND bank 3 registers configuration */
;;;478        Device->PMEM3 = tmppmem;
00001a  6283              STR      r3,[r0,#0x28]
                  |L2.28|
;;;479      }  
;;;480      
;;;481      return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;482    }
00001e  bd10              POP      {r4,pc}
                  |L2.32|
000020  6083              STR      r3,[r0,#8]            ;473
000022  e7fb              B        |L2.28|
;;;483    
                          ENDP


                          AREA ||i.FSMC_NAND_DeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_DeInit PROC
;;;529      */
;;;530    HAL_StatusTypeDef FSMC_NAND_DeInit(FSMC_NAND_TypeDef *Device, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;531    {
;;;532      /* Disable the NAND Bank */
;;;533      __FSMC_NAND_DISABLE(Device, Bank);
;;;534     
;;;535      /* De-initialize the NAND Bank */
;;;536      if(Bank == FSMC_NAND_BANK2)
;;;537      {
;;;538        /* Set the FSMC_NAND_BANK2 registers to their reset values */
;;;539        Device->PCR2  = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;540        Device->SR2   = 0x00000040;
000004  2440              MOVS     r4,#0x40
;;;541        Device->PMEM2 = 0xFCFCFCFC;
000006  f04f32fc          MOV      r2,#0xfcfcfcfc
00000a  2910              CMP      r1,#0x10              ;533
00000c  d009              BEQ      |L3.34|
00000e  6a01              LDR      r1,[r0,#0x20]         ;533
000010  f0210104          BIC      r1,r1,#4              ;533
000014  6201              STR      r1,[r0,#0x20]         ;533
;;;542        Device->PATT2 = 0xFCFCFCFC;  
;;;543      }
;;;544      /* FSMC_Bank3_NAND */  
;;;545      else
;;;546      {
;;;547        /* Set the FSMC_NAND_BANK3 registers to their reset values */
;;;548        Device->PCR3  = 0x00000018;
000016  6203              STR      r3,[r0,#0x20]
;;;549        Device->SR3   = 0x00000040;
000018  6244              STR      r4,[r0,#0x24]
;;;550        Device->PMEM3 = 0xFCFCFCFC;
00001a  6282              STR      r2,[r0,#0x28]
;;;551        Device->PATT3 = 0xFCFCFCFC; 
00001c  62c2              STR      r2,[r0,#0x2c]
                  |L3.30|
;;;552      }
;;;553      
;;;554      return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;555    }
000020  bd10              POP      {r4,pc}
                  |L3.34|
000022  6801              LDR      r1,[r0,#0]            ;533
000024  f0210104          BIC      r1,r1,#4              ;533
000028  6001              STR      r1,[r0,#0]            ;533
00002a  6003              STR      r3,[r0,#0]            ;539
00002c  6044              STR      r4,[r0,#4]            ;540
00002e  6082              STR      r2,[r0,#8]            ;541
000030  60c2              STR      r2,[r0,#0xc]          ;542
000032  e7f4              B        |L3.30|
;;;556    
                          ENDP


                          AREA ||i.FSMC_NAND_ECC_Disable||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_ECC_Disable PROC
;;;605      */  
;;;606    HAL_StatusTypeDef FSMC_NAND_ECC_Disable(FSMC_NAND_TypeDef *Device, uint32_t Bank)  
000000  2910              CMP      r1,#0x10
;;;607    {  
000002  d005              BEQ      |L4.16|
;;;608      /* Disable ECC feature */
;;;609      if(Bank == FSMC_NAND_BANK2)
;;;610      {
;;;611        Device->PCR2 &= ~FSMC_PCR2_ECCEN;
;;;612      }
;;;613      else
;;;614      {
;;;615        Device->PCR3 &= ~FSMC_PCR3_ECCEN;
000004  6a01              LDR      r1,[r0,#0x20]
000006  f0210140          BIC      r1,r1,#0x40
00000a  6201              STR      r1,[r0,#0x20]
                  |L4.12|
;;;616      } 
;;;617    
;;;618      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;619    }
00000e  4770              BX       lr
                  |L4.16|
000010  6801              LDR      r1,[r0,#0]            ;611
000012  f0210140          BIC      r1,r1,#0x40           ;611
000016  6001              STR      r1,[r0,#0]            ;611
000018  e7f8              B        |L4.12|
;;;620    
                          ENDP


                          AREA ||i.FSMC_NAND_ECC_Enable||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_ECC_Enable PROC
;;;583      */    
;;;584    HAL_StatusTypeDef  FSMC_NAND_ECC_Enable(FSMC_NAND_TypeDef *Device, uint32_t Bank)
000000  2910              CMP      r1,#0x10
;;;585    {
000002  d005              BEQ      |L5.16|
;;;586      /* Enable ECC feature */
;;;587      if(Bank == FSMC_NAND_BANK2)
;;;588      {
;;;589        Device->PCR2 |= FSMC_PCR2_ECCEN;
;;;590      }
;;;591      else
;;;592      {
;;;593        Device->PCR3 |= FSMC_PCR3_ECCEN;
000004  6a01              LDR      r1,[r0,#0x20]
000006  f0410140          ORR      r1,r1,#0x40
00000a  6201              STR      r1,[r0,#0x20]
                  |L5.12|
;;;594      } 
;;;595      
;;;596      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;597    }
00000e  4770              BX       lr
                  |L5.16|
000010  6801              LDR      r1,[r0,#0]            ;589
000012  f0410140          ORR      r1,r1,#0x40           ;589
000016  6001              STR      r1,[r0,#0]            ;589
000018  e7f8              B        |L5.12|
;;;598    
                          ENDP


                          AREA ||i.FSMC_NAND_GetECC||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_GetECC PROC
;;;628      */
;;;629    HAL_StatusTypeDef FSMC_NAND_GetECC(FSMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;630    {
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  4604              MOV      r4,r0
;;;631      uint32_t timeout = 0;
;;;632      
;;;633      /* Check the parameters */ 
;;;634      assert_param(IS_FSMC_NAND_DEVICE(Device)); 
;;;635      assert_param(IS_FSMC_NAND_BANK(Bank));
;;;636        
;;;637      timeout = HAL_GetTick() + Timeout;
00000c  f7fffffe          BL       HAL_GetTick
000010  eb000805          ADD      r8,r0,r5
;;;638      
;;;639      /* Wait untill FIFO is empty */
;;;640      while(__FSMC_NAND_GET_FLAG(Device, Bank, FSMC_FLAG_FEMPT))
000014  e008              B        |L6.40|
                  |L6.22|
;;;641      {
;;;642        /* Check for the Timeout */
;;;643        if(Timeout != HAL_MAX_DELAY)
000016  1c68              ADDS     r0,r5,#1
000018  d006              BEQ      |L6.40|
;;;644        {
;;;645          if(HAL_GetTick() >= timeout)
00001a  f7fffffe          BL       HAL_GetTick
00001e  4540              CMP      r0,r8
000020  d302              BCC      |L6.40|
;;;646          {
;;;647            return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
                  |L6.36|
;;;648          }
;;;649        }   
;;;650      }
;;;651         
;;;652      if(Bank == FSMC_NAND_BANK2)
;;;653      {    
;;;654        /* Get the ECCR2 register value */
;;;655        *ECCval = (uint32_t)Device->ECCR2;
;;;656      }
;;;657      else
;;;658      {    
;;;659        /* Get the ECCR3 register value */
;;;660        *ECCval = (uint32_t)Device->ECCR3;
;;;661      }
;;;662    
;;;663      return HAL_OK;  
;;;664    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L6.40|
000028  2e10              CMP      r6,#0x10              ;640
00002a  d00b              BEQ      |L6.68|
00002c  f8d40024          LDR.W    r0,[r4,#0x24]         ;640
                  |L6.48|
000030  f3c01080          UBFX     r0,r0,#6,#1           ;640
000034  2800              CMP      r0,#0                 ;640
000036  d1ee              BNE      |L6.22|
000038  2e10              CMP      r6,#0x10              ;652
00003a  d005              BEQ      |L6.72|
00003c  6b60              LDR      r0,[r4,#0x34]         ;660
                  |L6.62|
00003e  6038              STR      r0,[r7,#0]            ;663
000040  2000              MOVS     r0,#0                 ;663
000042  e7ef              B        |L6.36|
                  |L6.68|
000044  6860              LDR      r0,[r4,#4]            ;640
000046  e7f3              B        |L6.48|
                  |L6.72|
000048  6960              LDR      r0,[r4,#0x14]         ;655
00004a  e7f8              B        |L6.62|
;;;665    
                          ENDP


                          AREA ||i.FSMC_NAND_Init||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_Init PROC
;;;406      */
;;;407    HAL_StatusTypeDef FSMC_NAND_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_InitTypeDef *Init)
000000  b510              PUSH     {r4,lr}
;;;408    {
000002  e9d12301          LDRD     r2,r3,[r1,#4]
;;;409      uint32_t tmppcr  = 0; 
;;;410        
;;;411      /* Check the parameters */
;;;412      assert_param(IS_FSMC_NAND_BANK(Init->NandBank));
;;;413      assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
;;;414      assert_param(IS_FSMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;415      assert_param(IS_FSMC_ECC_STATE(Init->EccComputation));
;;;416      assert_param(IS_FSMC_ECCPAGE_SIZE(Init->ECCPageSize));
;;;417      assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
;;;418      assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));   
;;;419    
;;;420      /* Set NAND device control parameters */
;;;421      tmppcr = (uint32_t)(Init->Waitfeature                |\
000006  431a              ORRS     r2,r2,r3
000008  e9d13403          LDRD     r3,r4,[r1,#0xc]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  694b              LDR      r3,[r1,#0x14]
000012  ea422243          ORR      r2,r2,r3,LSL #9
000016  698b              LDR      r3,[r1,#0x18]
;;;422                          FSMC_PCR_MEMORY_TYPE_NAND         |\
;;;423                          Init->MemoryDataWidth            |\
;;;424                          Init->EccComputation             |\
;;;425                          Init->ECCPageSize                |\
;;;426                          ((Init->TCLRSetupTime) << 9)     |\
;;;427                          ((Init->TARSetupTime) << 13)
;;;428                          );   
;;;429      
;;;430      if(Init->NandBank == FSMC_NAND_BANK2)
000018  6809              LDR      r1,[r1,#0]
00001a  ea423243          ORR      r2,r2,r3,LSL #13      ;421
00001e  f0420208          ORR      r2,r2,#8              ;421
000022  2910              CMP      r1,#0x10
000024  d002              BEQ      |L7.44|
;;;431      {
;;;432        /* NAND bank 2 registers configuration */
;;;433        Device->PCR2  = tmppcr;
;;;434      }
;;;435      else
;;;436      {
;;;437        /* NAND bank 3 registers configuration */
;;;438        Device->PCR3  = tmppcr;
000026  6202              STR      r2,[r0,#0x20]
                  |L7.40|
;;;439      }
;;;440      
;;;441      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;442    
;;;443    }
00002a  bd10              POP      {r4,pc}
                  |L7.44|
00002c  6002              STR      r2,[r0,#0]            ;433
00002e  e7fb              B        |L7.40|
;;;444    
                          ENDP


                          AREA ||i.FSMC_NORSRAM_DeInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAM_DeInit PROC
;;;198      */
;;;199    HAL_StatusTypeDef FSMC_NORSRAM_DeInit(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
000000  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;200    {
;;;201      /* Check the parameters */
;;;202      assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
;;;203      assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
;;;204    
;;;205      /* Disable the FSMC_NORSRAM device */
;;;206      __FSMC_NORSRAM_DISABLE(Device, Bank);
000004  f0230301          BIC      r3,r3,#1
000008  f8403022          STR      r3,[r0,r2,LSL #2]
00000c  b16a              CBZ      r2,|L8.42|
;;;207      
;;;208      /* De-initialize the FSMC_NORSRAM device */
;;;209      /* FSMC_NORSRAM_BANK1 */
;;;210      if(Bank == FSMC_NORSRAM_BANK1)
;;;211      {
;;;212        Device->BTCR[Bank] = 0x000030DB;    
;;;213      }
;;;214      /* FSMC_NORSRAM_BANK2, FSMC_NORSRAM_BANK3 or FSMC_NORSRAM_BANK4 */
;;;215      else
;;;216      {   
;;;217        Device->BTCR[Bank] = 0x000030D2; 
00000e  f24303d2          MOV      r3,#0x30d2
000012  f8403022          STR      r3,[r0,r2,LSL #2]
;;;218      }
;;;219      
;;;220      Device->BTCR[Bank + 1] = 0x0FFFFFFF;
000016  bf00              NOP      
                  |L8.24|
000018  eb000082          ADD      r0,r0,r2,LSL #2
00001c  f06f4370          MVN      r3,#0xf0000000
000020  6043              STR      r3,[r0,#4]
;;;221      ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
000022  f8413022          STR      r3,[r1,r2,LSL #2]
;;;222       
;;;223      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;224    }
000028  4770              BX       lr
                  |L8.42|
00002a  f24303db          MOV      r3,#0x30db            ;212
00002e  6003              STR      r3,[r0,#0]            ;212
000030  e7f2              B        |L8.24|
;;;225    
                          ENDP


                          AREA ||i.FSMC_NORSRAM_Extended_Timing_Init||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAM_Extended_Timing_Init PROC
;;;270      */
;;;271    HAL_StatusTypeDef  FSMC_NORSRAM_Extended_Timing_Init(FSMC_NORSRAM_EXTENDED_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
000000  b530              PUSH     {r4,r5,lr}
;;;272    {
;;;273      /* Set NORSRAM device timing register for write configuration, if extended mode is used */
;;;274      if(ExtendedMode == FSMC_EXTENDED_MODE_ENABLE)
000002  f5b34f80          CMP      r3,#0x4000
000006  d005              BEQ      |L9.20|
;;;275      {
;;;276        /* Check the parameters */  
;;;277        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;278        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;279        assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;280        assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;281        assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
;;;282        assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
;;;283        assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
;;;284      
;;;285        Device->BWTR[Bank] = (uint32_t)(Timing->AddressSetupTime                 |\
;;;286                                       ((Timing->AddressHoldTime) << 4)          |\
;;;287                                       ((Timing->DataSetupTime) << 8)            |\
;;;288                                       ((Timing->BusTurnAroundDuration) << 16)   |\
;;;289                                       (((Timing->CLKDivision)-1) << 20)         |\
;;;290                                       (((Timing->DataLatency)-2) << 24)         |\
;;;291                                       (Timing->AccessMode));
;;;292      }
;;;293      else                                        
;;;294      {
;;;295        Device->BWTR[Bank] = 0x0FFFFFFF;
000008  f06f4170          MVN      r1,#0xf0000000
00000c  f8401022          STR      r1,[r0,r2,LSL #2]
                  |L9.16|
;;;296      }   
;;;297      
;;;298      return HAL_OK;  
000010  2000              MOVS     r0,#0
;;;299    }
000012  bd30              POP      {r4,r5,pc}
                  |L9.20|
000014  e9d13400          LDRD     r3,r4,[r1,#0]
000018  ea431304          ORR      r3,r3,r4,LSL #4       ;285
00001c  688c              LDR      r4,[r1,#8]            ;285
00001e  898d              LDRH     r5,[r1,#0xc]          ;285
000020  0224              LSLS     r4,r4,#8              ;285
000022  ea444405          ORR      r4,r4,r5,LSL #16      ;285
000026  4323              ORRS     r3,r3,r4              ;285
000028  8a0c              LDRH     r4,[r1,#0x10]         ;285
00002a  4d07              LDR      r5,|L9.72|
00002c  eb055404          ADD      r4,r5,r4,LSL #20      ;285
000030  4323              ORRS     r3,r3,r4              ;285
000032  7d0c              LDRB     r4,[r1,#0x14]         ;285
000034  016d              LSLS     r5,r5,#5              ;285
000036  eb056404          ADD      r4,r5,r4,LSL #24      ;285
00003a  6989              LDR      r1,[r1,#0x18]         ;285
00003c  4323              ORRS     r3,r3,r4              ;285
00003e  430b              ORRS     r3,r3,r1              ;285
000040  f8403022          STR      r3,[r0,r2,LSL #2]     ;285
000044  e7e4              B        |L9.16|
;;;300    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0xfff00000

                          AREA ||i.FSMC_NORSRAM_Init||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAM_Init PROC
;;;146      */
;;;147    HAL_StatusTypeDef  FSMC_NORSRAM_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_InitTypeDef* Init)
000000  b530              PUSH     {r4,r5,lr}
;;;148    { 
000002  e9d12301          LDRD     r2,r3,[r1,#4]
;;;149      uint32_t tmpr = 0;
;;;150        
;;;151      /* Check the parameters */
;;;152      assert_param(IS_FSMC_NORSRAM_BANK(Init->NSBank));
;;;153      assert_param(IS_FSMC_MUX(Init->DataAddressMux));
;;;154      assert_param(IS_FSMC_MEMORY(Init->MemoryType));
;;;155      assert_param(IS_FSMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;156      assert_param(IS_FSMC_BURSTMODE(Init->BurstAccessMode));
;;;157      assert_param(IS_FSMC_WAIT_POLARITY(Init->WaitSignalPolarity));
;;;158      assert_param(IS_FSMC_WRAP_MODE(Init->WrapMode));
;;;159      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
;;;160      assert_param(IS_FSMC_WRITE_OPERATION(Init->WriteOperation));
;;;161      assert_param(IS_FSMC_WAITE_SIGNAL(Init->WaitSignal));
;;;162      assert_param(IS_FSMC_EXTENDED_MODE(Init->ExtendedMode));
;;;163      assert_param(IS_FSMC_ASYNWAIT(Init->AsynchronousWait));
;;;164      assert_param(IS_FSMC_WRITE_BURST(Init->WriteBurst));
;;;165      
;;;166      /* Set NORSRAM device control parameters */
;;;167      tmpr = (uint32_t)(Init->DataAddressMux       |\
000006  e9d14503          LDRD     r4,r5,[r1,#0xc]
00000a  431a              ORRS     r2,r2,r3
00000c  432c              ORRS     r4,r4,r5
00000e  4322              ORRS     r2,r2,r4
000010  694c              LDR      r4,[r1,#0x14]
000012  4322              ORRS     r2,r2,r4
000014  698c              LDR      r4,[r1,#0x18]
000016  4322              ORRS     r2,r2,r4
000018  69cc              LDR      r4,[r1,#0x1c]
00001a  4322              ORRS     r2,r2,r4
00001c  6a0c              LDR      r4,[r1,#0x20]
00001e  4322              ORRS     r2,r2,r4
000020  6a4c              LDR      r4,[r1,#0x24]
000022  4322              ORRS     r2,r2,r4
000024  6a8c              LDR      r4,[r1,#0x28]
000026  4322              ORRS     r2,r2,r4
000028  6acc              LDR      r4,[r1,#0x2c]
00002a  4322              ORRS     r2,r2,r4
00002c  6b0c              LDR      r4,[r1,#0x30]
00002e  4322              ORRS     r2,r2,r4
;;;168                        Init->MemoryType           |\
;;;169                        Init->MemoryDataWidth      |\
;;;170                        Init->BurstAccessMode      |\
;;;171                        Init->WaitSignalPolarity   |\
;;;172                        Init->WrapMode             |\
;;;173                        Init->WaitSignalActive     |\
;;;174                        Init->WriteOperation       |\
;;;175                        Init->WaitSignal           |\
;;;176                        Init->ExtendedMode         |\
;;;177                        Init->AsynchronousWait     |\
;;;178                        Init->WriteBurst
;;;179                        );
;;;180                        
;;;181      if(Init->MemoryType == FSMC_MEMORY_TYPE_NOR)
000030  2b08              CMP      r3,#8
000032  d101              BNE      |L10.56|
;;;182      {
;;;183        tmpr |= (uint32_t)FSMC_NORSRAM_FLASH_ACCESS_ENABLE;
000034  f0420240          ORR      r2,r2,#0x40
                  |L10.56|
;;;184      }
;;;185      
;;;186      Device->BTCR[Init->NSBank] = tmpr;                   
000038  6809              LDR      r1,[r1,#0]
00003a  f8402021          STR      r2,[r0,r1,LSL #2]
;;;187      
;;;188      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;189    }
000040  bd30              POP      {r4,r5,pc}
;;;190    
                          ENDP


                          AREA ||i.FSMC_NORSRAM_Timing_Init||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAM_Timing_Init PROC
;;;234      */
;;;235    HAL_StatusTypeDef FSMC_NORSRAM_Timing_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;236    {
000002  e9d13400          LDRD     r3,r4,[r1,#0]
;;;237      uint32_t tmpr = 0;
;;;238      
;;;239      /* Check the parameters */
;;;240      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;241      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;242      assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;243      assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;244      assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
;;;245      assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
;;;246      assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
;;;247      
;;;248      /* Set FSMC_NORSRAM device timing parameters */  
;;;249      tmpr = (uint32_t)(Timing->AddressSetupTime                  |\
000006  ea431304          ORR      r3,r3,r4,LSL #4
00000a  688c              LDR      r4,[r1,#8]
00000c  898d              LDRH     r5,[r1,#0xc]
00000e  0224              LSLS     r4,r4,#8
000010  ea444405          ORR      r4,r4,r5,LSL #16
000014  4323              ORRS     r3,r3,r4
000016  8a0c              LDRH     r4,[r1,#0x10]
000018  4d07              LDR      r5,|L11.56|
;;;250                       ((Timing->AddressHoldTime) << 4)          |\
;;;251                       ((Timing->DataSetupTime) << 8)            |\
;;;252                       ((Timing->BusTurnAroundDuration) << 16)   |\
;;;253                       (((Timing->CLKDivision)-1) << 20)         |\
;;;254                       (((Timing->DataLatency)-2) << 24)         |\
;;;255                        (Timing->AccessMode)
;;;256                        );
;;;257      
;;;258      Device->BTCR[Bank + 1] = tmpr; 
00001a  eb000082          ADD      r0,r0,r2,LSL #2
00001e  eb055404          ADD      r4,r5,r4,LSL #20      ;249
000022  4323              ORRS     r3,r3,r4              ;249
000024  7d0c              LDRB     r4,[r1,#0x14]         ;249
000026  016d              LSLS     r5,r5,#5              ;249
000028  eb056404          ADD      r4,r5,r4,LSL #24      ;249
00002c  6989              LDR      r1,[r1,#0x18]         ;249
00002e  4323              ORRS     r3,r3,r4              ;249
000030  430b              ORRS     r3,r3,r1              ;249
000032  6043              STR      r3,[r0,#4]
;;;259      
;;;260      return HAL_OK;   
000034  2000              MOVS     r0,#0
;;;261    }
000036  bd30              POP      {r4,r5,pc}
;;;262    
                          ENDP

                  |L11.56|
                          DCD      0xfff00000

                          AREA ||i.FSMC_NORSRAM_WriteOperation_Disable||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAM_WriteOperation_Disable PROC
;;;341      */
;;;342    HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Disable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;343    { 
;;;344      /* Disable write operation */
;;;345      Device->BTCR[Bank] &= ~FSMC_WRITE_OPERATION_ENABLE; 
000004  f4225280          BIC      r2,r2,#0x1000
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;346    
;;;347      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;348    }
00000e  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.FSMC_NORSRAM_WriteOperation_Enable||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAM_WriteOperation_Enable PROC
;;;327      */
;;;328    HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Enable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;329    {
;;;330      /* Enable write operation */
;;;331      Device->BTCR[Bank] |= FSMC_WRITE_OPERATION_ENABLE; 
000004  f4425280          ORR      r2,r2,#0x1000
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;332    
;;;333      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;334    }
00000e  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.FSMC_PCCARD_AttributeSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARD_AttributeSpace_Timing_Init PROC
;;;770      */
;;;771    HAL_StatusTypeDef FSMC_PCCARD_AttributeSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
000000  e9d12300          LDRD     r2,r3,[r1,#0]
;;;772    {
;;;773      /* Check the parameters */  
;;;774      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;775      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;776      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;777      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;778    
;;;779      /* Set PCCARD timing parameters */
;;;780      Device->PATT4 = (uint32_t)((Timing->SetupTime                 |\
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  890b              LDRH     r3,[r1,#8]
00000a  7b09              LDRB     r1,[r1,#0xc]
00000c  041b              LSLS     r3,r3,#16
00000e  ea436101          ORR      r1,r3,r1,LSL #24
000012  430a              ORRS     r2,r2,r1
000014  60c2              STR      r2,[r0,#0xc]
;;;781                                 ((Timing->WaitSetupTime) << 8)     |\
;;;782                                  (Timing->HoldSetupTime) << 16)    |\
;;;783                                  ((Timing->HiZSetupTime) << 24)
;;;784                                 );  
;;;785                                            
;;;786      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;787    }
000018  4770              BX       lr
;;;788    
                          ENDP


                          AREA ||i.FSMC_PCCARD_CommonSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARD_CommonSpace_Timing_Init PROC
;;;745      */
;;;746    HAL_StatusTypeDef FSMC_PCCARD_CommonSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
000000  e9d12300          LDRD     r2,r3,[r1,#0]
;;;747    {
;;;748      /* Check the parameters */
;;;749      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;750      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;751      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;752      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;753    
;;;754      /* Set PCCARD timing parameters */
;;;755      Device->PMEM4 = (uint32_t)((Timing->SetupTime                 |\
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  890b              LDRH     r3,[r1,#8]
00000a  7b09              LDRB     r1,[r1,#0xc]
00000c  041b              LSLS     r3,r3,#16
00000e  ea436101          ORR      r1,r3,r1,LSL #24
000012  430a              ORRS     r2,r2,r1
000014  6082              STR      r2,[r0,#8]
;;;756                                 ((Timing->WaitSetupTime) << 8)     |\
;;;757                                  (Timing->HoldSetupTime) << 16)    |\
;;;758                                  ((Timing->HiZSetupTime) << 24)
;;;759                                 ); 
;;;760    
;;;761      return HAL_OK;  
000016  2000              MOVS     r0,#0
;;;762    }
000018  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.FSMC_PCCARD_DeInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARD_DeInit PROC
;;;818      */
;;;819    HAL_StatusTypeDef FSMC_PCCARD_DeInit(FSMC_PCCARD_TypeDef *Device)
000000  6801              LDR      r1,[r0,#0]
;;;820    {
;;;821      /* Disable the FSMC_PCCARD device */
;;;822      __FSMC_PCCARD_DISABLE(Device);
000002  f0210104          BIC      r1,r1,#4
000006  6001              STR      r1,[r0,#0]
;;;823      
;;;824      /* De-initialize the FSMC_PCCARD device */
;;;825      Device->PCR4    = 0x00000018; 
000008  2118              MOVS     r1,#0x18
00000a  6001              STR      r1,[r0,#0]
;;;826      Device->SR4     = 0x00000000;	
00000c  2100              MOVS     r1,#0
00000e  6041              STR      r1,[r0,#4]
;;;827      Device->PMEM4   = 0xFCFCFCFC;
000010  f04f31fc          MOV      r1,#0xfcfcfcfc
000014  6081              STR      r1,[r0,#8]
;;;828      Device->PATT4   = 0xFCFCFCFC;
000016  60c1              STR      r1,[r0,#0xc]
;;;829      Device->PIO4    = 0xFCFCFCFC;
000018  6101              STR      r1,[r0,#0x10]
;;;830      
;;;831      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;832    }
00001c  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.FSMC_PCCARD_IOSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARD_IOSpace_Timing_Init PROC
;;;795      */
;;;796    HAL_StatusTypeDef FSMC_PCCARD_IOSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
000000  e9d12300          LDRD     r2,r3,[r1,#0]
;;;797    {
;;;798      /* Check the parameters */  
;;;799      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;800      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;801      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;802      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;803    
;;;804      /* Set FSMC_PCCARD device timing parameters */
;;;805      Device->PIO4 = (uint32_t)((Timing->SetupTime                  |\
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  890b              LDRH     r3,[r1,#8]
00000a  7b09              LDRB     r1,[r1,#0xc]
00000c  041b              LSLS     r3,r3,#16
00000e  ea436101          ORR      r1,r3,r1,LSL #24
000012  430a              ORRS     r2,r2,r1
000014  6102              STR      r2,[r0,#0x10]
;;;806                                 ((Timing->WaitSetupTime) << 8)     |\
;;;807                                  (Timing->HoldSetupTime) << 16)    |\
;;;808                                  ((Timing->HiZSetupTime) << 24)
;;;809                                 );   
;;;810      
;;;811      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;812    }
000018  4770              BX       lr
;;;813                                               
                          ENDP


                          AREA ||i.FSMC_PCCARD_Init||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARD_Init PROC
;;;721      */
;;;722    HAL_StatusTypeDef FSMC_PCCARD_Init(FSMC_PCCARD_TypeDef *Device, FSMC_PCCARD_InitTypeDef *Init)
000000  e9d12300          LDRD     r2,r3,[r1,#0]
;;;723    {
;;;724      /* Check the parameters */ 
;;;725      assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
;;;726      assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
;;;727      assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));     
;;;728      
;;;729      /* Set FSMC_PCCARD device control parameters */
;;;730      Device->PCR4 = (uint32_t)(Init->Waitfeature               |\
000004  ea422243          ORR      r2,r2,r3,LSL #9
000008  6889              LDR      r1,[r1,#8]
00000a  2310              MOVS     r3,#0x10
00000c  ea433141          ORR      r1,r3,r1,LSL #13
000010  430a              ORRS     r2,r2,r1
000012  6002              STR      r2,[r0,#0]
;;;731                                FSMC_NAND_PCC_MEM_BUS_WIDTH_16   |\
;;;732                                (Init->TCLRSetupTime << 9)      |\
;;;733                                (Init->TARSetupTime << 13));
;;;734      
;;;735      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;736    
;;;737    }
000016  4770              BX       lr
;;;738    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_ll_fsmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_ll_fsmc_c_26ff9b41____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_ll_fsmc_c_26ff9b41____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_ll_fsmc_c_26ff9b41____REVSH|
#line 144
|__asm___19_stm32f2xx_ll_fsmc_c_26ff9b41____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
