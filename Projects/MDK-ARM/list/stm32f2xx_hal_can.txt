; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_can.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_can.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_can.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_can.c]
                          THUMB

                          AREA ||i.CAN_Receive_IT||, CODE, READONLY, ALIGN=1

                  CAN_Receive_IT PROC
;;;1317     */
;;;1318   static HAL_StatusTypeDef CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
000000  b510              PUSH     {r4,lr}
;;;1319   {
;;;1320     /* Get the Id */
;;;1321     hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
000002  f44f72d8          MOV      r2,#0x1b0
000006  6803              LDR      r3,[r0,#0]
000008  eb021201          ADD      r2,r2,r1,LSL #4
00000c  589b              LDR      r3,[r3,r2]
00000e  f0130404          ANDS     r4,r3,#4
000012  6b43              LDR      r3,[r0,#0x34]
;;;1322     if (hcan->pRxMsg->IDE == CAN_ID_STD)
000014  609c              STR      r4,[r3,#8]
;;;1323     {
;;;1324       hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;1325     }
;;;1326     else
;;;1327     {
;;;1328       hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
000016  6804              LDR      r4,[r0,#0]
000018  6b43              LDR      r3,[r0,#0x34]
00001a  58a4              LDR      r4,[r4,r2]
00001c  d05c              BEQ      |L1.216|
00001e  08e4              LSRS     r4,r4,#3
000020  605c              STR      r4,[r3,#4]
                  |L1.34|
;;;1329     }
;;;1330     
;;;1331     hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
000022  6803              LDR      r3,[r0,#0]
000024  589a              LDR      r2,[r3,r2]
000026  6b43              LDR      r3,[r0,#0x34]
000028  f0020202          AND      r2,r2,#2
;;;1332     /* Get the DLC */
;;;1333     hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
00002c  60da              STR      r2,[r3,#0xc]
00002e  f44f72da          MOV      r2,#0x1b4
000032  6803              LDR      r3,[r0,#0]
000034  eb021201          ADD      r2,r2,r1,LSL #4
000038  589b              LDR      r3,[r3,r2]
00003a  6b44              LDR      r4,[r0,#0x34]
00003c  f003030f          AND      r3,r3,#0xf
;;;1334     /* Get the FMI */
;;;1335     hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
000040  6123              STR      r3,[r4,#0x10]
000042  6803              LDR      r3,[r0,#0]
000044  589a              LDR      r2,[r3,r2]
000046  6b43              LDR      r3,[r0,#0x34]
000048  f3c22207          UBFX     r2,r2,#8,#8
;;;1336     /* Get the data field */
;;;1337     hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
00004c  635a              STR      r2,[r3,#0x34]
00004e  f44f72dc          MOV      r2,#0x1b8
000052  6803              LDR      r3,[r0,#0]
000054  eb021201          ADD      r2,r2,r1,LSL #4
000058  589b              LDR      r3,[r3,r2]
00005a  6b44              LDR      r4,[r0,#0x34]
00005c  b2db              UXTB     r3,r3
;;;1338     hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
00005e  6163              STR      r3,[r4,#0x14]
000060  6803              LDR      r3,[r0,#0]
000062  589b              LDR      r3,[r3,r2]
000064  6b44              LDR      r4,[r0,#0x34]
000066  f3c32307          UBFX     r3,r3,#8,#8
;;;1339     hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
00006a  61a3              STR      r3,[r4,#0x18]
00006c  6803              LDR      r3,[r0,#0]
00006e  589b              LDR      r3,[r3,r2]
000070  6b44              LDR      r4,[r0,#0x34]
000072  f3c34307          UBFX     r3,r3,#16,#8
;;;1340     hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
000076  61e3              STR      r3,[r4,#0x1c]
000078  6803              LDR      r3,[r0,#0]
00007a  589a              LDR      r2,[r3,r2]
00007c  6b43              LDR      r3,[r0,#0x34]
00007e  0e12              LSRS     r2,r2,#24
;;;1341     hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
000080  621a              STR      r2,[r3,#0x20]
000082  f44f72de          MOV      r2,#0x1bc
000086  6803              LDR      r3,[r0,#0]
000088  eb021201          ADD      r2,r2,r1,LSL #4
00008c  589b              LDR      r3,[r3,r2]
00008e  6b44              LDR      r4,[r0,#0x34]
000090  b2db              UXTB     r3,r3
;;;1342     hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
000092  6263              STR      r3,[r4,#0x24]
000094  6803              LDR      r3,[r0,#0]
000096  589b              LDR      r3,[r3,r2]
000098  6b44              LDR      r4,[r0,#0x34]
00009a  f3c32307          UBFX     r3,r3,#8,#8
;;;1343     hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
00009e  62a3              STR      r3,[r4,#0x28]
0000a0  6803              LDR      r3,[r0,#0]
0000a2  589b              LDR      r3,[r3,r2]
0000a4  6b44              LDR      r4,[r0,#0x34]
0000a6  f3c34307          UBFX     r3,r3,#16,#8
;;;1344     hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000aa  62e3              STR      r3,[r4,#0x2c]
0000ac  6803              LDR      r3,[r0,#0]
0000ae  589a              LDR      r2,[r3,r2]
0000b0  6b43              LDR      r3,[r0,#0x34]
0000b2  0e12              LSRS     r2,r2,#24
;;;1345     /* Release the FIFO */
;;;1346     /* Release FIFO0 */
;;;1347     if (FIFONumber == CAN_FIFO0)
0000b4  2900              CMP      r1,#0
0000b6  631a              STR      r2,[r3,#0x30]
0000b8  6801              LDR      r1,[r0,#0]
0000ba  d010              BEQ      |L1.222|
;;;1348     {
;;;1349       __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
;;;1350       
;;;1351       /* Disable FIFO 0 message pending Interrupt */
;;;1352       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP0);
;;;1353     }
;;;1354     /* Release FIFO1 */
;;;1355     else /* FIFONumber == CAN_FIFO1 */
;;;1356     {
;;;1357       __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
0000bc  690a              LDR      r2,[r1,#0x10]
0000be  f0420220          ORR      r2,r2,#0x20
0000c2  610a              STR      r2,[r1,#0x10]
;;;1358       
;;;1359       /* Disable FIFO 1 message pending Interrupt */
;;;1360       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_FMP1);
0000c4  6801              LDR      r1,[r0,#0]
0000c6  694a              LDR      r2,[r1,#0x14]
0000c8  f0220210          BIC      r2,r2,#0x10
                  |L1.204|
0000cc  614a              STR      r2,[r1,#0x14]
;;;1361     }
;;;1362     
;;;1363     if(hcan->State == HAL_CAN_STATE_BUSY_RX)
0000ce  f8901038          LDRB     r1,[r0,#0x38]
0000d2  2922              CMP      r1,#0x22
0000d4  d00c              BEQ      |L1.240|
0000d6  e024              B        |L1.290|
                  |L1.216|
0000d8  0d64              LSRS     r4,r4,#21             ;1324
0000da  601c              STR      r4,[r3,#0]            ;1324
0000dc  e7a1              B        |L1.34|
                  |L1.222|
0000de  68ca              LDR      r2,[r1,#0xc]          ;1349
0000e0  f0420220          ORR      r2,r2,#0x20           ;1349
0000e4  60ca              STR      r2,[r1,#0xc]          ;1349
0000e6  6801              LDR      r1,[r0,#0]            ;1352
0000e8  694a              LDR      r2,[r1,#0x14]         ;1352
0000ea  f0220202          BIC      r2,r2,#2              ;1352
0000ee  e7ed              B        |L1.204|
                  |L1.240|
;;;1364     {   
;;;1365       /* Disable Error warning Interrupt */
;;;1366       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
0000f0  6801              LDR      r1,[r0,#0]
0000f2  694a              LDR      r2,[r1,#0x14]
0000f4  f4227280          BIC      r2,r2,#0x100
0000f8  614a              STR      r2,[r1,#0x14]
;;;1367       
;;;1368       /* Disable Error passive Interrupt */
;;;1369       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
0000fa  6801              LDR      r1,[r0,#0]
0000fc  694a              LDR      r2,[r1,#0x14]
0000fe  f4227200          BIC      r2,r2,#0x200
000102  614a              STR      r2,[r1,#0x14]
;;;1370       
;;;1371       /* Disable Bus-off Interrupt */
;;;1372       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
000104  6801              LDR      r1,[r0,#0]
000106  694a              LDR      r2,[r1,#0x14]
000108  f4226280          BIC      r2,r2,#0x400
00010c  614a              STR      r2,[r1,#0x14]
;;;1373       
;;;1374       /* Disable Last error code Interrupt */
;;;1375       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
00010e  6801              LDR      r1,[r0,#0]
000110  694a              LDR      r2,[r1,#0x14]
000112  f4226200          BIC      r2,r2,#0x800
000116  614a              STR      r2,[r1,#0x14]
;;;1376       
;;;1377       /* Disable Error Interrupt */
;;;1378       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
000118  6801              LDR      r1,[r0,#0]
00011a  694a              LDR      r2,[r1,#0x14]
00011c  f4224200          BIC      r2,r2,#0x8000
000120  614a              STR      r2,[r1,#0x14]
                  |L1.290|
;;;1379     }
;;;1380     
;;;1381     if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
000122  f8901038          LDRB     r1,[r0,#0x38]
000126  2932              CMP      r1,#0x32
000128  d006              BEQ      |L1.312|
;;;1382     {
;;;1383       /* Disable CAN state */
;;;1384       hcan->State = HAL_CAN_STATE_BUSY_TX;
;;;1385     }
;;;1386     else
;;;1387     {
;;;1388       /* Change CAN state */
;;;1389       hcan->State = HAL_CAN_STATE_READY;
00012a  2101              MOVS     r1,#1
                  |L1.300|
00012c  f8801038          STRB     r1,[r0,#0x38]
;;;1390     }
;;;1391   
;;;1392     /* Receive complete callback */ 
;;;1393     HAL_CAN_RxCpltCallback(hcan);
000130  f7fffffe          BL       HAL_CAN_RxCpltCallback
;;;1394   
;;;1395     /* Return function status */
;;;1396     return HAL_OK;
000134  2000              MOVS     r0,#0
;;;1397   }
000136  bd10              POP      {r4,pc}
                  |L1.312|
000138  2112              MOVS     r1,#0x12              ;1384
00013a  e7f7              B        |L1.300|
;;;1398   
                          ENDP


                          AREA ||i.CAN_Transmit_IT||, CODE, READONLY, ALIGN=1

                  CAN_Transmit_IT PROC
;;;1269     */
;;;1270   static HAL_StatusTypeDef CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
000000  b510              PUSH     {r4,lr}
;;;1271   {
;;;1272     /* Disable Transmit mailbox empty Interrupt */
;;;1273     __HAL_CAN_DISABLE_IT(hcan, CAN_IT_TME);
000002  6801              LDR      r1,[r0,#0]
000004  694a              LDR      r2,[r1,#0x14]
000006  f0220201          BIC      r2,r2,#1
00000a  614a              STR      r2,[r1,#0x14]
;;;1274     
;;;1275     if(hcan->State == HAL_CAN_STATE_BUSY_TX)
00000c  f8901038          LDRB     r1,[r0,#0x38]
000010  2912              CMP      r1,#0x12
000012  d118              BNE      |L2.70|
;;;1276     {   
;;;1277       /* Disable Error warning Interrupt */
;;;1278       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EWG);
000014  6801              LDR      r1,[r0,#0]
000016  694a              LDR      r2,[r1,#0x14]
000018  f4227280          BIC      r2,r2,#0x100
00001c  614a              STR      r2,[r1,#0x14]
;;;1279       
;;;1280       /* Disable Error passive Interrupt */
;;;1281       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_EPV);
00001e  6801              LDR      r1,[r0,#0]
000020  694a              LDR      r2,[r1,#0x14]
000022  f4227200          BIC      r2,r2,#0x200
000026  614a              STR      r2,[r1,#0x14]
;;;1282       
;;;1283       /* Disable Bus-off Interrupt */
;;;1284       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_BOF);
000028  6801              LDR      r1,[r0,#0]
00002a  694a              LDR      r2,[r1,#0x14]
00002c  f4226280          BIC      r2,r2,#0x400
000030  614a              STR      r2,[r1,#0x14]
;;;1285       
;;;1286       /* Disable Last error code Interrupt */
;;;1287       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_LEC);
000032  6801              LDR      r1,[r0,#0]
000034  694a              LDR      r2,[r1,#0x14]
000036  f4226200          BIC      r2,r2,#0x800
00003a  614a              STR      r2,[r1,#0x14]
;;;1288       
;;;1289       /* Disable Error Interrupt */
;;;1290       __HAL_CAN_DISABLE_IT(hcan, CAN_IT_ERR);
00003c  6801              LDR      r1,[r0,#0]
00003e  694a              LDR      r2,[r1,#0x14]
000040  f4224200          BIC      r2,r2,#0x8000
000044  614a              STR      r2,[r1,#0x14]
                  |L2.70|
;;;1291     }
;;;1292     
;;;1293     if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
000046  f8901038          LDRB     r1,[r0,#0x38]
00004a  2932              CMP      r1,#0x32
00004c  d006              BEQ      |L2.92|
;;;1294     {
;;;1295       /* Change CAN state */
;;;1296       hcan->State = HAL_CAN_STATE_BUSY_RX;
;;;1297     }
;;;1298     else
;;;1299     {
;;;1300       /* Change CAN state */
;;;1301       hcan->State = HAL_CAN_STATE_READY;
00004e  2101              MOVS     r1,#1
                  |L2.80|
000050  f8801038          STRB     r1,[r0,#0x38]
;;;1302     }
;;;1303     
;;;1304     /* Transmission complete callback */ 
;;;1305     HAL_CAN_TxCpltCallback(hcan);
000054  f7fffffe          BL       HAL_CAN_TxCpltCallback
;;;1306     
;;;1307     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1308   }
00005a  bd10              POP      {r4,pc}
                  |L2.92|
00005c  2122              MOVS     r1,#0x22              ;1296
00005e  e7f7              B        |L2.80|
;;;1309   
                          ENDP


                          AREA ||i.HAL_CAN_ConfigFilter||, CODE, READONLY, ALIGN=2

                  HAL_CAN_ConfigFilter PROC
;;;339      */
;;;340    HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef* hcan, CAN_FilterConfTypeDef* sFilterConfig)
000000  b5f0              PUSH     {r4-r7,lr}
;;;341    {
;;;342      uint32_t filternbrbitpos = 0;
;;;343      
;;;344      /* Check the parameters */
;;;345      assert_param(IS_CAN_FILTER_NUMBER(sFilterConfig->FilterNumber));
;;;346      assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));
;;;347      assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
;;;348      assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
;;;349      assert_param(IS_FUNCTIONAL_STATE(sFilterConfig->FilterActivation));
;;;350      assert_param(IS_CAN_BANKNUMBER(sFilterConfig->BankNumber));
;;;351      
;;;352      filternbrbitpos = ((uint32_t)1) << sFilterConfig->FilterNumber;
000002  7d0a              LDRB     r2,[r1,#0x14]
000004  2001              MOVS     r0,#1
000006  4090              LSLS     r0,r0,r2
;;;353    
;;;354      /* Initialisation mode for the filter */
;;;355      CAN1->FMR |= (uint32_t)CAN_FMR_FINIT;
000008  4a34              LDR      r2,|L3.220|
00000a  6813              LDR      r3,[r2,#0]
00000c  f0430301          ORR      r3,r3,#1
000010  6013              STR      r3,[r2,#0]
;;;356      
;;;357      /* Select the start slave bank */
;;;358      CAN1->FMR &= ~((uint32_t)CAN_FMR_CAN2SB);
000012  6813              LDR      r3,[r2,#0]
000014  f423537c          BIC      r3,r3,#0x3f00
000018  6013              STR      r3,[r2,#0]
;;;359      CAN1->FMR |= (uint32_t)(sFilterConfig->BankNumber << 8);
00001a  6813              LDR      r3,[r2,#0]
00001c  6a4c              LDR      r4,[r1,#0x24]
00001e  ea432304          ORR      r3,r3,r4,LSL #8
000022  6013              STR      r3,[r2,#0]
;;;360         
;;;361      /* Filter Deactivation */
;;;362      CAN1->FA1R &= ~(uint32_t)filternbrbitpos;
000024  4b2d              LDR      r3,|L3.220|
000026  331c              ADDS     r3,r3,#0x1c
000028  681c              LDR      r4,[r3,#0]
00002a  4384              BICS     r4,r4,r0
00002c  601c              STR      r4,[r3,#0]
;;;363    
;;;364      /* Filter Scale */
;;;365      if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
;;;366      {
;;;367        /* 16-bit scale for the filter */
;;;368        CAN1->FS1R &= ~(uint32_t)filternbrbitpos;
00002e  4d2b              LDR      r5,|L3.220|
;;;369    
;;;370        /* First 16-bit identifier and First 16-bit mask */
;;;371        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;372        CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
000030  4c2b              LDR      r4,|L3.224|
000032  69ce              LDR      r6,[r1,#0x1c]         ;341
000034  350c              ADDS     r5,r5,#0xc            ;368
000036  b9a6              CBNZ     r6,|L3.98|
000038  682e              LDR      r6,[r5,#0]            ;368
00003a  4386              BICS     r6,r6,r0              ;368
00003c  602e              STR      r6,[r5,#0]            ;368
00003e  898f              LDRH     r7,[r1,#0xc]
000040  684e              LDR      r6,[r1,#4]
000042  f367461f          BFI      r6,r7,#16,#16
000046  694f              LDR      r7,[r1,#0x14]
000048  eb0407c7          ADD      r7,r4,r7,LSL #3
00004c  f8c76640          STR      r6,[r7,#0x640]
;;;373           ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16) |
;;;374            (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
;;;375    
;;;376        /* Second 16-bit identifier and Second 16-bit mask */
;;;377        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;378        CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
000050  890f              LDRH     r7,[r1,#8]
000052  680e              LDR      r6,[r1,#0]
000054  f367461f          BFI      r6,r7,#16,#16
000058  694f              LDR      r7,[r1,#0x14]
00005a  eb0407c7          ADD      r7,r4,r7,LSL #3
00005e  f8c76644          STR      r6,[r7,#0x644]
                  |L3.98|
;;;379           ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
;;;380            (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh);
;;;381      }
;;;382    
;;;383      if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
000062  69ce              LDR      r6,[r1,#0x1c]
000064  2e01              CMP      r6,#1
000066  d114              BNE      |L3.146|
;;;384      {
;;;385        /* 32-bit scale for the filter */
;;;386        CAN1->FS1R |= filternbrbitpos;
000068  682e              LDR      r6,[r5,#0]
00006a  4306              ORRS     r6,r6,r0
00006c  602e              STR      r6,[r5,#0]
;;;387        /* 32-bit identifier or First 32-bit identifier */
;;;388        CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR1 = 
00006e  880e              LDRH     r6,[r1,#0]
000070  684d              LDR      r5,[r1,#4]
000072  f366451f          BFI      r5,r6,#16,#16
000076  694e              LDR      r6,[r1,#0x14]
000078  eb0406c6          ADD      r6,r4,r6,LSL #3
00007c  f8c65640          STR      r5,[r6,#0x640]
;;;389           ((0x0000FFFF & (uint32_t)sFilterConfig->FilterIdHigh) << 16) |
;;;390            (0x0000FFFF & (uint32_t)sFilterConfig->FilterIdLow);
;;;391        /* 32-bit mask or Second 32-bit identifier */
;;;392        CAN1->sFilterRegister[sFilterConfig->FilterNumber].FR2 = 
000080  890e              LDRH     r6,[r1,#8]
000082  68cd              LDR      r5,[r1,#0xc]
000084  f366451f          BFI      r5,r6,#16,#16
000088  694e              LDR      r6,[r1,#0x14]
00008a  eb0404c6          ADD      r4,r4,r6,LSL #3
00008e  f8c45644          STR      r5,[r4,#0x644]
                  |L3.146|
;;;393           ((0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16) |
;;;394            (0x0000FFFF & (uint32_t)sFilterConfig->FilterMaskIdLow);
;;;395      }
;;;396    
;;;397      /* Filter Mode */
;;;398      if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
;;;399      {
;;;400        /*Id/Mask mode for the filter*/
;;;401        CAN1->FM1R &= ~(uint32_t)filternbrbitpos;
000092  4c12              LDR      r4,|L3.220|
000094  698d              LDR      r5,[r1,#0x18]         ;398
000096  1d24              ADDS     r4,r4,#4
000098  2d00              CMP      r5,#0                 ;398
;;;402      }
;;;403      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;404      {
;;;405        /*Identifier list mode for the filter*/
;;;406        CAN1->FM1R |= (uint32_t)filternbrbitpos;
00009a  6825              LDR      r5,[r4,#0]
00009c  d006              BEQ      |L3.172|
00009e  4305              ORRS     r5,r5,r0
                  |L3.160|
0000a0  6025              STR      r5,[r4,#0]
;;;407      }
;;;408    
;;;409      /* Filter FIFO assignment */
;;;410      if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
;;;411      {
;;;412        /* FIFO 0 assignation for the filter */
;;;413        CAN1->FFA1R &= ~(uint32_t)filternbrbitpos;
0000a2  4c0e              LDR      r4,|L3.220|
0000a4  690d              LDR      r5,[r1,#0x10]
0000a6  3414              ADDS     r4,r4,#0x14
0000a8  b115              CBZ      r5,|L3.176|
0000aa  e004              B        |L3.182|
                  |L3.172|
0000ac  4385              BICS     r5,r5,r0              ;401
0000ae  e7f7              B        |L3.160|
                  |L3.176|
0000b0  6825              LDR      r5,[r4,#0]
0000b2  4385              BICS     r5,r5,r0
0000b4  6025              STR      r5,[r4,#0]
                  |L3.182|
;;;414      }
;;;415    
;;;416      if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO1)
0000b6  690d              LDR      r5,[r1,#0x10]
0000b8  2d01              CMP      r5,#1
0000ba  d102              BNE      |L3.194|
;;;417      {
;;;418        /* FIFO 1 assignation for the filter */
;;;419        CAN1->FFA1R |= (uint32_t)filternbrbitpos;
0000bc  6825              LDR      r5,[r4,#0]
0000be  4305              ORRS     r5,r5,r0
0000c0  6025              STR      r5,[r4,#0]
                  |L3.194|
;;;420      }
;;;421      
;;;422      /* Filter activation */
;;;423      if (sFilterConfig->FilterActivation == ENABLE)
0000c2  6a09              LDR      r1,[r1,#0x20]
0000c4  2901              CMP      r1,#1
0000c6  d102              BNE      |L3.206|
;;;424      {
;;;425        CAN1->FA1R |= filternbrbitpos;
0000c8  6819              LDR      r1,[r3,#0]
0000ca  4301              ORRS     r1,r1,r0
0000cc  6019              STR      r1,[r3,#0]
                  |L3.206|
;;;426      }
;;;427    
;;;428      /* Leave the initialisation mode for the filter */
;;;429      CAN1->FMR &= ~((uint32_t)CAN_FMR_FINIT);
0000ce  6810              LDR      r0,[r2,#0]
0000d0  f0200001          BIC      r0,r0,#1
0000d4  6010              STR      r0,[r2,#0]
;;;430      
;;;431      /* Return function status */
;;;432      return HAL_OK;
0000d6  2000              MOVS     r0,#0
;;;433    }
0000d8  bdf0              POP      {r4-r7,pc}
;;;434    
                          ENDP

0000da  0000              DCW      0x0000
                  |L3.220|
                          DCD      0x40006600
                  |L3.224|
                          DCD      0x40006000

                          AREA ||i.HAL_CAN_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_DeInit PROC
;;;440      */
;;;441    HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef* hcan)
000000  b510              PUSH     {r4,lr}
;;;442    {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L4.28|
;;;443      /* Check CAN handle */
;;;444      if(hcan == NULL)
;;;445      {
;;;446         return HAL_ERROR;
;;;447      }
;;;448      
;;;449      /* Check the parameters */
;;;450      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;451      
;;;452      /* Change CAN state */
;;;453      hcan->State = HAL_CAN_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  f8840038          STRB     r0,[r4,#0x38]
;;;454      
;;;455      /* DeInit the low level hardware */
;;;456      HAL_CAN_MspDeInit(hcan);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_CAN_MspDeInit
;;;457      
;;;458      /* Change CAN state */
;;;459      hcan->State = HAL_CAN_STATE_RESET;
000012  2000              MOVS     r0,#0
000014  f8040f38          STRB     r0,[r4,#0x38]!
;;;460    
;;;461      /* Release Lock */
;;;462      __HAL_UNLOCK(hcan);
000018  7060              STRB     r0,[r4,#1]
;;;463    
;;;464      /* Return function status */
;;;465      return HAL_OK;
;;;466    }
00001a  bd10              POP      {r4,pc}
                  |L4.28|
00001c  2001              MOVS     r0,#1                 ;446
00001e  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.HAL_CAN_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ErrorCallback PROC
;;;1210     */
;;;1211   __weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;1212   {
;;;1213     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1214               the HAL_CAN_ErrorCallback could be implemented in the user file
;;;1215      */
;;;1216   }
;;;1217   
                          ENDP


                          AREA ||i.HAL_CAN_GetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetError PROC
;;;1255     */
;;;1256   uint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;1257   {
;;;1258     return hcan->ErrorCode;
;;;1259   }
000002  4770              BX       lr
;;;1260   
                          ENDP


                          AREA ||i.HAL_CAN_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetState PROC
;;;1243     */
;;;1244   HAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef* hcan)
000000  f8900038          LDRB     r0,[r0,#0x38]
;;;1245   {
;;;1246     /* Return CAN state */
;;;1247     return hcan->State;
;;;1248   }
000004  4770              BX       lr
;;;1249   
                          ENDP


                          AREA ||i.HAL_CAN_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_CAN_IRQHandler PROC
;;;1056     */
;;;1057   void HAL_CAN_IRQHandler(CAN_HandleTypeDef* hcan)
000000  b510              PUSH     {r4,lr}
;;;1058   {
000002  4604              MOV      r4,r0
;;;1059     uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
;;;1060     
;;;1061     /* Check End of transmission flag */
;;;1062     if(__HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_TME))
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  43c9              MVNS     r1,r1
00000a  07c9              LSLS     r1,r1,#31
00000c  d114              BNE      |L8.56|
;;;1063     {
;;;1064       tmp1 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_0);
00000e  6882              LDR      r2,[r0,#8]
000010  495f              LDR      r1,|L8.400|
000012  4391              BICS     r1,r1,r2
000014  d07a              BEQ      |L8.268|
000016  2100              MOVS     r1,#0
                  |L8.24|
;;;1065       tmp2 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_1);
000018  6883              LDR      r3,[r0,#8]
00001a  4a5e              LDR      r2,|L8.404|
00001c  439a              BICS     r2,r2,r3
00001e  d077              BEQ      |L8.272|
000020  2200              MOVS     r2,#0
                  |L8.34|
;;;1066       tmp3 = __HAL_CAN_TRANSMIT_STATUS(hcan, CAN_TXMAILBOX_2);
000022  6883              LDR      r3,[r0,#8]
000024  485c              LDR      r0,|L8.408|
000026  4398              BICS     r0,r0,r3
000028  d074              BEQ      |L8.276|
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;1067       if(tmp1 || tmp2 || tmp3)  
00002c  4311              ORRS     r1,r1,r2
00002e  4301              ORRS     r1,r1,r0
000030  d002              BEQ      |L8.56|
;;;1068       {
;;;1069         /* Call transmit function */
;;;1070         CAN_Transmit_IT(hcan);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       CAN_Transmit_IT
                  |L8.56|
;;;1071       }
;;;1072     }
;;;1073     
;;;1074     tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO0);
000038  6821              LDR      r1,[r4,#0]
00003a  68c8              LDR      r0,[r1,#0xc]
;;;1075     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP0);
00003c  6949              LDR      r1,[r1,#0x14]
00003e  f0100f03          TST      r0,#3                 ;1074
000042  f3c10140          UBFX     r1,r1,#1,#1
;;;1076     /* Check End of reception flag for FIFO0 */
;;;1077     if((tmp1 != 0) && tmp2)
000046  d004              BEQ      |L8.82|
000048  b119              CBZ      r1,|L8.82|
;;;1078     {
;;;1079       /* Call receive function */
;;;1080       CAN_Receive_IT(hcan, CAN_FIFO0);
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       CAN_Receive_IT
                  |L8.82|
;;;1081     }
;;;1082     
;;;1083     tmp1 = __HAL_CAN_MSG_PENDING(hcan, CAN_FIFO1);
000052  6820              LDR      r0,[r4,#0]
000054  6901              LDR      r1,[r0,#0x10]
;;;1084     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_FMP1);
000056  6940              LDR      r0,[r0,#0x14]
000058  f0110f03          TST      r1,#3                 ;1083
00005c  f3c01000          UBFX     r0,r0,#4,#1
;;;1085     /* Check End of reception flag for FIFO1 */
;;;1086     if((tmp1 != 0) && tmp2)
000060  d004              BEQ      |L8.108|
000062  b118              CBZ      r0,|L8.108|
;;;1087     {
;;;1088       /* Call receive function */
;;;1089       CAN_Receive_IT(hcan, CAN_FIFO1);
000064  2101              MOVS     r1,#1
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       CAN_Receive_IT
                  |L8.108|
;;;1090     }
;;;1091     
;;;1092     tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EWG);
00006c  6820              LDR      r0,[r4,#0]
00006e  6981              LDR      r1,[r0,#0x18]
;;;1093     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EWG);
000070  6942              LDR      r2,[r0,#0x14]
000072  f0110f01          TST      r1,#1                 ;1092
;;;1094     tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
000076  6943              LDR      r3,[r0,#0x14]
000078  f3c22200          UBFX     r2,r2,#8,#1           ;1093
00007c  f3c333c0          UBFX     r3,r3,#15,#1
;;;1095     /* Check Error Warning Flag */
;;;1096     if(tmp1 && tmp2 && tmp3)
000080  d009              BEQ      |L8.150|
000082  b142              CBZ      r2,|L8.150|
000084  b13b              CBZ      r3,|L8.150|
;;;1097     {
;;;1098       /* Set CAN error code to EWG error */
;;;1099       hcan->ErrorCode |= HAL_CAN_ERROR_EWG;
000086  6be1              LDR      r1,[r4,#0x3c]
000088  f0410101          ORR      r1,r1,#1
00008c  63e1              STR      r1,[r4,#0x3c]
;;;1100       /* Clear Error Warning Flag */ 
;;;1101       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EWG);
00008e  6981              LDR      r1,[r0,#0x18]
000090  f0210101          BIC      r1,r1,#1
000094  6181              STR      r1,[r0,#0x18]
                  |L8.150|
;;;1102     }
;;;1103     
;;;1104     tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_EPV);
000096  6820              LDR      r0,[r4,#0]
000098  6981              LDR      r1,[r0,#0x18]
;;;1105     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_EPV);
00009a  6942              LDR      r2,[r0,#0x14]
00009c  f3c10140          UBFX     r1,r1,#1,#1           ;1104
;;;1106     tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR); 
0000a0  6943              LDR      r3,[r0,#0x14]
0000a2  f3c22240          UBFX     r2,r2,#9,#1           ;1105
0000a6  f3c333c0          UBFX     r3,r3,#15,#1
;;;1107     /* Check Error Passive Flag */
;;;1108     if(tmp1 && tmp2 && tmp3)
0000aa  b149              CBZ      r1,|L8.192|
0000ac  b142              CBZ      r2,|L8.192|
0000ae  b13b              CBZ      r3,|L8.192|
;;;1109     {
;;;1110       /* Set CAN error code to EPV error */
;;;1111       hcan->ErrorCode |= HAL_CAN_ERROR_EPV;
0000b0  6be1              LDR      r1,[r4,#0x3c]
0000b2  f0410102          ORR      r1,r1,#2
0000b6  63e1              STR      r1,[r4,#0x3c]
;;;1112       /* Clear Error Passive Flag */ 
;;;1113       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_EPV);
0000b8  6981              LDR      r1,[r0,#0x18]
0000ba  f0210102          BIC      r1,r1,#2
0000be  6181              STR      r1,[r0,#0x18]
                  |L8.192|
;;;1114     }
;;;1115     
;;;1116     tmp1 = __HAL_CAN_GET_FLAG(hcan, CAN_FLAG_BOF);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6981              LDR      r1,[r0,#0x18]
;;;1117     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_BOF);
0000c4  6942              LDR      r2,[r0,#0x14]
0000c6  f3c10180          UBFX     r1,r1,#2,#1           ;1116
;;;1118     tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);  
0000ca  6943              LDR      r3,[r0,#0x14]
0000cc  f3c22280          UBFX     r2,r2,#10,#1          ;1117
0000d0  f3c333c0          UBFX     r3,r3,#15,#1
;;;1119     /* Check Bus-Off Flag */
;;;1120     if(tmp1 && tmp2 && tmp3)
0000d4  b149              CBZ      r1,|L8.234|
0000d6  b142              CBZ      r2,|L8.234|
0000d8  b13b              CBZ      r3,|L8.234|
;;;1121     {
;;;1122       /* Set CAN error code to BOF error */
;;;1123       hcan->ErrorCode |= HAL_CAN_ERROR_BOF;
0000da  6be1              LDR      r1,[r4,#0x3c]
0000dc  f0410104          ORR      r1,r1,#4
0000e0  63e1              STR      r1,[r4,#0x3c]
;;;1124       /* Clear Bus-Off Flag */ 
;;;1125       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_BOF);
0000e2  6981              LDR      r1,[r0,#0x18]
0000e4  f0210104          BIC      r1,r1,#4
0000e8  6181              STR      r1,[r0,#0x18]
                  |L8.234|
;;;1126     }
;;;1127     
;;;1128     tmp1 = HAL_IS_BIT_CLR(hcan->Instance->ESR, CAN_ESR_LEC);
0000ea  6820              LDR      r0,[r4,#0]
0000ec  6981              LDR      r1,[r0,#0x18]
0000ee  f0110f70          TST      r1,#0x70
0000f2  d011              BEQ      |L8.280|
0000f4  2300              MOVS     r3,#0
                  |L8.246|
;;;1129     tmp2 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_LEC);
0000f6  6941              LDR      r1,[r0,#0x14]
0000f8  f3c122c0          UBFX     r2,r1,#11,#1
;;;1130     tmp3 = __HAL_CAN_GET_IT_SOURCE(hcan, CAN_IT_ERR);
0000fc  6941              LDR      r1,[r0,#0x14]
0000fe  f3c131c0          UBFX     r1,r1,#15,#1
;;;1131     /* Check Last error code Flag */
;;;1132     if((!tmp1) && tmp2 && tmp3)
000102  b15b              CBZ      r3,|L8.284|
000104  e02a              B        |L8.348|
000106  e001              B        |L8.268|
000108  e002              B        |L8.272|
00010a  e003              B        |L8.276|
                  |L8.268|
00010c  2101              MOVS     r1,#1                 ;1064
00010e  e783              B        |L8.24|
                  |L8.272|
000110  2201              MOVS     r2,#1                 ;1065
000112  e786              B        |L8.34|
                  |L8.276|
000114  2001              MOVS     r0,#1                 ;1066
000116  e789              B        |L8.44|
                  |L8.280|
000118  2301              MOVS     r3,#1                 ;1128
00011a  e7ec              B        |L8.246|
                  |L8.284|
00011c  b1f2              CBZ      r2,|L8.348|
00011e  b1e9              CBZ      r1,|L8.348|
;;;1133     {
;;;1134       tmp1 = (hcan->Instance->ESR) & CAN_ESR_LEC;
000120  6981              LDR      r1,[r0,#0x18]
000122  f0010170          AND      r1,r1,#0x70
;;;1135       switch(tmp1)
000126  2940              CMP      r1,#0x40
000128  d026              BEQ      |L8.376|
00012a  dc06              BGT      |L8.314|
00012c  2910              CMP      r1,#0x10
00012e  d009              BEQ      |L8.324|
000130  2920              CMP      r1,#0x20
000132  d00b              BEQ      |L8.332|
000134  2930              CMP      r1,#0x30
000136  d10d              BNE      |L8.340|
000138  e01a              B        |L8.368|
                  |L8.314|
00013a  2950              CMP      r1,#0x50
00013c  d020              BEQ      |L8.384|
00013e  2960              CMP      r1,#0x60
000140  d108              BNE      |L8.340|
000142  e021              B        |L8.392|
                  |L8.324|
;;;1136       {
;;;1137         case(CAN_ESR_LEC_0):
;;;1138             /* Set CAN error code to STF error */
;;;1139             hcan->ErrorCode |= HAL_CAN_ERROR_STF;
000144  6be1              LDR      r1,[r4,#0x3c]
000146  f0410108          ORR      r1,r1,#8
;;;1140             break;
00014a  e002              B        |L8.338|
                  |L8.332|
;;;1141         case(CAN_ESR_LEC_1):
;;;1142             /* Set CAN error code to FOR error */
;;;1143             hcan->ErrorCode |= HAL_CAN_ERROR_FOR;
00014c  6be1              LDR      r1,[r4,#0x3c]
00014e  f0410110          ORR      r1,r1,#0x10
                  |L8.338|
000152  63e1              STR      r1,[r4,#0x3c]         ;1139
                  |L8.340|
;;;1144             break;
;;;1145         case(CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
;;;1146             /* Set CAN error code to ACK error */
;;;1147             hcan->ErrorCode |= HAL_CAN_ERROR_ACK;
;;;1148             break;
;;;1149         case(CAN_ESR_LEC_2):
;;;1150             /* Set CAN error code to BR error */
;;;1151             hcan->ErrorCode |= HAL_CAN_ERROR_BR;
;;;1152             break;
;;;1153         case(CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
;;;1154             /* Set CAN error code to BD error */
;;;1155             hcan->ErrorCode |= HAL_CAN_ERROR_BD;
;;;1156             break;
;;;1157         case(CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
;;;1158             /* Set CAN error code to CRC error */
;;;1159             hcan->ErrorCode |= HAL_CAN_ERROR_CRC;
;;;1160             break;
;;;1161         default:
;;;1162             break;
;;;1163       }
;;;1164   
;;;1165       /* Clear Last error code Flag */ 
;;;1166       hcan->Instance->ESR &= ~(CAN_ESR_LEC);
000154  6981              LDR      r1,[r0,#0x18]
000156  f0210170          BIC      r1,r1,#0x70
00015a  6181              STR      r1,[r0,#0x18]
                  |L8.348|
;;;1167     }
;;;1168     
;;;1169     /* Call the Error call Back in case of Errors */
;;;1170     if(hcan->ErrorCode != HAL_CAN_ERROR_NONE)
00015c  6be0              LDR      r0,[r4,#0x3c]
00015e  2800              CMP      r0,#0
000160  d005              BEQ      |L8.366|
;;;1171     {
;;;1172       /* Set the CAN state ready to be able to start again the process */
;;;1173       hcan->State = HAL_CAN_STATE_READY;
000162  2001              MOVS     r0,#1
000164  f8840038          STRB     r0,[r4,#0x38]
;;;1174       /* Call Error callback function */
;;;1175       HAL_CAN_ErrorCallback(hcan);
000168  4620              MOV      r0,r4
00016a  f7fffffe          BL       HAL_CAN_ErrorCallback
                  |L8.366|
;;;1176     }  
;;;1177   }
00016e  bd10              POP      {r4,pc}
                  |L8.368|
000170  6be1              LDR      r1,[r4,#0x3c]         ;1147
000172  f0410120          ORR      r1,r1,#0x20           ;1147
000176  e7ec              B        |L8.338|
                  |L8.376|
000178  6be1              LDR      r1,[r4,#0x3c]         ;1151
00017a  f0410140          ORR      r1,r1,#0x40           ;1151
00017e  e7e8              B        |L8.338|
                  |L8.384|
000180  6be1              LDR      r1,[r4,#0x3c]         ;1155
000182  f0410180          ORR      r1,r1,#0x80           ;1155
000186  e7e4              B        |L8.338|
                  |L8.392|
000188  6be1              LDR      r1,[r4,#0x3c]         ;1159
00018a  f4417180          ORR      r1,r1,#0x100          ;1159
00018e  e7e0              B        |L8.338|
;;;1178   
                          ENDP

                  |L8.400|
                          DCD      0x04000003
                  |L8.404|
                          DCD      0x08000300
                  |L8.408|
                          DCD      0x10030000

                          AREA ||i.HAL_CAN_Init||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Init PROC
;;;150      */
;;;151    HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef* hcan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;152    {
000004  0004              MOVS     r4,r0
000006  d003              BEQ      |L9.16|
;;;153      uint32_t InitStatus = 3;
;;;154      uint32_t timeout = 0;
;;;155      
;;;156      /* Check CAN handle */
;;;157      if(hcan == NULL)
;;;158      {
;;;159         return HAL_ERROR;
;;;160      }
;;;161      
;;;162      /* Check the parameters */
;;;163      assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;164      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TTCM));
;;;165      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ABOM));
;;;166      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AWUM));
;;;167      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.NART));
;;;168      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.RFLM));
;;;169      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TXFP));
;;;170      assert_param(IS_CAN_MODE(hcan->Init.Mode));
;;;171      assert_param(IS_CAN_SJW(hcan->Init.SJW));
;;;172      assert_param(IS_CAN_BS1(hcan->Init.BS1));
;;;173      assert_param(IS_CAN_BS2(hcan->Init.BS2));
;;;174      assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
;;;175      
;;;176    
;;;177      if(hcan->State == HAL_CAN_STATE_RESET)
000008  f8940038          LDRB     r0,[r4,#0x38]
00000c  b118              CBZ      r0,|L9.22|
00000e  e005              B        |L9.28|
                  |L9.16|
000010  2001              MOVS     r0,#1                 ;159
                  |L9.18|
;;;178      {    
;;;179        /* Init the low level hardware */
;;;180        HAL_CAN_MspInit(hcan);
;;;181      }
;;;182      
;;;183      /* Initialize the CAN state*/
;;;184      hcan->State = HAL_CAN_STATE_BUSY;
;;;185      
;;;186      /* Exit from sleep mode */
;;;187      hcan->Instance->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
;;;188    
;;;189      /* Request initialisation */
;;;190      hcan->Instance->MCR |= CAN_MCR_INRQ ;
;;;191      
;;;192      /* Get timeout */
;;;193      timeout = HAL_GetTick() + 10;   
;;;194      
;;;195      /* Wait the acknowledge */
;;;196      while((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
;;;197      {
;;;198        if(HAL_GetTick() >= timeout)
;;;199        {
;;;200          hcan->State= HAL_CAN_STATE_TIMEOUT;
;;;201          /* Process unlocked */
;;;202          __HAL_UNLOCK(hcan);
;;;203          return HAL_TIMEOUT;
;;;204        }
;;;205      }
;;;206    
;;;207      /* Check acknowledge */
;;;208      if ((hcan->Instance->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
;;;209      {
;;;210        InitStatus = CAN_INITSTATUS_FAILED;
;;;211      }
;;;212      else 
;;;213      {
;;;214        /* Set the time triggered communication mode */
;;;215        if (hcan->Init.TTCM == ENABLE)
;;;216        {
;;;217          hcan->Instance->MCR |= CAN_MCR_TTCM;
;;;218        }
;;;219        else
;;;220        {
;;;221          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TTCM;
;;;222        }
;;;223    
;;;224        /* Set the automatic bus-off management */
;;;225        if (hcan->Init.ABOM == ENABLE)
;;;226        {
;;;227          hcan->Instance->MCR |= CAN_MCR_ABOM;
;;;228        }
;;;229        else
;;;230        {
;;;231          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_ABOM;
;;;232        }
;;;233    
;;;234        /* Set the automatic wake-up mode */
;;;235        if (hcan->Init.AWUM == ENABLE)
;;;236        {
;;;237          hcan->Instance->MCR |= CAN_MCR_AWUM;
;;;238        }
;;;239        else
;;;240        {
;;;241          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_AWUM;
;;;242        }
;;;243    
;;;244        /* Set the no automatic retransmission */
;;;245        if (hcan->Init.NART == ENABLE)
;;;246        {
;;;247          hcan->Instance->MCR |= CAN_MCR_NART;
;;;248        }
;;;249        else
;;;250        {
;;;251          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_NART;
;;;252        }
;;;253    
;;;254        /* Set the receive FIFO locked mode */
;;;255        if (hcan->Init.RFLM == ENABLE)
;;;256        {
;;;257          hcan->Instance->MCR |= CAN_MCR_RFLM;
;;;258        }
;;;259        else
;;;260        {
;;;261          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_RFLM;
;;;262        }
;;;263    
;;;264        /* Set the transmit FIFO priority */
;;;265        if (hcan->Init.TXFP == ENABLE)
;;;266        {
;;;267          hcan->Instance->MCR |= CAN_MCR_TXFP;
;;;268        }
;;;269        else
;;;270        {
;;;271          hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_TXFP;
;;;272        }
;;;273    
;;;274        /* Set the bit timing register */
;;;275        hcan->Instance->BTR = (uint32_t)((uint32_t)hcan->Init.Mode) | \
;;;276                    ((uint32_t)hcan->Init.SJW) | \
;;;277                    ((uint32_t)hcan->Init.BS1) | \
;;;278                    ((uint32_t)hcan->Init.BS2) | \
;;;279                   ((uint32_t)hcan->Init.Prescaler - 1);
;;;280    
;;;281        /* Request leave initialisation */
;;;282        hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_INRQ;
;;;283    
;;;284        /* Get timeout */
;;;285        timeout = HAL_GetTick() + 10;   
;;;286       
;;;287       /* Wait the acknowledge */
;;;288       while((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
;;;289       {
;;;290         if(HAL_GetTick() >= timeout)
;;;291         {
;;;292           hcan->State= HAL_CAN_STATE_TIMEOUT;
;;;293           /* Process unlocked */
;;;294           __HAL_UNLOCK(hcan);
;;;295           return HAL_TIMEOUT;
;;;296         }
;;;297       }
;;;298    
;;;299        /* Check acknowledged */
;;;300        if ((hcan->Instance->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
;;;301        {
;;;302          InitStatus = CAN_INITSTATUS_FAILED;
;;;303        }
;;;304        else
;;;305        {
;;;306          InitStatus = CAN_INITSTATUS_SUCCESS;
;;;307        }
;;;308      }
;;;309     
;;;310      if(InitStatus == CAN_INITSTATUS_SUCCESS)
;;;311      {
;;;312        /* Set CAN error code to none */
;;;313        hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;314        
;;;315        /* Initialize the CAN state */
;;;316        hcan->State = HAL_CAN_STATE_READY;
;;;317      
;;;318        /* Return function status */
;;;319        return HAL_OK;
;;;320      }
;;;321      else
;;;322      {
;;;323        /* Initialize the CAN state */
;;;324        hcan->State = HAL_CAN_STATE_ERROR;
;;;325        
;;;326        /* Return function status */
;;;327        return HAL_ERROR;
;;;328      }
;;;329    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L9.22|
000016  4620              MOV      r0,r4                 ;180
000018  f7fffffe          BL       HAL_CAN_MspInit
                  |L9.28|
00001c  2002              MOVS     r0,#2                 ;184
00001e  f8840038          STRB     r0,[r4,#0x38]         ;184
000022  6820              LDR      r0,[r4,#0]            ;187
000024  6801              LDR      r1,[r0,#0]            ;187
000026  f0210102          BIC      r1,r1,#2              ;187
00002a  6001              STR      r1,[r0,#0]            ;187
00002c  6820              LDR      r0,[r4,#0]            ;190
00002e  6801              LDR      r1,[r0,#0]            ;190
000030  f0410101          ORR      r1,r1,#1              ;190
000034  6001              STR      r1,[r0,#0]            ;190
000036  f7fffffe          BL       HAL_GetTick
00003a  2500              MOVS     r5,#0                 ;193
00003c  f100070a          ADD      r7,r0,#0xa            ;193
000040  2603              MOVS     r6,#3                 ;153
000042  e003              B        |L9.76|
                  |L9.68|
000044  f7fffffe          BL       HAL_GetTick
000048  42b8              CMP      r0,r7                 ;198
00004a  d263              BCS      |L9.276|
                  |L9.76|
00004c  6820              LDR      r0,[r4,#0]            ;196
00004e  6840              LDR      r0,[r0,#4]            ;196
000050  07c0              LSLS     r0,r0,#31             ;196
000052  d0f7              BEQ      |L9.68|
000054  6820              LDR      r0,[r4,#0]            ;208
000056  6841              LDR      r1,[r0,#4]            ;208
000058  07c9              LSLS     r1,r1,#31             ;208
00005a  d068              BEQ      |L9.302|
00005c  69a1              LDR      r1,[r4,#0x18]         ;215
00005e  2901              CMP      r1,#1                 ;215
000060  6801              LDR      r1,[r0,#0]            ;221
000062  d040              BEQ      |L9.230|
000064  f0210180          BIC      r1,r1,#0x80           ;221
                  |L9.104|
000068  6001              STR      r1,[r0,#0]            ;221
00006a  69e0              LDR      r0,[r4,#0x1c]         ;225
00006c  2801              CMP      r0,#1                 ;225
00006e  6820              LDR      r0,[r4,#0]            ;231
000070  6801              LDR      r1,[r0,#0]            ;231
000072  d03b              BEQ      |L9.236|
000074  f0210140          BIC      r1,r1,#0x40           ;231
                  |L9.120|
000078  6001              STR      r1,[r0,#0]            ;231
00007a  6a20              LDR      r0,[r4,#0x20]         ;235
00007c  2801              CMP      r0,#1                 ;235
00007e  6820              LDR      r0,[r4,#0]            ;241
000080  6801              LDR      r1,[r0,#0]            ;241
000082  d036              BEQ      |L9.242|
000084  f0210120          BIC      r1,r1,#0x20           ;241
                  |L9.136|
000088  6001              STR      r1,[r0,#0]            ;241
00008a  6a60              LDR      r0,[r4,#0x24]         ;245
00008c  2801              CMP      r0,#1                 ;245
00008e  6820              LDR      r0,[r4,#0]            ;251
000090  6801              LDR      r1,[r0,#0]            ;251
000092  d031              BEQ      |L9.248|
000094  f0210110          BIC      r1,r1,#0x10           ;251
                  |L9.152|
000098  6001              STR      r1,[r0,#0]            ;251
00009a  6aa0              LDR      r0,[r4,#0x28]         ;255
00009c  2801              CMP      r0,#1                 ;255
00009e  6820              LDR      r0,[r4,#0]            ;261
0000a0  6801              LDR      r1,[r0,#0]            ;261
0000a2  d02c              BEQ      |L9.254|
0000a4  f0210108          BIC      r1,r1,#8              ;261
                  |L9.168|
0000a8  6001              STR      r1,[r0,#0]            ;261
0000aa  6ae0              LDR      r0,[r4,#0x2c]         ;265
0000ac  2801              CMP      r0,#1                 ;265
0000ae  6820              LDR      r0,[r4,#0]            ;271
0000b0  6801              LDR      r1,[r0,#0]            ;271
0000b2  d027              BEQ      |L9.260|
0000b4  f0210104          BIC      r1,r1,#4              ;271
                  |L9.184|
0000b8  6001              STR      r1,[r0,#0]            ;271
0000ba  e9d40102          LDRD     r0,r1,[r4,#8]         ;271
0000be  4308              ORRS     r0,r0,r1              ;275
0000c0  e9d41204          LDRD     r1,r2,[r4,#0x10]      ;275
0000c4  4311              ORRS     r1,r1,r2              ;275
0000c6  4308              ORRS     r0,r0,r1              ;275
0000c8  6861              LDR      r1,[r4,#4]            ;275
0000ca  1e49              SUBS     r1,r1,#1              ;275
0000cc  4308              ORRS     r0,r0,r1              ;275
0000ce  6821              LDR      r1,[r4,#0]            ;275
0000d0  61c8              STR      r0,[r1,#0x1c]         ;275
0000d2  6820              LDR      r0,[r4,#0]            ;282
0000d4  6801              LDR      r1,[r0,#0]            ;282
0000d6  f0210101          BIC      r1,r1,#1              ;282
0000da  6001              STR      r1,[r0,#0]            ;282
0000dc  f7fffffe          BL       HAL_GetTick
0000e0  f100070a          ADD      r7,r0,#0xa            ;285
0000e4  e01b              B        |L9.286|
                  |L9.230|
0000e6  f0410180          ORR      r1,r1,#0x80           ;217
0000ea  e7bd              B        |L9.104|
                  |L9.236|
0000ec  f0410140          ORR      r1,r1,#0x40           ;227
0000f0  e7c2              B        |L9.120|
                  |L9.242|
0000f2  f0410120          ORR      r1,r1,#0x20           ;237
0000f6  e7c7              B        |L9.136|
                  |L9.248|
0000f8  f0410110          ORR      r1,r1,#0x10           ;247
0000fc  e7cc              B        |L9.152|
                  |L9.254|
0000fe  f0410108          ORR      r1,r1,#8              ;257
000102  e7d1              B        |L9.168|
                  |L9.260|
000104  f0410104          ORR      r1,r1,#4              ;267
000108  e7d6              B        |L9.184|
00010a  bf00              NOP                            ;290
                  |L9.268|
00010c  f7fffffe          BL       HAL_GetTick
000110  42b8              CMP      r0,r7                 ;290
000112  d304              BCC      |L9.286|
                  |L9.276|
000114  f8046f38          STRB     r6,[r4,#0x38]!        ;292
000118  2003              MOVS     r0,#3                 ;295
00011a  7065              STRB     r5,[r4,#1]            ;294
00011c  e779              B        |L9.18|
                  |L9.286|
00011e  6820              LDR      r0,[r4,#0]            ;288
000120  6840              LDR      r0,[r0,#4]            ;288
000122  07c0              LSLS     r0,r0,#31             ;288
000124  d1f2              BNE      |L9.268|
000126  6820              LDR      r0,[r4,#0]            ;300
000128  6840              LDR      r0,[r0,#4]            ;300
00012a  07c0              LSLS     r0,r0,#31             ;300
00012c  d003              BEQ      |L9.310|
                  |L9.302|
00012e  2004              MOVS     r0,#4                 ;324
000130  f8840038          STRB     r0,[r4,#0x38]         ;324
000134  e76c              B        |L9.16|
                  |L9.310|
000136  63e5              STR      r5,[r4,#0x3c]         ;313
000138  2001              MOVS     r0,#1                 ;316
00013a  f8840038          STRB     r0,[r4,#0x38]         ;316
00013e  2000              MOVS     r0,#0                 ;319
000140  e767              B        |L9.18|
;;;330    
                          ENDP


                          AREA ||i.HAL_CAN_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspDeInit PROC
;;;486      */
;;;487    __weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef* hcan)
000000  4770              BX       lr
;;;488    {
;;;489      /* NOTE : This function Should not be modified, when the callback is needed,
;;;490                the HAL_CAN_MspDeInit could be implemented in the user file
;;;491       */ 
;;;492    }
;;;493    
                          ENDP


                          AREA ||i.HAL_CAN_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspInit PROC
;;;473      */
;;;474    __weak void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
000000  4770              BX       lr
;;;475    {
;;;476      /* NOTE : This function Should not be modified, when the callback is needed,
;;;477                the HAL_CAN_MspInit could be implemented in the user file
;;;478       */ 
;;;479    }
;;;480    
                          ENDP


                          AREA ||i.HAL_CAN_Receive||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Receive PROC
;;;776      */
;;;777    HAL_StatusTypeDef HAL_CAN_Receive(CAN_HandleTypeDef* hcan, uint8_t FIFONumber, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;778    {
000004  4604              MOV      r4,r0
;;;779      uint32_t timeout;
;;;780       
;;;781      /* Check the parameters */
;;;782      assert_param(IS_CAN_FIFO(FIFONumber));
;;;783      
;;;784      /* Process locked */
;;;785      __HAL_LOCK(hcan);
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  4616              MOV      r6,r2                 ;778
00000c  460d              MOV      r5,r1                 ;778
00000e  2801              CMP      r0,#1
000010  d010              BEQ      |L12.52|
000012  f04f0901          MOV      r9,#1
000016  f8849039          STRB     r9,[r4,#0x39]
;;;786      
;;;787      if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
00001a  f8940038          LDRB     r0,[r4,#0x38]
00001e  2812              CMP      r0,#0x12
000020  d00b              BEQ      |L12.58|
;;;788      {
;;;789        /* Change CAN state */
;;;790        hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
;;;791      }
;;;792      else
;;;793      {
;;;794        /* Change CAN state */
;;;795        hcan->State = HAL_CAN_STATE_BUSY_RX;
000022  2022              MOVS     r0,#0x22
                  |L12.36|
000024  f8840038          STRB     r0,[r4,#0x38]
;;;796      }
;;;797        
;;;798      /* Get timeout */
;;;799      timeout = HAL_GetTick() + Timeout;   
000028  f7fffffe          BL       HAL_GetTick
00002c  eb000806          ADD      r8,r0,r6
000030  2700              MOVS     r7,#0
;;;800      
;;;801      /* Check pending message */
;;;802      while(__HAL_CAN_MSG_PENDING(hcan, FIFONumber) == 0)
000032  e00f              B        |L12.84|
                  |L12.52|
000034  2002              MOVS     r0,#2                 ;785
                  |L12.54|
;;;803      {
;;;804        /* Check for the Timeout */
;;;805        if(Timeout != HAL_MAX_DELAY)
;;;806        {
;;;807          if(HAL_GetTick() >= timeout)
;;;808          {
;;;809            hcan->State = HAL_CAN_STATE_TIMEOUT;
;;;810            /* Process unlocked */
;;;811            __HAL_UNLOCK(hcan);
;;;812            return HAL_TIMEOUT;
;;;813          }
;;;814        }
;;;815      }
;;;816      
;;;817      /* Get the Id */
;;;818      hcan->pRxMsg->IDE = (uint8_t)0x04 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
;;;819      if (hcan->pRxMsg->IDE == CAN_ID_STD)
;;;820      {
;;;821        hcan->pRxMsg->StdId = (uint32_t)0x000007FF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;822      }
;;;823      else
;;;824      {
;;;825        hcan->pRxMsg->ExtId = (uint32_t)0x1FFFFFFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RIR >> 3);
;;;826      }
;;;827      
;;;828      hcan->pRxMsg->RTR = (uint8_t)0x02 & hcan->Instance->sFIFOMailBox[FIFONumber].RIR;
;;;829      /* Get the DLC */
;;;830      hcan->pRxMsg->DLC = (uint8_t)0x0F & hcan->Instance->sFIFOMailBox[FIFONumber].RDTR;
;;;831      /* Get the FMI */
;;;832      hcan->pRxMsg->FMI = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDTR >> 8);
;;;833      /* Get the data field */
;;;834      hcan->pRxMsg->Data[0] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDLR;
;;;835      hcan->pRxMsg->Data[1] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 8);
;;;836      hcan->pRxMsg->Data[2] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 16);
;;;837      hcan->pRxMsg->Data[3] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDLR >> 24);
;;;838      hcan->pRxMsg->Data[4] = (uint8_t)0xFF & hcan->Instance->sFIFOMailBox[FIFONumber].RDHR;
;;;839      hcan->pRxMsg->Data[5] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 8);
;;;840      hcan->pRxMsg->Data[6] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 16);
;;;841      hcan->pRxMsg->Data[7] = (uint8_t)0xFF & (hcan->Instance->sFIFOMailBox[FIFONumber].RDHR >> 24);
;;;842      
;;;843      /* Release the FIFO */
;;;844      if(FIFONumber == CAN_FIFO0)
;;;845      {
;;;846        /* Release FIFO0 */
;;;847        __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO0);
;;;848      }
;;;849      else /* FIFONumber == CAN_FIFO1 */
;;;850      {
;;;851        /* Release FIFO1 */
;;;852        __HAL_CAN_FIFO_RELEASE(hcan, CAN_FIFO1);
;;;853      }
;;;854      
;;;855      if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
;;;856      {
;;;857        /* Change CAN state */
;;;858        hcan->State = HAL_CAN_STATE_BUSY_TX;
;;;859        
;;;860        /* Process unlocked */
;;;861        __HAL_UNLOCK(hcan);
;;;862      }
;;;863      else
;;;864      {
;;;865        /* Change CAN state */
;;;866        hcan->State = HAL_CAN_STATE_READY;
;;;867        
;;;868        /* Process unlocked */
;;;869        __HAL_UNLOCK(hcan);
;;;870      }
;;;871      
;;;872      /* Return function status */
;;;873      return HAL_OK;
;;;874    }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L12.58|
00003a  2032              MOVS     r0,#0x32              ;790
00003c  e7f2              B        |L12.36|
                  |L12.62|
00003e  1c70              ADDS     r0,r6,#1              ;805
000040  d008              BEQ      |L12.84|
000042  f7fffffe          BL       HAL_GetTick
000046  4540              CMP      r0,r8                 ;807
000048  d304              BCC      |L12.84|
00004a  2003              MOVS     r0,#3                 ;809
00004c  f8040f38          STRB     r0,[r4,#0x38]!        ;809
000050  7067              STRB     r7,[r4,#1]            ;811
000052  e7f0              B        |L12.54|
                  |L12.84|
000054  6820              LDR      r0,[r4,#0]            ;802
000056  2d00              CMP      r5,#0                 ;802
000058  d070              BEQ      |L12.316|
00005a  6900              LDR      r0,[r0,#0x10]         ;802
                  |L12.92|
00005c  f0100f03          TST      r0,#3                 ;802
000060  d0ed              BEQ      |L12.62|
000062  f44f70d8          MOV      r0,#0x1b0             ;818
000066  6821              LDR      r1,[r4,#0]            ;818
000068  eb001005          ADD      r0,r0,r5,LSL #4       ;818
00006c  5809              LDR      r1,[r1,r0]            ;818
00006e  f0110204          ANDS     r2,r1,#4              ;818
000072  6b61              LDR      r1,[r4,#0x34]         ;818
000074  608a              STR      r2,[r1,#8]            ;819
000076  6822              LDR      r2,[r4,#0]            ;825
000078  6b61              LDR      r1,[r4,#0x34]         ;825
00007a  5812              LDR      r2,[r2,r0]            ;825
00007c  d060              BEQ      |L12.320|
00007e  08d2              LSRS     r2,r2,#3              ;825
000080  604a              STR      r2,[r1,#4]            ;825
                  |L12.130|
000082  6821              LDR      r1,[r4,#0]            ;828
000084  5808              LDR      r0,[r1,r0]            ;828
000086  6b61              LDR      r1,[r4,#0x34]         ;828
000088  f0000002          AND      r0,r0,#2              ;828
00008c  60c8              STR      r0,[r1,#0xc]          ;830
00008e  f44f70da          MOV      r0,#0x1b4             ;830
000092  6821              LDR      r1,[r4,#0]            ;830
000094  eb001005          ADD      r0,r0,r5,LSL #4       ;830
000098  5809              LDR      r1,[r1,r0]            ;830
00009a  6b62              LDR      r2,[r4,#0x34]         ;830
00009c  f001010f          AND      r1,r1,#0xf            ;830
0000a0  6111              STR      r1,[r2,#0x10]         ;832
0000a2  6821              LDR      r1,[r4,#0]            ;832
0000a4  5808              LDR      r0,[r1,r0]            ;832
0000a6  6b61              LDR      r1,[r4,#0x34]         ;832
0000a8  f3c02007          UBFX     r0,r0,#8,#8           ;832
0000ac  6348              STR      r0,[r1,#0x34]         ;834
0000ae  f44f70dc          MOV      r0,#0x1b8             ;834
0000b2  6821              LDR      r1,[r4,#0]            ;834
0000b4  eb001005          ADD      r0,r0,r5,LSL #4       ;834
0000b8  5809              LDR      r1,[r1,r0]            ;834
0000ba  6b62              LDR      r2,[r4,#0x34]         ;834
0000bc  b2c9              UXTB     r1,r1                 ;834
0000be  6151              STR      r1,[r2,#0x14]         ;835
0000c0  6821              LDR      r1,[r4,#0]            ;835
0000c2  5809              LDR      r1,[r1,r0]            ;835
0000c4  6b62              LDR      r2,[r4,#0x34]         ;835
0000c6  f3c12107          UBFX     r1,r1,#8,#8           ;835
0000ca  6191              STR      r1,[r2,#0x18]         ;836
0000cc  6821              LDR      r1,[r4,#0]            ;836
0000ce  5809              LDR      r1,[r1,r0]            ;836
0000d0  6b62              LDR      r2,[r4,#0x34]         ;836
0000d2  f3c14107          UBFX     r1,r1,#16,#8          ;836
0000d6  61d1              STR      r1,[r2,#0x1c]         ;837
0000d8  6821              LDR      r1,[r4,#0]            ;837
0000da  5808              LDR      r0,[r1,r0]            ;837
0000dc  6b61              LDR      r1,[r4,#0x34]         ;837
0000de  0e00              LSRS     r0,r0,#24             ;837
0000e0  6208              STR      r0,[r1,#0x20]         ;838
0000e2  f44f70de          MOV      r0,#0x1bc             ;838
0000e6  6821              LDR      r1,[r4,#0]            ;838
0000e8  eb001005          ADD      r0,r0,r5,LSL #4       ;838
0000ec  5809              LDR      r1,[r1,r0]            ;838
0000ee  6b62              LDR      r2,[r4,#0x34]         ;838
0000f0  b2c9              UXTB     r1,r1                 ;838
0000f2  6251              STR      r1,[r2,#0x24]         ;839
0000f4  6821              LDR      r1,[r4,#0]            ;839
0000f6  5809              LDR      r1,[r1,r0]            ;839
0000f8  6b62              LDR      r2,[r4,#0x34]         ;839
0000fa  f3c12107          UBFX     r1,r1,#8,#8           ;839
0000fe  6291              STR      r1,[r2,#0x28]         ;840
000100  6821              LDR      r1,[r4,#0]            ;840
000102  5809              LDR      r1,[r1,r0]            ;840
000104  6b62              LDR      r2,[r4,#0x34]         ;840
000106  f3c14107          UBFX     r1,r1,#16,#8          ;840
00010a  62d1              STR      r1,[r2,#0x2c]         ;841
00010c  6821              LDR      r1,[r4,#0]            ;841
00010e  5808              LDR      r0,[r1,r0]            ;841
000110  6b61              LDR      r1,[r4,#0x34]         ;841
000112  0e00              LSRS     r0,r0,#24             ;841
000114  6308              STR      r0,[r1,#0x30]         ;852
000116  6820              LDR      r0,[r4,#0]            ;844
000118  b1ad              CBZ      r5,|L12.326|
00011a  6901              LDR      r1,[r0,#0x10]         ;852
00011c  f0410120          ORR      r1,r1,#0x20           ;852
000120  f8c01010          STR.W    r1,[r0,#0x10]         ;852
                  |L12.292|
000124  f8940038          LDRB     r0,[r4,#0x38]         ;855
000128  2832              CMP      r0,#0x32              ;855
00012a  d011              BEQ      |L12.336|
00012c  ea4f0009          MOV.W    r0,r9                 ;866
                  |L12.304|
000130  f8040f38          STRB     r0,[r4,#0x38]!        ;866
000134  2000              MOVS     r0,#0                 ;873
000136  7067              STRB     r7,[r4,#1]            ;869
000138  e77d              B        |L12.54|
00013a  e7ff              B        |L12.316|
                  |L12.316|
00013c  68c0              LDR      r0,[r0,#0xc]          ;802
00013e  e78d              B        |L12.92|
                  |L12.320|
000140  0d52              LSRS     r2,r2,#21             ;821
000142  600a              STR      r2,[r1,#0]            ;821
000144  e79d              B        |L12.130|
                  |L12.326|
000146  68c1              LDR      r1,[r0,#0xc]          ;847
000148  f0410120          ORR      r1,r1,#0x20           ;847
00014c  60c1              STR      r1,[r0,#0xc]          ;847
00014e  e7e9              B        |L12.292|
                  |L12.336|
000150  2012              MOVS     r0,#0x12              ;858
000152  e7ed              B        |L12.304|
;;;875    
                          ENDP


                          AREA ||i.HAL_CAN_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Receive_IT PROC
;;;883      */
;;;884    HAL_StatusTypeDef HAL_CAN_Receive_IT(CAN_HandleTypeDef* hcan, uint8_t FIFONumber)
000000  b510              PUSH     {r4,lr}
;;;885    {
;;;886      uint32_t tmp = 0;
;;;887      
;;;888      /* Check the parameters */
;;;889      assert_param(IS_CAN_FIFO(FIFONumber));
;;;890      
;;;891      tmp = hcan->State;
000002  f8902038          LDRB     r2,[r0,#0x38]
;;;892      if((tmp == HAL_CAN_STATE_READY) || (tmp == HAL_CAN_STATE_BUSY_TX))
000006  2a01              CMP      r2,#1
000008  d001              BEQ      |L13.14|
00000a  2a12              CMP      r2,#0x12
00000c  d139              BNE      |L13.130|
                  |L13.14|
;;;893      {
;;;894        /* Process locked */
;;;895        __HAL_LOCK(hcan);
00000e  f8902039          LDRB     r2,[r0,#0x39]
000012  2a01              CMP      r2,#1
000014  d035              BEQ      |L13.130|
000016  2201              MOVS     r2,#1
000018  f8802039          STRB     r2,[r0,#0x39]
;;;896      
;;;897        if(hcan->State == HAL_CAN_STATE_BUSY_TX) 
00001c  f8902038          LDRB     r2,[r0,#0x38]
000020  2a12              CMP      r2,#0x12
000022  d029              BEQ      |L13.120|
;;;898        {
;;;899          /* Change CAN state */
;;;900          hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
;;;901        }
;;;902        else
;;;903        {
;;;904          /* Change CAN state */
;;;905          hcan->State = HAL_CAN_STATE_BUSY_RX;
000024  f05f0222          MOVS.W   r2,#0x22
                  |L13.40|
000028  f8802038          STRB     r2,[r0,#0x38]
;;;906        }
;;;907        
;;;908        /* Set CAN error code to none */
;;;909        hcan->ErrorCode = HAL_CAN_ERROR_NONE;
00002c  2200              MOVS     r2,#0
00002e  63c2              STR      r2,[r0,#0x3c]
;;;910        
;;;911        /* Enable Error warning Interrupt */
;;;912        __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EWG);
000030  6803              LDR      r3,[r0,#0]
000032  695c              LDR      r4,[r3,#0x14]
000034  f4447480          ORR      r4,r4,#0x100
000038  615c              STR      r4,[r3,#0x14]
;;;913          
;;;914        /* Enable Error passive Interrupt */
;;;915        __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EPV);
00003a  6803              LDR      r3,[r0,#0]
00003c  695c              LDR      r4,[r3,#0x14]
00003e  f4447400          ORR      r4,r4,#0x200
000042  615c              STR      r4,[r3,#0x14]
;;;916          
;;;917        /* Enable Bus-off Interrupt */
;;;918        __HAL_CAN_ENABLE_IT(hcan, CAN_IT_BOF);
000044  6803              LDR      r3,[r0,#0]
000046  695c              LDR      r4,[r3,#0x14]
000048  f4446480          ORR      r4,r4,#0x400
00004c  615c              STR      r4,[r3,#0x14]
;;;919          
;;;920        /* Enable Last error code Interrupt */
;;;921        __HAL_CAN_ENABLE_IT(hcan, CAN_IT_LEC);
00004e  6803              LDR      r3,[r0,#0]
000050  695c              LDR      r4,[r3,#0x14]
000052  f4446400          ORR      r4,r4,#0x800
000056  615c              STR      r4,[r3,#0x14]
;;;922          
;;;923        /* Enable Error Interrupt */
;;;924        __HAL_CAN_ENABLE_IT(hcan, CAN_IT_ERR);
000058  6803              LDR      r3,[r0,#0]
00005a  695c              LDR      r4,[r3,#0x14]
00005c  f4444400          ORR      r4,r4,#0x8000
000060  615c              STR      r4,[r3,#0x14]
;;;925    
;;;926        /* Process unlocked */
;;;927        __HAL_UNLOCK(hcan);
000062  f8802039          STRB     r2,[r0,#0x39]
;;;928    
;;;929        if(FIFONumber == CAN_FIFO0)
;;;930        {
;;;931          /* Enable FIFO 0 message pending Interrupt */
;;;932          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP0);
;;;933        }
;;;934        else
;;;935        {
;;;936          /* Enable FIFO 1 message pending Interrupt */
;;;937          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_FMP1);
000066  6800              LDR      r0,[r0,#0]
000068  2900              CMP      r1,#0                 ;929
00006a  6941              LDR      r1,[r0,#0x14]
00006c  d006              BEQ      |L13.124|
00006e  f0410110          ORR      r1,r1,#0x10
                  |L13.114|
000072  6141              STR      r1,[r0,#0x14]         ;932
;;;938        }
;;;939        
;;;940      }
;;;941      else
;;;942      {
;;;943        return HAL_BUSY;
;;;944      }
;;;945      
;;;946      /* Return function status */
;;;947      return HAL_OK;
000074  2000              MOVS     r0,#0
;;;948    }
000076  bd10              POP      {r4,pc}
                  |L13.120|
000078  2232              MOVS     r2,#0x32              ;900
00007a  e7d5              B        |L13.40|
                  |L13.124|
00007c  f0410102          ORR      r1,r1,#2              ;932
000080  e7f7              B        |L13.114|
                  |L13.130|
000082  2002              MOVS     r0,#2                 ;943
000084  bd10              POP      {r4,pc}
;;;949    
                          ENDP


                          AREA ||i.HAL_CAN_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxCpltCallback PROC
;;;1197     */
;;;1198   __weak void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* hcan)
000000  4770              BX       lr
;;;1199   {
;;;1200     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1201               the HAL_CAN_RxCpltCallback could be implemented in the user file
;;;1202      */
;;;1203   }
;;;1204   
                          ENDP


                          AREA ||i.HAL_CAN_Sleep||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Sleep PROC
;;;955      */
;;;956    HAL_StatusTypeDef HAL_CAN_Sleep(CAN_HandleTypeDef* hcan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;957    {
000004  4604              MOV      r4,r0
;;;958      uint32_t timeout;
;;;959       
;;;960      /* Process locked */
;;;961      __HAL_LOCK(hcan);
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  2801              CMP      r0,#1
00000c  d015              BEQ      |L15.58|
00000e  2601              MOVS     r6,#1
000010  f8846039          STRB     r6,[r4,#0x39]
;;;962      
;;;963      /* Change CAN state */
;;;964      hcan->State = HAL_CAN_STATE_BUSY; 
000014  2002              MOVS     r0,#2
000016  f8840038          STRB     r0,[r4,#0x38]
;;;965        
;;;966      /* Request Sleep mode */
;;;967       hcan->Instance->MCR = (((hcan->Instance->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  f0410102          ORR      r1,r1,#2
000026  6001              STR      r1,[r0,#0]
;;;968       
;;;969      /* Sleep mode status */
;;;970      if ((hcan->Instance->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) != CAN_MSR_SLAK)
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  f0000003          AND      r0,r0,#3
000030  2802              CMP      r0,#2
000032  d004              BEQ      |L15.62|
;;;971      {
;;;972        /* Return function status */
;;;973        return HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L15.54|
;;;974      }
;;;975      
;;;976      /* Get timeout */
;;;977      timeout = HAL_GetTick() + 10;   
;;;978      
;;;979      /* Wait the acknowledge */
;;;980      while((hcan->Instance->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) != CAN_MSR_SLAK)
;;;981      {
;;;982        if(HAL_GetTick() >= timeout)
;;;983        {
;;;984          hcan->State = HAL_CAN_STATE_TIMEOUT;
;;;985          /* Process unlocked */
;;;986          __HAL_UNLOCK(hcan);
;;;987          return HAL_TIMEOUT;
;;;988        }
;;;989      }
;;;990      
;;;991      /* Change CAN state */
;;;992      hcan->State = HAL_CAN_STATE_READY;
;;;993      
;;;994      /* Process unlocked */
;;;995      __HAL_UNLOCK(hcan);
;;;996      
;;;997      /* Return function status */
;;;998      return HAL_OK;
;;;999    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L15.58|
00003a  2002              MOVS     r0,#2                 ;961
00003c  e7fb              B        |L15.54|
                  |L15.62|
00003e  f7fffffe          BL       HAL_GetTick
000042  f100050a          ADD      r5,r0,#0xa            ;977
000046  2700              MOVS     r7,#0                 ;977
000048  e009              B        |L15.94|
00004a  bf00              NOP                            ;982
                  |L15.76|
00004c  f7fffffe          BL       HAL_GetTick
000050  42a8              CMP      r0,r5                 ;982
000052  d304              BCC      |L15.94|
000054  2003              MOVS     r0,#3                 ;984
000056  f8040f38          STRB     r0,[r4,#0x38]!        ;984
00005a  7067              STRB     r7,[r4,#1]            ;986
00005c  e7eb              B        |L15.54|
                  |L15.94|
00005e  6820              LDR      r0,[r4,#0]            ;980
000060  6840              LDR      r0,[r0,#4]            ;980
000062  f0000003          AND      r0,r0,#3              ;980
000066  2802              CMP      r0,#2                 ;980
000068  d1f0              BNE      |L15.76|
00006a  f8046f38          STRB     r6,[r4,#0x38]!        ;992
00006e  2000              MOVS     r0,#0                 ;998
000070  7067              STRB     r7,[r4,#1]            ;995
000072  e7e0              B        |L15.54|
;;;1000   
                          ENDP


                          AREA ||i.HAL_CAN_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Transmit PROC
;;;521      */
;;;522    HAL_StatusTypeDef HAL_CAN_Transmit(CAN_HandleTypeDef* hcan, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;523    {
000004  4604              MOV      r4,r0
;;;524      uint32_t  transmitmailbox = 5;
;;;525      
;;;526      uint32_t timeout;
;;;527       
;;;528      /* Check the parameters */
;;;529      assert_param(IS_CAN_IDTYPE(hcan->pTxMsg->IDE));
;;;530      assert_param(IS_CAN_RTR(hcan->pTxMsg->RTR));
;;;531      assert_param(IS_CAN_DLC(hcan->pTxMsg->DLC));
;;;532      
;;;533      /* Process locked */
;;;534      __HAL_LOCK(hcan);
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  460e              MOV      r6,r1                 ;523
00000c  2801              CMP      r0,#1
00000e  d011              BEQ      |L16.52|
000010  f04f0901          MOV      r9,#1
000014  f8849039          STRB     r9,[r4,#0x39]
;;;535      
;;;536      if(hcan->State == HAL_CAN_STATE_BUSY_RX) 
000018  f8940038          LDRB     r0,[r4,#0x38]
00001c  2822              CMP      r0,#0x22
00001e  d00c              BEQ      |L16.58|
;;;537      {
;;;538        /* Change CAN state */
;;;539        hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
;;;540      }
;;;541      else
;;;542      {
;;;543        /* Change CAN state */
;;;544        hcan->State = HAL_CAN_STATE_BUSY_TX;
000020  f05f0012          MOVS.W   r0,#0x12
                  |L16.36|
000024  f8840038          STRB     r0,[r4,#0x38]
;;;545      }
;;;546      
;;;547      /* Select one empty transmit mailbox */
;;;548      if ((hcan->Instance->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000028  6821              LDR      r1,[r4,#0]
00002a  6888              LDR      r0,[r1,#8]
00002c  0140              LSLS     r0,r0,#5
00002e  d506              BPL      |L16.62|
;;;549      {
;;;550        transmitmailbox = 0;
000030  2500              MOVS     r5,#0
000032  e00d              B        |L16.80|
                  |L16.52|
000034  2002              MOVS     r0,#2                 ;534
                  |L16.54|
;;;551      }
;;;552      else if ((hcan->Instance->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
;;;553      {
;;;554        transmitmailbox = 1;
;;;555      }
;;;556      else if ((hcan->Instance->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
;;;557      {
;;;558        transmitmailbox = 2;
;;;559      }
;;;560      else
;;;561      {
;;;562        transmitmailbox = CAN_TXSTATUS_NOMAILBOX;
;;;563      }
;;;564    
;;;565      if (transmitmailbox != CAN_TXSTATUS_NOMAILBOX)
;;;566      {
;;;567        /* Set up the Id */
;;;568        hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
;;;569        if (hcan->pTxMsg->IDE == CAN_ID_STD)
;;;570        {
;;;571          assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
;;;572          hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
;;;573                                                      hcan->pTxMsg->RTR);
;;;574        }
;;;575        else
;;;576        {
;;;577          assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
;;;578          hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
;;;579                                                      hcan->pTxMsg->IDE | \
;;;580                                                      hcan->pTxMsg->RTR);
;;;581        }
;;;582        
;;;583        /* Set up the DLC */
;;;584        hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
;;;585        hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
;;;586        hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;
;;;587    
;;;588        /* Set up the data field */
;;;589        hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
;;;590                                                 ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
;;;591                                                 ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
;;;592                                                 ((uint32_t)hcan->pTxMsg->Data[0]));
;;;593        hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
;;;594                                                 ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
;;;595                                                 ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
;;;596                                                 ((uint32_t)hcan->pTxMsg->Data[4]));
;;;597        /* Request transmission */
;;;598        hcan->Instance->sTxMailBox[transmitmailbox].TIR |= CAN_TI0R_TXRQ;
;;;599      
;;;600        /* Get timeout */
;;;601        timeout = HAL_GetTick() + Timeout;   
;;;602      
;;;603        /* Check End of transmission flag */
;;;604        while(!(__HAL_CAN_TRANSMIT_STATUS(hcan, transmitmailbox)))
;;;605        {
;;;606          /* Check for the Timeout */
;;;607          if(Timeout != HAL_MAX_DELAY)
;;;608          {
;;;609            if(HAL_GetTick() >= timeout)
;;;610            {
;;;611              hcan->State = HAL_CAN_STATE_TIMEOUT;
;;;612              /* Process unlocked */
;;;613              __HAL_UNLOCK(hcan);
;;;614              return HAL_TIMEOUT;
;;;615            }
;;;616          }
;;;617        }
;;;618        if(hcan->State == HAL_CAN_STATE_BUSY_TX_RX) 
;;;619        {
;;;620          /* Change CAN state */
;;;621          hcan->State = HAL_CAN_STATE_BUSY_RX;
;;;622          
;;;623          /* Process unlocked */
;;;624          __HAL_UNLOCK(hcan);
;;;625        }
;;;626        else
;;;627        {
;;;628          /* Change CAN state */
;;;629          hcan->State = HAL_CAN_STATE_READY;
;;;630          
;;;631          /* Process unlocked */
;;;632          __HAL_UNLOCK(hcan);
;;;633        }
;;;634        
;;;635        /* Return function status */
;;;636        return HAL_OK;
;;;637      }
;;;638      else
;;;639      {
;;;640        /* Change CAN state */
;;;641        hcan->State = HAL_CAN_STATE_ERROR; 
;;;642        
;;;643        /* Return function status */
;;;644        return HAL_ERROR;
;;;645      }
;;;646    }
000036  e8bd9ff0          POP      {r4-r12,pc}
                  |L16.58|
00003a  2032              MOVS     r0,#0x32              ;539
00003c  e7f2              B        |L16.36|
                  |L16.62|
00003e  6888              LDR      r0,[r1,#8]            ;552
000040  0100              LSLS     r0,r0,#4              ;552
000042  d501              BPL      |L16.72|
000044  2501              MOVS     r5,#1                 ;554
000046  e003              B        |L16.80|
                  |L16.72|
000048  6888              LDR      r0,[r1,#8]            ;556
00004a  00c0              LSLS     r0,r0,#3              ;556
00004c  d55d              BPL      |L16.266|
00004e  2502              MOVS     r5,#2                 ;558
                  |L16.80|
000050  f44f70c0          MOV      r0,#0x180             ;568
000054  eb001005          ADD      r0,r0,r5,LSL #4       ;568
000058  580a              LDR      r2,[r1,r0]            ;568
00005a  f0020201          AND      r2,r2,#1              ;568
00005e  500a              STR      r2,[r1,r0]            ;568
000060  6b21              LDR      r1,[r4,#0x30]         ;569
000062  688a              LDR      r2,[r1,#8]            ;569
000064  b3ea              CBZ      r2,|L16.226|
000066  6827              LDR      r7,[r4,#0]            ;578
000068  583b              LDR      r3,[r7,r0]            ;578
00006a  4313              ORRS     r3,r3,r2              ;578
00006c  68ca              LDR      r2,[r1,#0xc]          ;578
00006e  6849              LDR      r1,[r1,#4]            ;578
000070  ea4201c1          ORR      r1,r2,r1,LSL #3       ;578
000074  430b              ORRS     r3,r3,r1              ;578
000076  503b              STR      r3,[r7,r0]            ;578
                  |L16.120|
000078  6b21              LDR      r1,[r4,#0x30]         ;584
00007a  7c0a              LDRB     r2,[r1,#0x10]         ;584
00007c  f002020f          AND      r2,r2,#0xf            ;584
000080  610a              STR      r2,[r1,#0x10]         ;585
000082  f44f71c2          MOV      r1,#0x184             ;585
000086  6822              LDR      r2,[r4,#0]            ;585
000088  eb011105          ADD      r1,r1,r5,LSL #4       ;585
00008c  5853              LDR      r3,[r2,r1]            ;585
00008e  f023030f          BIC      r3,r3,#0xf            ;585
000092  5053              STR      r3,[r2,r1]            ;585
000094  6822              LDR      r2,[r4,#0]            ;586
000096  5853              LDR      r3,[r2,r1]            ;586
000098  6b27              LDR      r7,[r4,#0x30]         ;586
00009a  693f              LDR      r7,[r7,#0x10]         ;586
00009c  433b              ORRS     r3,r3,r7              ;586
00009e  5053              STR      r3,[r2,r1]            ;586
0000a0  6b21              LDR      r1,[r4,#0x30]         ;589
0000a2  f8913020          LDRB     r3,[r1,#0x20]         ;589
0000a6  694a              LDR      r2,[r1,#0x14]         ;589
0000a8  ea426203          ORR      r2,r2,r3,LSL #24      ;589
0000ac  8b8b              LDRH     r3,[r1,#0x1c]         ;589
0000ae  6989              LDR      r1,[r1,#0x18]         ;589
0000b0  041b              LSLS     r3,r3,#16             ;589
0000b2  ea432101          ORR      r1,r3,r1,LSL #8       ;589
0000b6  430a              ORRS     r2,r2,r1              ;589
0000b8  f44f73c4          MOV      r3,#0x188             ;589
0000bc  6821              LDR      r1,[r4,#0]            ;589
0000be  eb031305          ADD      r3,r3,r5,LSL #4       ;589
0000c2  50ca              STR      r2,[r1,r3]            ;589
0000c4  6b21              LDR      r1,[r4,#0x30]         ;593
0000c6  f8913030          LDRB     r3,[r1,#0x30]         ;593
0000ca  6a4a              LDR      r2,[r1,#0x24]         ;593
0000cc  ea426203          ORR      r2,r2,r3,LSL #24      ;593
0000d0  8d8b              LDRH     r3,[r1,#0x2c]         ;593
0000d2  6a89              LDR      r1,[r1,#0x28]         ;593
0000d4  041b              LSLS     r3,r3,#16             ;593
0000d6  ea432101          ORR      r1,r3,r1,LSL #8       ;593
0000da  430a              ORRS     r2,r2,r1              ;593
0000dc  f44f73c6          MOV      r3,#0x18c             ;593
0000e0  e000              B        |L16.228|
                  |L16.226|
0000e2  e017              B        |L16.276|
                  |L16.228|
0000e4  6821              LDR      r1,[r4,#0]            ;593
0000e6  eb031305          ADD      r3,r3,r5,LSL #4       ;593
0000ea  50ca              STR      r2,[r1,r3]            ;593
0000ec  6821              LDR      r1,[r4,#0]            ;598
0000ee  580a              LDR      r2,[r1,r0]            ;598
0000f0  f0420201          ORR      r2,r2,#1              ;598
0000f4  500a              STR      r2,[r1,r0]            ;598
0000f6  f7fffffe          BL       HAL_GetTick
0000fa  eb000806          ADD      r8,r0,r6              ;601
0000fe  2700              MOVS     r7,#0                 ;601
000100  f8dfa074          LDR      r10,|L16.376|
000104  f8dfb074          LDR      r11,|L16.380|
000108  e018              B        |L16.316|
                  |L16.266|
00010a  2004              MOVS     r0,#4                 ;641
00010c  f8840038          STRB     r0,[r4,#0x38]         ;641
000110  2001              MOVS     r0,#1                 ;644
000112  e790              B        |L16.54|
                  |L16.276|
000114  6822              LDR      r2,[r4,#0]            ;572
000116  5813              LDR      r3,[r2,r0]            ;572
000118  68cf              LDR      r7,[r1,#0xc]          ;572
00011a  8809              LDRH     r1,[r1,#0]            ;572
00011c  433b              ORRS     r3,r3,r7              ;572
00011e  ea435141          ORR      r1,r3,r1,LSL #21      ;572
000122  5011              STR      r1,[r2,r0]            ;572
000124  e7a8              B        |L16.120|
                  |L16.294|
000126  1c70              ADDS     r0,r6,#1              ;607
000128  d008              BEQ      |L16.316|
00012a  f7fffffe          BL       HAL_GetTick
00012e  4540              CMP      r0,r8                 ;609
000130  d304              BCC      |L16.316|
000132  2003              MOVS     r0,#3                 ;611
000134  f8040f38          STRB     r0,[r4,#0x38]!        ;611
000138  7067              STRB     r7,[r4,#1]            ;613
00013a  e77c              B        |L16.54|
                  |L16.316|
00013c  b18d              CBZ      r5,|L16.354|
00013e  6820              LDR      r0,[r4,#0]            ;604
000140  2d01              CMP      r5,#1                 ;604
000142  6881              LDR      r1,[r0,#8]            ;604
000144  d012              BEQ      |L16.364|
000146  480e              LDR      r0,|L16.384|
000148  4388              BICS     r0,r0,r1              ;604
                  |L16.330|
00014a  2800              CMP      r0,#0                 ;604
00014c  d1eb              BNE      |L16.294|
00014e  f8940038          LDRB     r0,[r4,#0x38]         ;618
000152  2832              CMP      r0,#0x32              ;618
000154  d00d              BEQ      |L16.370|
000156  4648              MOV      r0,r9                 ;629
                  |L16.344|
000158  f8040f38          STRB     r0,[r4,#0x38]!        ;629
00015c  2000              MOVS     r0,#0                 ;636
00015e  7067              STRB     r7,[r4,#1]            ;632
000160  e769              B        |L16.54|
                  |L16.354|
000162  6820              LDR      r0,[r4,#0]            ;604
000164  6881              LDR      r1,[r0,#8]            ;604
000166  ea2a0001          BIC      r0,r10,r1             ;604
00016a  e7ee              B        |L16.330|
                  |L16.364|
00016c  ea2b0001          BIC      r0,r11,r1             ;604
000170  e7eb              B        |L16.330|
                  |L16.370|
000172  2022              MOVS     r0,#0x22              ;621
000174  e7f0              B        |L16.344|
;;;647    
                          ENDP

000176  0000              DCW      0x0000
                  |L16.376|
                          DCD      0x04000003
                  |L16.380|
                          DCD      0x08000300
                  |L16.384|
                          DCD      0x10030000

                          AREA ||i.HAL_CAN_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Transmit_IT PROC
;;;653      */
;;;654    HAL_StatusTypeDef HAL_CAN_Transmit_IT(CAN_HandleTypeDef* hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;655    {
;;;656      uint32_t  transmitmailbox = 5;
;;;657      uint32_t tmp = 0;
;;;658      
;;;659      /* Check the parameters */
;;;660      assert_param(IS_CAN_IDTYPE(hcan->pTxMsg->IDE));
;;;661      assert_param(IS_CAN_RTR(hcan->pTxMsg->RTR));
;;;662      assert_param(IS_CAN_DLC(hcan->pTxMsg->DLC));
;;;663      
;;;664      tmp = hcan->State;
000002  f8901038          LDRB     r1,[r0,#0x38]
;;;665      if((tmp == HAL_CAN_STATE_READY) || (tmp == HAL_CAN_STATE_BUSY_RX))
000006  2901              CMP      r1,#1
000008  d001              BEQ      |L17.14|
00000a  2922              CMP      r1,#0x22
00000c  d17e              BNE      |L17.268|
                  |L17.14|
;;;666      {
;;;667        /* Process Locked */
;;;668        __HAL_LOCK(hcan);
00000e  f8901039          LDRB     r1,[r0,#0x39]
000012  2901              CMP      r1,#1
000014  d07a              BEQ      |L17.268|
000016  2101              MOVS     r1,#1
000018  f8801039          STRB     r1,[r0,#0x39]
;;;669        
;;;670        /* Select one empty transmit mailbox */
;;;671        if((hcan->Instance->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
00001c  6803              LDR      r3,[r0,#0]
00001e  6899              LDR      r1,[r3,#8]
000020  0149              LSLS     r1,r1,#5
000022  d501              BPL      |L17.40|
;;;672        {
;;;673          transmitmailbox = 0;
000024  2200              MOVS     r2,#0
000026  e008              B        |L17.58|
                  |L17.40|
;;;674        }
;;;675        else if((hcan->Instance->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
000028  6899              LDR      r1,[r3,#8]
00002a  0109              LSLS     r1,r1,#4
00002c  d501              BPL      |L17.50|
;;;676        {
;;;677          transmitmailbox = 1;
00002e  2201              MOVS     r2,#1
000030  e003              B        |L17.58|
                  |L17.50|
;;;678        }
;;;679        else if((hcan->Instance->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000032  6899              LDR      r1,[r3,#8]
000034  00c9              LSLS     r1,r1,#3
000036  d57f              BPL      |L17.312|
;;;680        {
;;;681          transmitmailbox = 2;
000038  2202              MOVS     r2,#2
                  |L17.58|
;;;682        }
;;;683        else
;;;684        {
;;;685          transmitmailbox = CAN_TXSTATUS_NOMAILBOX;
;;;686        }
;;;687    
;;;688        if(transmitmailbox != CAN_TXSTATUS_NOMAILBOX)
;;;689        {
;;;690          /* Set up the Id */
;;;691          hcan->Instance->sTxMailBox[transmitmailbox].TIR &= CAN_TI0R_TXRQ;
00003a  f44f71c0          MOV      r1,#0x180
00003e  eb011102          ADD      r1,r1,r2,LSL #4
000042  585c              LDR      r4,[r3,r1]
000044  f0040401          AND      r4,r4,#1
000048  505c              STR      r4,[r3,r1]
;;;692          if(hcan->pTxMsg->IDE == CAN_ID_STD)
00004a  6b03              LDR      r3,[r0,#0x30]
00004c  689c              LDR      r4,[r3,#8]
00004e  2c00              CMP      r4,#0
000050  d075              BEQ      |L17.318|
;;;693          {
;;;694            assert_param(IS_CAN_STDID(hcan->pTxMsg->StdId));  
;;;695            hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->StdId << 21) | \
;;;696                                                      hcan->pTxMsg->RTR);
;;;697          }
;;;698          else
;;;699          {
;;;700            assert_param(IS_CAN_EXTID(hcan->pTxMsg->ExtId));
;;;701            hcan->Instance->sTxMailBox[transmitmailbox].TIR |= ((hcan->pTxMsg->ExtId << 3) | \
000052  6806              LDR      r6,[r0,#0]
000054  5875              LDR      r5,[r6,r1]
000056  4325              ORRS     r5,r5,r4
000058  68dc              LDR      r4,[r3,#0xc]
00005a  685b              LDR      r3,[r3,#4]
00005c  ea4403c3          ORR      r3,r4,r3,LSL #3
000060  431d              ORRS     r5,r5,r3
000062  5075              STR      r5,[r6,r1]
                  |L17.100|
;;;702                                                      hcan->pTxMsg->IDE | \
;;;703                                                      hcan->pTxMsg->RTR);
;;;704          }
;;;705        
;;;706          /* Set up the DLC */
;;;707          hcan->pTxMsg->DLC &= (uint8_t)0x0000000F;
000064  6b03              LDR      r3,[r0,#0x30]
000066  7c1c              LDRB     r4,[r3,#0x10]
000068  f004040f          AND      r4,r4,#0xf
;;;708          hcan->Instance->sTxMailBox[transmitmailbox].TDTR &= (uint32_t)0xFFFFFFF0;
00006c  611c              STR      r4,[r3,#0x10]
00006e  f44f73c2          MOV      r3,#0x184
000072  6804              LDR      r4,[r0,#0]
000074  eb031302          ADD      r3,r3,r2,LSL #4
000078  58e5              LDR      r5,[r4,r3]
00007a  f025050f          BIC      r5,r5,#0xf
00007e  50e5              STR      r5,[r4,r3]
;;;709          hcan->Instance->sTxMailBox[transmitmailbox].TDTR |= hcan->pTxMsg->DLC;
000080  6804              LDR      r4,[r0,#0]
000082  58e5              LDR      r5,[r4,r3]
000084  6b06              LDR      r6,[r0,#0x30]
000086  6936              LDR      r6,[r6,#0x10]
000088  4335              ORRS     r5,r5,r6
00008a  50e5              STR      r5,[r4,r3]
;;;710    
;;;711          /* Set up the data field */
;;;712          hcan->Instance->sTxMailBox[transmitmailbox].TDLR = (((uint32_t)hcan->pTxMsg->Data[3] << 24) | 
00008c  6b03              LDR      r3,[r0,#0x30]
00008e  f8935020          LDRB     r5,[r3,#0x20]
000092  695c              LDR      r4,[r3,#0x14]
000094  ea446405          ORR      r4,r4,r5,LSL #24
000098  8b9d              LDRH     r5,[r3,#0x1c]
00009a  699b              LDR      r3,[r3,#0x18]
00009c  042d              LSLS     r5,r5,#16
00009e  ea452303          ORR      r3,r5,r3,LSL #8
0000a2  431c              ORRS     r4,r4,r3
0000a4  f44f75c4          MOV      r5,#0x188
0000a8  6803              LDR      r3,[r0,#0]
0000aa  eb051502          ADD      r5,r5,r2,LSL #4
0000ae  515c              STR      r4,[r3,r5]
;;;713                                                 ((uint32_t)hcan->pTxMsg->Data[2] << 16) |
;;;714                                                 ((uint32_t)hcan->pTxMsg->Data[1] << 8) | 
;;;715                                                 ((uint32_t)hcan->pTxMsg->Data[0]));
;;;716          hcan->Instance->sTxMailBox[transmitmailbox].TDHR = (((uint32_t)hcan->pTxMsg->Data[7] << 24) | 
0000b0  6b03              LDR      r3,[r0,#0x30]
0000b2  f8935030          LDRB     r5,[r3,#0x30]
0000b6  6a5c              LDR      r4,[r3,#0x24]
0000b8  ea446405          ORR      r4,r4,r5,LSL #24
0000bc  8d9d              LDRH     r5,[r3,#0x2c]
0000be  6a9b              LDR      r3,[r3,#0x28]
0000c0  042d              LSLS     r5,r5,#16
0000c2  ea452303          ORR      r3,r5,r3,LSL #8
0000c6  431c              ORRS     r4,r4,r3
0000c8  f44f75c6          MOV      r5,#0x18c
0000cc  6803              LDR      r3,[r0,#0]
0000ce  eb051202          ADD      r2,r5,r2,LSL #4
0000d2  509c              STR      r4,[r3,r2]
;;;717                                                 ((uint32_t)hcan->pTxMsg->Data[6] << 16) |
;;;718                                                 ((uint32_t)hcan->pTxMsg->Data[5] << 8) |
;;;719                                                 ((uint32_t)hcan->pTxMsg->Data[4]));
;;;720        
;;;721          if(hcan->State == HAL_CAN_STATE_BUSY_RX) 
0000d4  f8902038          LDRB     r2,[r0,#0x38]
0000d8  2a22              CMP      r2,#0x22
0000da  d039              BEQ      |L17.336|
;;;722          {
;;;723            /* Change CAN state */
;;;724            hcan->State = HAL_CAN_STATE_BUSY_TX_RX;
;;;725          }
;;;726          else
;;;727          {
;;;728            /* Change CAN state */
;;;729            hcan->State = HAL_CAN_STATE_BUSY_TX;
0000dc  f05f0212          MOVS.W   r2,#0x12
                  |L17.224|
0000e0  f8802038          STRB     r2,[r0,#0x38]
;;;730          }
;;;731          
;;;732          /* Set CAN error code to none */
;;;733          hcan->ErrorCode = HAL_CAN_ERROR_NONE;
0000e4  2200              MOVS     r2,#0
0000e6  63c2              STR      r2,[r0,#0x3c]
;;;734          
;;;735          /* Process Unlocked */
;;;736          __HAL_UNLOCK(hcan);
0000e8  f8802039          STRB     r2,[r0,#0x39]
;;;737          
;;;738          /* Enable Error warning Interrupt */
;;;739          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EWG);
0000ec  6802              LDR      r2,[r0,#0]
0000ee  6953              LDR      r3,[r2,#0x14]
0000f0  f4437380          ORR      r3,r3,#0x100
0000f4  6153              STR      r3,[r2,#0x14]
;;;740          
;;;741          /* Enable Error passive Interrupt */
;;;742          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_EPV);
0000f6  6802              LDR      r2,[r0,#0]
0000f8  6953              LDR      r3,[r2,#0x14]
0000fa  f4437300          ORR      r3,r3,#0x200
0000fe  6153              STR      r3,[r2,#0x14]
;;;743          
;;;744          /* Enable Bus-off Interrupt */
;;;745          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_BOF);
000100  6802              LDR      r2,[r0,#0]
000102  6953              LDR      r3,[r2,#0x14]
000104  f4436380          ORR      r3,r3,#0x400
000108  6153              STR      r3,[r2,#0x14]
;;;746          
;;;747          /* Enable Last error code Interrupt */
;;;748          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_LEC);
00010a  e001              B        |L17.272|
                  |L17.268|
00010c  e022              B        |L17.340|
00010e  e013              B        |L17.312|
                  |L17.272|
000110  6802              LDR      r2,[r0,#0]
000112  6953              LDR      r3,[r2,#0x14]
000114  f4436300          ORR      r3,r3,#0x800
000118  6153              STR      r3,[r2,#0x14]
;;;749          
;;;750          /* Enable Error Interrupt */
;;;751          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_ERR);
00011a  6802              LDR      r2,[r0,#0]
00011c  6953              LDR      r3,[r2,#0x14]
00011e  f4434300          ORR      r3,r3,#0x8000
000122  6153              STR      r3,[r2,#0x14]
;;;752          
;;;753          /* Enable Transmit mailbox empty Interrupt */
;;;754          __HAL_CAN_ENABLE_IT(hcan, CAN_IT_TME);
000124  6802              LDR      r2,[r0,#0]
000126  6953              LDR      r3,[r2,#0x14]
000128  f0430301          ORR      r3,r3,#1
00012c  6153              STR      r3,[r2,#0x14]
;;;755          
;;;756          /* Request transmission */
;;;757          hcan->Instance->sTxMailBox[transmitmailbox].TIR |= CAN_TI0R_TXRQ;
00012e  6800              LDR      r0,[r0,#0]
000130  5842              LDR      r2,[r0,r1]
000132  f0420201          ORR      r2,r2,#1
000136  5042              STR      r2,[r0,r1]
                  |L17.312|
;;;758        }
;;;759      }
;;;760      else
;;;761      {
;;;762        return HAL_BUSY;
;;;763      }
;;;764      
;;;765      return HAL_OK;
000138  2000              MOVS     r0,#0
                  |L17.314|
;;;766    }
00013a  bd70              POP      {r4-r6,pc}
00013c  e7ff              B        |L17.318|
                  |L17.318|
00013e  6804              LDR      r4,[r0,#0]            ;695
000140  5865              LDR      r5,[r4,r1]            ;695
000142  68de              LDR      r6,[r3,#0xc]          ;695
000144  881b              LDRH     r3,[r3,#0]            ;695
000146  4335              ORRS     r5,r5,r6              ;695
000148  ea455343          ORR      r3,r5,r3,LSL #21      ;695
00014c  5063              STR      r3,[r4,r1]            ;695
00014e  e789              B        |L17.100|
                  |L17.336|
000150  2232              MOVS     r2,#0x32              ;724
000152  e7c5              B        |L17.224|
                  |L17.340|
000154  2002              MOVS     r0,#2                 ;762
000156  e7f0              B        |L17.314|
;;;767    
                          ENDP


                          AREA ||i.HAL_CAN_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxCpltCallback PROC
;;;1184     */
;;;1185   __weak void HAL_CAN_TxCpltCallback(CAN_HandleTypeDef* hcan)
000000  4770              BX       lr
;;;1186   {
;;;1187     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1188               the HAL_CAN_TxCpltCallback could be implemented in the user file
;;;1189      */
;;;1190   }
;;;1191   
                          ENDP


                          AREA ||i.HAL_CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  HAL_CAN_WakeUp PROC
;;;1007     */
;;;1008   HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef* hcan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1009   {
000004  4604              MOV      r4,r0
;;;1010     uint32_t timeout;
;;;1011       
;;;1012     /* Process locked */
;;;1013     __HAL_LOCK(hcan);
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  2801              CMP      r0,#1
00000c  d010              BEQ      |L19.48|
00000e  2601              MOVS     r6,#1
000010  f8846039          STRB     r6,[r4,#0x39]
;;;1014     
;;;1015     /* Change CAN state */
;;;1016     hcan->State = HAL_CAN_STATE_BUSY;  
000014  2002              MOVS     r0,#2
000016  f8840038          STRB     r0,[r4,#0x38]
;;;1017    
;;;1018     /* Wake up request */
;;;1019     hcan->Instance->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210102          BIC      r1,r1,#2
000022  6001              STR      r1,[r0,#0]
;;;1020       
;;;1021     /* Get timeout */
;;;1022     timeout = HAL_GetTick() + 10;   
000024  f7fffffe          BL       HAL_GetTick
000028  f100050a          ADD      r5,r0,#0xa
00002c  2700              MOVS     r7,#0
00002e  e00c              B        |L19.74|
                  |L19.48|
000030  2002              MOVS     r0,#2                 ;1013
                  |L19.50|
;;;1023     
;;;1024     /* Sleep mode status */
;;;1025     while((hcan->Instance->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)
;;;1026     {
;;;1027       if(HAL_GetTick() >= timeout)
;;;1028       {
;;;1029         hcan->State= HAL_CAN_STATE_TIMEOUT;
;;;1030         /* Process unlocked */
;;;1031         __HAL_UNLOCK(hcan);
;;;1032         return HAL_TIMEOUT;
;;;1033       }
;;;1034     }
;;;1035     if((hcan->Instance->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)
;;;1036     {
;;;1037       /* Return function status */
;;;1038       return HAL_ERROR;
;;;1039     }
;;;1040     
;;;1041     /* Change CAN state */
;;;1042     hcan->State = HAL_CAN_STATE_READY; 
;;;1043     
;;;1044     /* Process unlocked */
;;;1045     __HAL_UNLOCK(hcan);
;;;1046     
;;;1047     /* Return function status */
;;;1048     return HAL_OK;
;;;1049   }
000032  e8bd81f0          POP      {r4-r8,pc}
000036  bf00              NOP                            ;1027
                  |L19.56|
000038  f7fffffe          BL       HAL_GetTick
00003c  42a8              CMP      r0,r5                 ;1027
00003e  d304              BCC      |L19.74|
000040  2003              MOVS     r0,#3                 ;1029
000042  f8040f38          STRB     r0,[r4,#0x38]!        ;1029
000046  7067              STRB     r7,[r4,#1]            ;1031
000048  e7f3              B        |L19.50|
                  |L19.74|
00004a  6820              LDR      r0,[r4,#0]            ;1025
00004c  6840              LDR      r0,[r0,#4]            ;1025
00004e  0780              LSLS     r0,r0,#30             ;1025
000050  d4f2              BMI      |L19.56|
000052  6820              LDR      r0,[r4,#0]            ;1035
000054  6840              LDR      r0,[r0,#4]            ;1035
000056  0780              LSLS     r0,r0,#30             ;1035
000058  d501              BPL      |L19.94|
00005a  2001              MOVS     r0,#1                 ;1038
00005c  e7e9              B        |L19.50|
                  |L19.94|
00005e  f8046f38          STRB     r6,[r4,#0x38]!        ;1042
000062  2000              MOVS     r0,#0                 ;1048
000064  7067              STRB     r7,[r4,#1]            ;1045
000066  e7e4              B        |L19.50|
;;;1050   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_can_c_fe6cb454____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_can_c_fe6cb454____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_can_c_fe6cb454____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_can_c_fe6cb454____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
