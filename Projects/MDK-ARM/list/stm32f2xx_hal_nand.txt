; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_nand.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_nand.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_nand.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_nand.c]
                          THUMB

                          AREA ||i.HAL_NAND_Address_Inc||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Address_Inc PROC
;;;869      */
;;;870    uint32_t HAL_NAND_Address_Inc(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress)
000000  b530              PUSH     {r4,r5,lr}
;;;871    {
;;;872      uint32_t status = NAND_VALID_ADDRESS;
;;;873     
;;;874      /* Increment page address */
;;;875      pAddress->Page++;
000002  880b              LDRH     r3,[r1,#0]
000004  f44f7280          MOV      r2,#0x100             ;872
000008  1c5b              ADDS     r3,r3,#1
00000a  b29b              UXTH     r3,r3
00000c  800b              STRH     r3,[r1,#0]
;;;876    
;;;877      /* Check NAND address is valid */
;;;878      if(pAddress->Page == hnand->Info.BlockSize)
00000e  6ac4              LDR      r4,[r0,#0x2c]
000010  42a3              CMP      r3,r4
000012  d114              BNE      |L1.62|
;;;879      {
;;;880        pAddress->Page = 0;
000014  2300              MOVS     r3,#0
000016  800b              STRH     r3,[r1,#0]
;;;881        pAddress->Block++;
000018  888c              LDRH     r4,[r1,#4]
00001a  1c64              ADDS     r4,r4,#1
00001c  b2a4              UXTH     r4,r4
00001e  808c              STRH     r4,[r1,#4]
;;;882        
;;;883        if(pAddress->Block == hnand->Info.ZoneSize)
000020  6b45              LDR      r5,[r0,#0x34]
000022  42ac              CMP      r4,r5
000024  d10b              BNE      |L1.62|
;;;884        {
;;;885          pAddress->Block = 0;
000026  808b              STRH     r3,[r1,#4]
;;;886          pAddress->Zone++;
000028  884b              LDRH     r3,[r1,#2]
00002a  1c5b              ADDS     r3,r3,#1
00002c  b29b              UXTH     r3,r3
00002e  804b              STRH     r3,[r1,#2]
;;;887    
;;;888          if(pAddress->Zone == (hnand->Info.ZoneSize/ hnand->Info.BlockNbr))
000030  6b41              LDR      r1,[r0,#0x34]
000032  6b00              LDR      r0,[r0,#0x30]
000034  fbb1f0f0          UDIV     r0,r1,r0
000038  4298              CMP      r0,r3
00003a  d100              BNE      |L1.62|
;;;889          {
;;;890            status = NAND_INVALID_ADDRESS;
00003c  0052              LSLS     r2,r2,#1
                  |L1.62|
;;;891          }
;;;892        }
;;;893      } 
;;;894      
;;;895      return (status);
00003e  4610              MOV      r0,r2
;;;896    }
000040  bd30              POP      {r4,r5,pc}
;;;897    
                          ENDP


                          AREA ||i.HAL_NAND_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_NAND_DeInit PROC
;;;166      */
;;;167    HAL_StatusTypeDef HAL_NAND_DeInit(NAND_HandleTypeDef *hnand)  
000000  b510              PUSH     {r4,lr}
;;;168    {
000002  4604              MOV      r4,r0
;;;169      /* Initialize the low level hardware (MSP) */
;;;170      HAL_NAND_MspDeInit(hnand);
000004  f7fffffe          BL       HAL_NAND_MspDeInit
000008  e9d40100          LDRD     r0,r1,[r4,#0]
;;;171    
;;;172      /* Configure the NAND registers with their reset values */
;;;173      FMC_NAND_DeInit(hnand->Instance, hnand->Init.NandBank);
00000c  f7fffffe          BL       FSMC_NAND_DeInit
;;;174    
;;;175      /* Reset the NAND controller state */
;;;176      hnand->State = HAL_NAND_STATE_RESET;
000010  2000              MOVS     r0,#0
000012  f8840021          STRB     r0,[r4,#0x21]
;;;177    
;;;178      /* Release Lock */
;;;179      __HAL_UNLOCK(hnand);
000016  f8840020          STRB     r0,[r4,#0x20]
;;;180    
;;;181      return HAL_OK;
;;;182    }
00001a  bd10              POP      {r4,pc}
;;;183    
                          ENDP


                          AREA ||i.HAL_NAND_ECC_Disable||, CODE, READONLY, ALIGN=1

                  HAL_NAND_ECC_Disable PROC
;;;949      */  
;;;950    HAL_StatusTypeDef  HAL_NAND_ECC_Disable(NAND_HandleTypeDef *hnand)  
000000  b510              PUSH     {r4,lr}
;;;951    {
000002  4604              MOV      r4,r0
;;;952      /* Check the NAND controller state */
;;;953      if(hnand->State == HAL_NAND_STATE_BUSY)
000004  f8900021          LDRB     r0,[r0,#0x21]
000008  2802              CMP      r0,#2
00000a  d00a              BEQ      |L3.34|
;;;954      {
;;;955         return HAL_BUSY;
;;;956      }
;;;957    
;;;958      /* Update the NAND state */
;;;959      hnand->State = HAL_NAND_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  f8840021          STRB     r0,[r4,#0x21]
000012  e9d40100          LDRD     r0,r1,[r4,#0]
;;;960        
;;;961      /* Disable ECC feature */
;;;962      FMC_NAND_ECC_Disable(hnand->Instance, hnand->Init.NandBank);
000016  f7fffffe          BL       FSMC_NAND_ECC_Disable
;;;963      
;;;964      /* Update the NAND state */
;;;965      hnand->State = HAL_NAND_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  f8840021          STRB     r0,[r4,#0x21]
;;;966      
;;;967      return HAL_OK;  
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;968    }
000022  bd10              POP      {r4,pc}
;;;969    
                          ENDP


                          AREA ||i.HAL_NAND_ECC_Enable||, CODE, READONLY, ALIGN=1

                  HAL_NAND_ECC_Enable PROC
;;;923      */    
;;;924    HAL_StatusTypeDef  HAL_NAND_ECC_Enable(NAND_HandleTypeDef *hnand)
000000  b510              PUSH     {r4,lr}
;;;925    {
000002  4604              MOV      r4,r0
;;;926      /* Check the NAND controller state */
;;;927      if(hnand->State == HAL_NAND_STATE_BUSY)
000004  f8900021          LDRB     r0,[r0,#0x21]
000008  2802              CMP      r0,#2
00000a  d00a              BEQ      |L4.34|
;;;928      {
;;;929         return HAL_BUSY;
;;;930      }
;;;931    
;;;932      /* Update the NAND state */
;;;933      hnand->State = HAL_NAND_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  f8840021          STRB     r0,[r4,#0x21]
000012  e9d40100          LDRD     r0,r1,[r4,#0]
;;;934       
;;;935      /* Enable ECC feature */
;;;936      FMC_NAND_ECC_Enable(hnand->Instance, hnand->Init.NandBank);
000016  f7fffffe          BL       FSMC_NAND_ECC_Enable
;;;937      
;;;938      /* Update the NAND state */
;;;939      hnand->State = HAL_NAND_STATE_READY;
00001a  2001              MOVS     r0,#1
00001c  f8840021          STRB     r0,[r4,#0x21]
;;;940      
;;;941      return HAL_OK;  
000020  2000              MOVS     r0,#0
                  |L4.34|
;;;942    }
000022  bd10              POP      {r4,pc}
;;;943    
                          ENDP


                          AREA ||i.HAL_NAND_Erase_Block||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Erase_Block PROC
;;;770      */
;;;771    HAL_StatusTypeDef HAL_NAND_Erase_Block(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress)
000000  b5f0              PUSH     {r4-r7,lr}
;;;772    {
;;;773      uint32_t DeviceAddress = 0;
;;;774      
;;;775      /* Process Locked */
;;;776      __HAL_LOCK(hnand);
000002  f8902020          LDRB     r2,[r0,#0x20]
000006  2a01              CMP      r2,#1
000008  d04b              BEQ      |L5.162|
00000a  2401              MOVS     r4,#1
00000c  f8804020          STRB     r4,[r0,#0x20]
;;;777      
;;;778      /* Check the NAND controller state */
;;;779      if(hnand->State == HAL_NAND_STATE_BUSY)
000010  f8902021          LDRB     r2,[r0,#0x21]
000014  2a02              CMP      r2,#2
000016  d044              BEQ      |L5.162|
;;;780      {
;;;781         return HAL_BUSY;
;;;782      }
;;;783      
;;;784      /* Identify the device address */
;;;785      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000018  6842              LDR      r2,[r0,#4]
00001a  2a10              CMP      r2,#0x10
00001c  d043              BEQ      |L5.166|
;;;786      {
;;;787        DeviceAddress = NAND_DEVICE1;
;;;788      }
;;;789      else
;;;790      {
;;;791        DeviceAddress = NAND_DEVICE2;
00001e  07e2              LSLS     r2,r4,#31
                  |L5.32|
;;;792      }
;;;793      
;;;794      /* Update the NAND controller state */
;;;795      hnand->State = HAL_NAND_STATE_BUSY;  
000020  2302              MOVS     r3,#2
000022  f8803021          STRB     r3,[r0,#0x21]
;;;796      
;;;797      /* Send Erase block command sequence */
;;;798      *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = 0x60;
000026  f4423380          ORR      r3,r2,#0x10000
00002a  2560              MOVS     r5,#0x60
00002c  701d              STRB     r5,[r3,#0]
;;;799    
;;;800      *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_1st_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
00002e  888d              LDRH     r5,[r1,#4]
000030  884e              LDRH     r6,[r1,#2]
000032  6ac7              LDR      r7,[r0,#0x2c]
000034  f4423200          ORR      r2,r2,#0x20000
000038  fb065507          MLA      r5,r6,r7,r5
00003c  880f              LDRH     r7,[r1,#0]
00003e  6b46              LDR      r6,[r0,#0x34]
000040  fb057506          MLA      r5,r5,r6,r7
000044  7015              STRB     r5,[r2,#0]
;;;801      *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_2nd_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
000046  888d              LDRH     r5,[r1,#4]
000048  884e              LDRH     r6,[r1,#2]
00004a  6ac7              LDR      r7,[r0,#0x2c]
00004c  fb065507          MLA      r5,r6,r7,r5
000050  880f              LDRH     r7,[r1,#0]
000052  6b46              LDR      r6,[r0,#0x34]
000054  fb057506          MLA      r5,r5,r6,r7
000058  0a2d              LSRS     r5,r5,#8
00005a  7015              STRB     r5,[r2,#0]
;;;802      *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_3rd_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
00005c  888d              LDRH     r5,[r1,#4]
00005e  884e              LDRH     r6,[r1,#2]
000060  6ac7              LDR      r7,[r0,#0x2c]
000062  fb065507          MLA      r5,r6,r7,r5
000066  880f              LDRH     r7,[r1,#0]
000068  6b46              LDR      r6,[r0,#0x34]
00006a  fb057506          MLA      r5,r5,r6,r7
00006e  0c2d              LSRS     r5,r5,#16
000070  7015              STRB     r5,[r2,#0]
;;;803      
;;;804      /* for 512 and 1 GB devices, 4th cycle is required */     
;;;805      if(hnand->Info.BlockNbr >= 1024)
000072  6b05              LDR      r5,[r0,#0x30]
000074  f5b56f80          CMP      r5,#0x400
000078  d30a              BCC      |L5.144|
;;;806      {
;;;807        *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_4th_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
00007a  888d              LDRH     r5,[r1,#4]
00007c  884e              LDRH     r6,[r1,#2]
00007e  6ac7              LDR      r7,[r0,#0x2c]
000080  8809              LDRH     r1,[r1,#0]
000082  fb065507          MLA      r5,r6,r7,r5
000086  6b46              LDR      r6,[r0,#0x34]
000088  fb051106          MLA      r1,r5,r6,r1
00008c  0e09              LSRS     r1,r1,#24
00008e  7011              STRB     r1,[r2,#0]
                  |L5.144|
;;;808      }  
;;;809    		
;;;810      *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = 0xD0; 
000090  21d0              MOVS     r1,#0xd0
000092  7019              STRB     r1,[r3,#0]
;;;811      
;;;812      /* Update the NAND controller state */
;;;813      hnand->State = HAL_NAND_STATE_READY;
000094  f8804021          STRB     r4,[r0,#0x21]
;;;814      
;;;815      /* Process unlocked */
;;;816      __HAL_UNLOCK(hnand);    
000098  2100              MOVS     r1,#0
00009a  f8801020          STRB     r1,[r0,#0x20]
;;;817      
;;;818      return HAL_OK;  
00009e  4608              MOV      r0,r1
;;;819    }
0000a0  bdf0              POP      {r4-r7,pc}
                  |L5.162|
0000a2  2002              MOVS     r0,#2                 ;781
0000a4  bdf0              POP      {r4-r7,pc}
                  |L5.166|
0000a6  f04f42e0          MOV      r2,#0x70000000        ;787
0000aa  e7b9              B        |L5.32|
;;;820    
                          ENDP


                          AREA ||i.HAL_NAND_GetECC||, CODE, READONLY, ALIGN=1

                  HAL_NAND_GetECC PROC
;;;976      */
;;;977    HAL_StatusTypeDef  HAL_NAND_GetECC(NAND_HandleTypeDef *hnand, uint32_t *ECCval, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;978    {
000002  4604              MOV      r4,r0
;;;979      HAL_StatusTypeDef status = HAL_OK;
;;;980      
;;;981      /* Check the NAND controller state */
;;;982      if(hnand->State == HAL_NAND_STATE_BUSY)
000004  f8900021          LDRB     r0,[r0,#0x21]
000008  2802              CMP      r0,#2
00000a  d00b              BEQ      |L6.36|
;;;983      {
;;;984         return HAL_BUSY;
;;;985      }
;;;986      
;;;987      /* Update the NAND state */
;;;988      hnand->State = HAL_NAND_STATE_BUSY;  
00000c  2002              MOVS     r0,#2
00000e  f8840021          STRB     r0,[r4,#0x21]
;;;989       
;;;990      /* Get NAND ECC value */
;;;991      status = FMC_NAND_GetECC(hnand->Instance, ECCval, hnand->Init.NandBank, Timeout);
000012  e9d40500          LDRD     r0,r5,[r4,#0]
000016  4613              MOV      r3,r2
000018  462a              MOV      r2,r5
00001a  f7fffffe          BL       FSMC_NAND_GetECC
;;;992      
;;;993      /* Update the NAND state */
;;;994      hnand->State = HAL_NAND_STATE_READY;
00001e  2101              MOVS     r1,#1
000020  f8841021          STRB     r1,[r4,#0x21]
                  |L6.36|
;;;995    
;;;996      return status;  
;;;997    }
000024  bd70              POP      {r4-r6,pc}
;;;998                          
                          ENDP


                          AREA ||i.HAL_NAND_GetState||, CODE, READONLY, ALIGN=1

                  HAL_NAND_GetState PROC
;;;1023     */
;;;1024   HAL_NAND_StateTypeDef HAL_NAND_GetState(NAND_HandleTypeDef *hnand)
000000  f8900021          LDRB     r0,[r0,#0x21]
;;;1025   {
;;;1026     return hnand->State;
;;;1027   }
000004  4770              BX       lr
;;;1028   
                          ENDP


                          AREA ||i.HAL_NAND_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_NAND_IRQHandler PROC
;;;213    */
;;;214    void HAL_NAND_IRQHandler(NAND_HandleTypeDef *hnand)
000000  b510              PUSH     {r4,lr}
;;;215    {
000002  4604              MOV      r4,r0
000004  e9d40100          LDRD     r0,r1,[r4,#0]
;;;216      /* Check NAND interrupt Rising edge flag */
;;;217      if(__FMC_NAND_GET_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_RISING_EDGE))
000008  2910              CMP      r1,#0x10
00000a  d04d              BEQ      |L8.168|
00000c  f8d00024          LDR.W    r0,[r0,#0x24]
                  |L8.16|
000010  f0100f01          TST      r0,#1
000014  d00a              BEQ      |L8.44|
;;;218      {
;;;219        /* NAND interrupt callback*/
;;;220        HAL_NAND_ITCallback(hnand);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_NAND_ITCallback
;;;221      
;;;222        /* Clear NAND interrupt Rising edge pending bit */
;;;223        __FMC_NAND_CLEAR_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_RISING_EDGE);
00001c  6860              LDR      r0,[r4,#4]
00001e  2810              CMP      r0,#0x10
000020  6820              LDR      r0,[r4,#0]
000022  d043              BEQ      |L8.172|
000024  6a41              LDR      r1,[r0,#0x24]
000026  f0210101          BIC      r1,r1,#1
00002a  6241              STR      r1,[r0,#0x24]
                  |L8.44|
;;;224      }
;;;225      
;;;226      /* Check NAND interrupt Level flag */
;;;227      if(__FMC_NAND_GET_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_LEVEL))
00002c  6860              LDR      r0,[r4,#4]
00002e  2810              CMP      r0,#0x10
000030  6820              LDR      r0,[r4,#0]
000032  d040              BEQ      |L8.182|
000034  f8d00024          LDR.W    r0,[r0,#0x24]
                  |L8.56|
000038  f3c00040          UBFX     r0,r0,#1,#1
00003c  b150              CBZ      r0,|L8.84|
;;;228      {
;;;229        /* NAND interrupt callback*/
;;;230        HAL_NAND_ITCallback(hnand);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_NAND_ITCallback
;;;231      
;;;232        /* Clear NAND interrupt Level pending bit */
;;;233        __FMC_NAND_CLEAR_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_LEVEL);
000044  6860              LDR      r0,[r4,#4]
000046  2810              CMP      r0,#0x10
000048  6820              LDR      r0,[r4,#0]
00004a  d036              BEQ      |L8.186|
00004c  6a41              LDR      r1,[r0,#0x24]
00004e  f0210102          BIC      r1,r1,#2
000052  6241              STR      r1,[r0,#0x24]
                  |L8.84|
;;;234      }
;;;235    
;;;236      /* Check NAND interrupt Falling edge flag */
;;;237      if(__FMC_NAND_GET_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_FALLING_EDGE))
000054  6860              LDR      r0,[r4,#4]
000056  2810              CMP      r0,#0x10
000058  6820              LDR      r0,[r4,#0]
00005a  d033              BEQ      |L8.196|
00005c  f8d00024          LDR.W    r0,[r0,#0x24]
                  |L8.96|
000060  f3c00080          UBFX     r0,r0,#2,#1
000064  b150              CBZ      r0,|L8.124|
;;;238      {
;;;239        /* NAND interrupt callback*/
;;;240        HAL_NAND_ITCallback(hnand);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_NAND_ITCallback
;;;241      
;;;242        /* Clear NAND interrupt Falling edge pending bit */
;;;243        __FMC_NAND_CLEAR_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_FALLING_EDGE);
00006c  6860              LDR      r0,[r4,#4]
00006e  2810              CMP      r0,#0x10
000070  6820              LDR      r0,[r4,#0]
000072  d029              BEQ      |L8.200|
000074  6a41              LDR      r1,[r0,#0x24]
000076  f0210104          BIC      r1,r1,#4
00007a  6241              STR      r1,[r0,#0x24]
                  |L8.124|
;;;244      }
;;;245      
;;;246      /* Check NAND interrupt FIFO empty flag */
;;;247      if(__FMC_NAND_GET_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_FEMPT))
00007c  6860              LDR      r0,[r4,#4]
00007e  2810              CMP      r0,#0x10
000080  6820              LDR      r0,[r4,#0]
000082  d026              BEQ      |L8.210|
000084  f8d00024          LDR.W    r0,[r0,#0x24]
                  |L8.136|
000088  f3c01080          UBFX     r0,r0,#6,#1
00008c  2800              CMP      r0,#0
00008e  d00a              BEQ      |L8.166|
;;;248      {
;;;249        /* NAND interrupt callback*/
;;;250        HAL_NAND_ITCallback(hnand);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       HAL_NAND_ITCallback
;;;251      
;;;252        /* Clear NAND interrupt FIFO empty pending bit */
;;;253        __FMC_NAND_CLEAR_FLAG(hnand->Instance, hnand->Init.NandBank, FMC_FLAG_FEMPT);
000096  6860              LDR      r0,[r4,#4]
000098  2810              CMP      r0,#0x10
00009a  6820              LDR      r0,[r4,#0]
00009c  d01b              BEQ      |L8.214|
00009e  6a41              LDR      r1,[r0,#0x24]
0000a0  f0210140          BIC      r1,r1,#0x40
0000a4  6241              STR      r1,[r0,#0x24]
                  |L8.166|
;;;254      }  
;;;255    
;;;256    }
0000a6  bd10              POP      {r4,pc}
                  |L8.168|
0000a8  6840              LDR      r0,[r0,#4]            ;217
0000aa  e7b1              B        |L8.16|
                  |L8.172|
0000ac  6841              LDR      r1,[r0,#4]            ;223
0000ae  f0210101          BIC      r1,r1,#1              ;223
0000b2  6041              STR      r1,[r0,#4]            ;223
0000b4  e7ba              B        |L8.44|
                  |L8.182|
0000b6  6840              LDR      r0,[r0,#4]            ;227
0000b8  e7be              B        |L8.56|
                  |L8.186|
0000ba  6841              LDR      r1,[r0,#4]            ;233
0000bc  f0210102          BIC      r1,r1,#2              ;233
0000c0  6041              STR      r1,[r0,#4]            ;233
0000c2  e7c7              B        |L8.84|
                  |L8.196|
0000c4  6840              LDR      r0,[r0,#4]            ;237
0000c6  e7cb              B        |L8.96|
                  |L8.200|
0000c8  6841              LDR      r1,[r0,#4]            ;243
0000ca  f0210104          BIC      r1,r1,#4              ;243
0000ce  6041              STR      r1,[r0,#4]            ;243
0000d0  e7d4              B        |L8.124|
                  |L8.210|
0000d2  6840              LDR      r0,[r0,#4]            ;247
0000d4  e7d8              B        |L8.136|
                  |L8.214|
0000d6  6841              LDR      r1,[r0,#4]            ;253
0000d8  f0210140          BIC      r1,r1,#0x40           ;253
0000dc  6041              STR      r1,[r0,#4]            ;253
0000de  bd10              POP      {r4,pc}
;;;257    
                          ENDP


                          AREA ||i.HAL_NAND_ITCallback||, CODE, READONLY, ALIGN=1

                  HAL_NAND_ITCallback PROC
;;;262      */
;;;263    __weak void HAL_NAND_ITCallback(NAND_HandleTypeDef *hnand)
000000  4770              BX       lr
;;;264    {
;;;265      /* NOTE : This function Should not be modified, when the callback is needed,
;;;266                the HAL_NAND_ITCallback could be implemented in the user file
;;;267       */
;;;268    }
;;;269     
                          ENDP


                          AREA ||i.HAL_NAND_Init||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Init PROC
;;;129      */
;;;130    HAL_StatusTypeDef  HAL_NAND_Init(NAND_HandleTypeDef *hnand, FMC_NAND_PCC_TimingTypeDef *ComSpace_Timing, FMC_NAND_PCC_TimingTypeDef *AttSpace_Timing)
000000  b570              PUSH     {r4-r6,lr}
;;;131    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L10.18|
;;;132      /* Check the NAND handle state */
;;;133      if(hnand == NULL)
;;;134      {
;;;135         return HAL_ERROR;
;;;136      }
;;;137    
;;;138      if(hnand->State == HAL_NAND_STATE_RESET)
00000a  f8940021          LDRB     r0,[r4,#0x21]
00000e  b110              CBZ      r0,|L10.22|
000010  e004              B        |L10.28|
                  |L10.18|
000012  2001              MOVS     r0,#1                 ;135
;;;139      {
;;;140        /* Initialize the low level hardware (MSP) */
;;;141        HAL_NAND_MspInit(hnand);
;;;142      } 
;;;143    
;;;144      /* Initialize NAND control Interface */
;;;145      FMC_NAND_Init(hnand->Instance, &(hnand->Init));
;;;146      
;;;147      /* Initialize NAND common space timing Interface */  
;;;148      FMC_NAND_CommonSpace_Timing_Init(hnand->Instance, ComSpace_Timing, hnand->Init.NandBank);
;;;149      
;;;150      /* Initialize NAND attribute space timing Interface */  
;;;151      FMC_NAND_AttributeSpace_Timing_Init(hnand->Instance, AttSpace_Timing, hnand->Init.NandBank);
;;;152      
;;;153      /* Enable the NAND device */
;;;154      __FMC_NAND_ENABLE(hnand->Instance, hnand->Init.NandBank);
;;;155      
;;;156      /* Update the NAND controller state */
;;;157      hnand->State = HAL_NAND_STATE_READY;
;;;158    
;;;159      return HAL_OK;
;;;160    }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  4620              MOV      r0,r4                 ;141
000018  f7fffffe          BL       HAL_NAND_MspInit
                  |L10.28|
00001c  1d21              ADDS     r1,r4,#4              ;145
00001e  6820              LDR      r0,[r4,#0]            ;145
000020  f7fffffe          BL       FSMC_NAND_Init
000024  e9d40200          LDRD     r0,r2,[r4,#0]         ;148
000028  4631              MOV      r1,r6                 ;148
00002a  f7fffffe          BL       FSMC_NAND_CommonSpace_Timing_Init
00002e  e9d40200          LDRD     r0,r2,[r4,#0]         ;151
000032  4629              MOV      r1,r5                 ;151
000034  f7fffffe          BL       FSMC_NAND_AttributeSpace_Timing_Init
000038  6860              LDR      r0,[r4,#4]            ;154
00003a  2810              CMP      r0,#0x10              ;154
00003c  6820              LDR      r0,[r4,#0]            ;154
00003e  d008              BEQ      |L10.82|
000040  6a01              LDR      r1,[r0,#0x20]         ;154
000042  f0410104          ORR      r1,r1,#4              ;154
000046  6201              STR      r1,[r0,#0x20]         ;154
                  |L10.72|
000048  2001              MOVS     r0,#1                 ;157
00004a  f8840021          STRB     r0,[r4,#0x21]         ;157
00004e  2000              MOVS     r0,#0                 ;159
000050  bd70              POP      {r4-r6,pc}
                  |L10.82|
000052  6801              LDR      r1,[r0,#0]            ;154
000054  f0410104          ORR      r1,r1,#4              ;154
000058  6001              STR      r1,[r0,#0]            ;154
00005a  e7f5              B        |L10.72|
;;;161    
                          ENDP


                          AREA ||i.HAL_NAND_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_NAND_MspDeInit PROC
;;;200      */
;;;201    __weak void HAL_NAND_MspDeInit(NAND_HandleTypeDef *hnand)
000000  4770              BX       lr
;;;202    {
;;;203      /* NOTE : This function Should not be modified, when the callback is needed,
;;;204                the HAL_NAND_MspDeInit could be implemented in the user file
;;;205       */ 
;;;206    }
;;;207    
                          ENDP


                          AREA ||i.HAL_NAND_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_NAND_MspInit PROC
;;;188      */
;;;189    __weak void HAL_NAND_MspInit(NAND_HandleTypeDef *hnand)
000000  4770              BX       lr
;;;190    {
;;;191      /* NOTE : This function Should not be modified, when the callback is needed,
;;;192                the HAL_NAND_MspInit could be implemented in the user file
;;;193       */ 
;;;194    }
;;;195    
                          ENDP


                          AREA ||i.HAL_NAND_Read_ID||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Read_ID PROC
;;;294      */
;;;295    HAL_StatusTypeDef HAL_NAND_Read_ID(NAND_HandleTypeDef *hnand, NAND_IDTypeDef *pNAND_ID)
000000  b578              PUSH     {r3-r6,lr}
;;;296    {
;;;297      __IO uint32_t data = 0;
000002  2300              MOVS     r3,#0
;;;298      uint32_t deviceAddress = 0;
;;;299    
;;;300      /* Process Locked */
;;;301      __HAL_LOCK(hnand);  
000004  9300              STR      r3,[sp,#0]
000006  f8902020          LDRB     r2,[r0,#0x20]
00000a  2a01              CMP      r2,#1
00000c  d025              BEQ      |L13.90|
00000e  2401              MOVS     r4,#1
000010  f8804020          STRB     r4,[r0,#0x20]
;;;302      
;;;303      /* Check the NAND controller state */
;;;304      if(hnand->State == HAL_NAND_STATE_BUSY)
000014  f8902021          LDRB     r2,[r0,#0x21]
000018  2a02              CMP      r2,#2
00001a  d01e              BEQ      |L13.90|
;;;305      {
;;;306         return HAL_BUSY;
;;;307      }
;;;308      
;;;309      /* Identify the device address */
;;;310      if(hnand->Init.NandBank == FMC_NAND_BANK2)
00001c  6842              LDR      r2,[r0,#4]
00001e  2a10              CMP      r2,#0x10
000020  d01d              BEQ      |L13.94|
;;;311      {
;;;312        deviceAddress = NAND_DEVICE1;
;;;313      }
;;;314      else
;;;315      {
;;;316        deviceAddress = NAND_DEVICE2;
000022  07e2              LSLS     r2,r4,#31
                  |L13.36|
;;;317      }
;;;318      
;;;319      /* Update the NAND controller state */ 
;;;320      hnand->State = HAL_NAND_STATE_BUSY;
000024  2502              MOVS     r5,#2
000026  f8005f21          STRB     r5,[r0,#0x21]!
;;;321      
;;;322      /* Send Read ID command sequence */ 	
;;;323      *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA))  = 0x90;
00002a  f4423680          ORR      r6,r2,#0x10000
00002e  2590              MOVS     r5,#0x90
000030  7035              STRB     r5,[r6,#0]
;;;324      *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00;
000032  f4423500          ORR      r5,r2,#0x20000
000036  702b              STRB     r3,[r5,#0]
;;;325    
;;;326      /* Read the electronic signature from NAND flash */	
;;;327      data = *(__IO uint32_t *)deviceAddress;
000038  6812              LDR      r2,[r2,#0]
;;;328      
;;;329      /* Return the data read */
;;;330      pNAND_ID->Maker_Id   = ADDR_1st_CYCLE(data);
00003a  9200              STR      r2,[sp,#0]
00003c  700a              STRB     r2,[r1,#0]
;;;331      pNAND_ID->Device_Id  = ADDR_2nd_CYCLE(data);
00003e  9a00              LDR      r2,[sp,#0]
000040  0a12              LSRS     r2,r2,#8
000042  704a              STRB     r2,[r1,#1]
;;;332      pNAND_ID->Third_Id   = ADDR_3rd_CYCLE(data);
000044  9a00              LDR      r2,[sp,#0]
000046  0c12              LSRS     r2,r2,#16
000048  708a              STRB     r2,[r1,#2]
;;;333      pNAND_ID->Fourth_Id  = ADDR_4th_CYCLE(data);
00004a  9a00              LDR      r2,[sp,#0]
00004c  0e12              LSRS     r2,r2,#24
00004e  70ca              STRB     r2,[r1,#3]
;;;334      
;;;335      /* Update the NAND controller state */ 
;;;336      hnand->State = HAL_NAND_STATE_READY;
000050  f8004901          STRB     r4,[r0],#-1
;;;337      
;;;338      /* Process unlocked */
;;;339      __HAL_UNLOCK(hnand);   
000054  7003              STRB     r3,[r0,#0]
;;;340       
;;;341      return HAL_OK;
000056  2000              MOVS     r0,#0
;;;342    }
000058  bd78              POP      {r3-r6,pc}
                  |L13.90|
00005a  2002              MOVS     r0,#2                 ;306
00005c  bd78              POP      {r3-r6,pc}
                  |L13.94|
00005e  f04f42e0          MOV      r2,#0x70000000        ;312
000062  e7df              B        |L13.36|
;;;343    
                          ENDP


                          AREA ||i.HAL_NAND_Read_Page||, CODE, READONLY, ALIGN=2

                  HAL_NAND_Read_Page PROC
;;;397      */
;;;398    HAL_StatusTypeDef HAL_NAND_Read_Page(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress, uint8_t *pBuffer, uint32_t NumPageToRead)
000000  e92d47f8          PUSH     {r3-r10,lr}
;;;399    {   
;;;400      __IO uint32_t index  = 0;
000004  2500              MOVS     r5,#0
;;;401      uint32_t deviceAddress = 0, size = 0, numPagesRead = 0, nandAddress = 0;
;;;402      
;;;403      /* Process Locked */
;;;404      __HAL_LOCK(hnand); 
000006  9500              STR      r5,[sp,#0]
000008  f8904020          LDRB     r4,[r0,#0x20]
00000c  462e              MOV      r6,r5                 ;401
00000e  2c01              CMP      r4,#1
000010  d01d              BEQ      |L14.78|
000012  f04f0901          MOV      r9,#1
000016  f8809020          STRB     r9,[r0,#0x20]
;;;405      
;;;406      /* Check the NAND controller state */
;;;407      if(hnand->State == HAL_NAND_STATE_BUSY)
00001a  f8904021          LDRB     r4,[r0,#0x21]
00001e  2c02              CMP      r4,#2
000020  d015              BEQ      |L14.78|
;;;408      {
;;;409         return HAL_BUSY;
;;;410      }
;;;411      
;;;412      /* Identify the device address */
;;;413      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000022  6844              LDR      r4,[r0,#4]
000024  2c10              CMP      r4,#0x10
000026  d015              BEQ      |L14.84|
;;;414      {
;;;415        deviceAddress = NAND_DEVICE1;
;;;416      }
;;;417      else
;;;418      {
;;;419        deviceAddress = NAND_DEVICE2;
000028  f04f4400          MOV      r4,#0x80000000
                  |L14.44|
;;;420      }
;;;421    
;;;422      /* Update the NAND controller state */ 
;;;423      hnand->State = HAL_NAND_STATE_BUSY;
00002c  2702              MOVS     r7,#2
00002e  f8807021          STRB     r7,[r0,#0x21]
;;;424      
;;;425      /* NAND raw address calculation */
;;;426      nandAddress = ARRAY_ADDRESS(pAddress, hnand);
000032  888f              LDRH     r7,[r1,#4]
000034  f8b1c002          LDRH     r12,[r1,#2]
000038  f8d0802c          LDR      r8,[r0,#0x2c]
00003c  8809              LDRH     r1,[r1,#0]
00003e  fb0c7708          MLA      r7,r12,r8,r7
000042  f8d0c034          LDR      r12,[r0,#0x34]
000046  46a8              MOV      r8,r5
000048  fb07110c          MLA      r1,r7,r12,r1
;;;427      
;;;428      /* Page(s) read loop */  
;;;429      while((NumPageToRead != 0) && (nandAddress < (hnand->Info.BlockSize) * (hnand->Info.PageSize)))
00004c  e036              B        |L14.188|
                  |L14.78|
00004e  2002              MOVS     r0,#2                 ;409
                  |L14.80|
;;;430      {	   
;;;431        /* update the buffer size */
;;;432        size = (hnand->Info.PageSize) + ((hnand->Info.PageSize) * numPagesRead);
;;;433        
;;;434        /* Send read page command sequence */
;;;435        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;  
;;;436       
;;;437        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00; 
;;;438        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1st_CYCLE(nandAddress); 
;;;439        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2nd_CYCLE(nandAddress); 
;;;440        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3rd_CYCLE(nandAddress);
;;;441      
;;;442        /* for 512 and 1 GB devices, 4th cycle is required */    
;;;443        if(hnand->Info.BlockNbr >= 1024)
;;;444        {
;;;445          *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_4th_CYCLE(nandAddress);
;;;446        }
;;;447      
;;;448        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA))  = 0x30;
;;;449          
;;;450        /* Get Data into Buffer */    
;;;451        for(; index < size; index++)
;;;452        {
;;;453          *(uint8_t *)pBuffer++ = *(uint8_t *)deviceAddress;
;;;454        }
;;;455        
;;;456        /* Increment read pages number */
;;;457        numPagesRead++;
;;;458        
;;;459        /* Decrement pages to read */
;;;460        NumPageToRead--;
;;;461        
;;;462        /* Increment the NAND address */
;;;463        nandAddress = (uint32_t)(nandAddress + (hnand->Info.PageSize * 8));   
;;;464        
;;;465      }
;;;466      
;;;467      /* Update the NAND controller state */ 
;;;468      hnand->State = HAL_NAND_STATE_READY;
;;;469      
;;;470      /* Process unlocked */
;;;471      __HAL_UNLOCK(hnand);  
;;;472        
;;;473      return HAL_OK;
;;;474    
;;;475    }
000050  e8bd87f8          POP      {r3-r10,pc}
                  |L14.84|
000054  f04f44e0          MOV      r4,#0x70000000        ;415
000058  e7e8              B        |L14.44|
00005a  bf00              NOP                            ;432
                  |L14.92|
00005c  fb055706          MLA      r7,r5,r6,r5           ;432
000060  f4443580          ORR      r5,r4,#0x10000        ;435
000064  46aa              MOV      r10,r5                ;435
000066  f8858000          STRB     r8,[r5,#0]            ;435
00006a  f4443500          ORR      r5,r4,#0x20000        ;437
00006e  f8858000          STRB     r8,[r5,#0]            ;437
000072  7029              STRB     r1,[r5,#0]            ;438
000074  ea4f2c11          LSR      r12,r1,#8             ;439
000078  f885c000          STRB     r12,[r5,#0]           ;439
00007c  ea4f4c11          LSR      r12,r1,#16            ;440
000080  f885c000          STRB     r12,[r5,#0]           ;440
000084  f8d0c030          LDR      r12,[r0,#0x30]        ;443
000088  f5bc6f80          CMP      r12,#0x400            ;443
00008c  d303              BCC      |L14.150|
00008e  ea4f6c11          LSR      r12,r1,#24            ;445
000092  f885c000          STRB     r12,[r5,#0]           ;445
                  |L14.150|
000096  f04f0c30          MOV      r12,#0x30             ;448
00009a  f88ac000          STRB     r12,[r10,#0]          ;448
00009e  9d00              LDR      r5,[sp,#0]            ;451
0000a0  e005              B        |L14.174|
                  |L14.162|
0000a2  7825              LDRB     r5,[r4,#0]            ;453
0000a4  f8025b01          STRB     r5,[r2],#1            ;453
0000a8  9d00              LDR      r5,[sp,#0]            ;451
0000aa  1c6d              ADDS     r5,r5,#1              ;451
0000ac  9500              STR      r5,[sp,#0]            ;451
                  |L14.174|
0000ae  42bd              CMP      r5,r7                 ;451
0000b0  d3f7              BCC      |L14.162|
0000b2  6a45              LDR      r5,[r0,#0x24]         ;463
0000b4  1e5b              SUBS     r3,r3,#1              ;463
0000b6  eb0101c5          ADD      r1,r1,r5,LSL #3       ;463
0000ba  1c76              ADDS     r6,r6,#1              ;463
                  |L14.188|
0000bc  b123              CBZ      r3,|L14.200|
0000be  6ac7              LDR      r7,[r0,#0x2c]         ;429
0000c0  6a45              LDR      r5,[r0,#0x24]         ;429
0000c2  436f              MULS     r7,r5,r7              ;429
0000c4  428f              CMP      r7,r1                 ;429
0000c6  d8c9              BHI      |L14.92|
                  |L14.200|
0000c8  f8809021          STRB     r9,[r0,#0x21]         ;468
0000cc  f8808020          STRB     r8,[r0,#0x20]         ;471
0000d0  2000              MOVS     r0,#0                 ;473
0000d2  e7bd              B        |L14.80|
;;;476    
                          ENDP


                          AREA ||i.HAL_NAND_Read_SpareArea||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Read_SpareArea PROC
;;;585    */
;;;586    HAL_StatusTypeDef HAL_NAND_Read_SpareArea(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaToRead)
000000  e92d47f8          PUSH     {r3-r10,lr}
;;;587    {
;;;588      __IO uint32_t index   = 0; 
000004  2500              MOVS     r5,#0
;;;589      uint32_t deviceAddress = 0, size = 0, numSpareAreaRead = 0, nandAddress = 0;
;;;590      
;;;591      /* Process Locked */
;;;592      __HAL_LOCK(hnand);  
000006  9500              STR      r5,[sp,#0]
000008  f8904020          LDRB     r4,[r0,#0x20]
00000c  462e              MOV      r6,r5                 ;589
00000e  2c01              CMP      r4,#1
000010  d01d              BEQ      |L15.78|
000012  f04f0901          MOV      r9,#1
000016  f8809020          STRB     r9,[r0,#0x20]
;;;593      
;;;594      /* Check the NAND controller state */
;;;595      if(hnand->State == HAL_NAND_STATE_BUSY)
00001a  f8904021          LDRB     r4,[r0,#0x21]
00001e  2c02              CMP      r4,#2
000020  d015              BEQ      |L15.78|
;;;596      {
;;;597         return HAL_BUSY;
;;;598      }
;;;599      
;;;600      /* Identify the device address */
;;;601      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000022  6844              LDR      r4,[r0,#4]
000024  2c10              CMP      r4,#0x10
000026  d015              BEQ      |L15.84|
;;;602      {
;;;603        deviceAddress = NAND_DEVICE1;
;;;604      }
;;;605      else
;;;606      {
;;;607        deviceAddress = NAND_DEVICE2;
000028  f04f4400          MOV      r4,#0x80000000
                  |L15.44|
;;;608      }
;;;609      
;;;610      /* Update the NAND controller state */
;;;611      hnand->State = HAL_NAND_STATE_BUSY; 
00002c  2702              MOVS     r7,#2
00002e  f8807021          STRB     r7,[r0,#0x21]
;;;612      
;;;613      /* NAND raw address calculation */
;;;614      nandAddress = ARRAY_ADDRESS(pAddress, hnand);    
000032  888f              LDRH     r7,[r1,#4]
000034  f8b1c002          LDRH     r12,[r1,#2]
000038  f8d0802c          LDR      r8,[r0,#0x2c]
00003c  8809              LDRH     r1,[r1,#0]
00003e  fb0c7708          MLA      r7,r12,r8,r7
000042  f8d0c034          LDR      r12,[r0,#0x34]
000046  46a8              MOV      r8,r5
000048  fb07110c          MLA      r1,r7,r12,r1
;;;615      
;;;616      /* Spare area(s) read loop */ 
;;;617      while((NumSpareAreaToRead != 0) && (nandAddress < (hnand->Info.BlockSize) * (hnand->Info.SpareAreaSize)))
00004c  e037              B        |L15.190|
                  |L15.78|
00004e  2002              MOVS     r0,#2                 ;597
                  |L15.80|
;;;618      {     
;;;619        
;;;620        /* update the buffer size */
;;;621        size = (hnand->Info.PageSize) + ((hnand->Info.PageSize) * numSpareAreaRead);
;;;622        
;;;623        /* Send read spare area command sequence */     
;;;624        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
;;;625    
;;;626        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00; 
;;;627        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1st_CYCLE(nandAddress);     
;;;628        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2nd_CYCLE(nandAddress);     
;;;629        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3rd_CYCLE(nandAddress);
;;;630      
;;;631        /* for 512 and 1 GB devices, 4th cycle is required */    
;;;632        if(hnand->Info.BlockNbr >= 1024)
;;;633        {
;;;634          *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_4th_CYCLE(nandAddress);
;;;635        } 
;;;636    
;;;637        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0x30;    
;;;638        
;;;639        /* Get Data into Buffer */
;;;640        for ( ;index < size; index++)
;;;641        {
;;;642          *(uint8_t *)pBuffer++ = *(uint8_t *)deviceAddress;
;;;643        }
;;;644        
;;;645        /* Increment read spare areas number */
;;;646        numSpareAreaRead++;
;;;647        
;;;648        /* Decrement spare areas to read */
;;;649        NumSpareAreaToRead--;
;;;650        
;;;651        /* Increment the NAND address */
;;;652        nandAddress = (uint32_t)(nandAddress + (hnand->Info.SpareAreaSize));
;;;653      }
;;;654      
;;;655      /* Update the NAND controller state */
;;;656      hnand->State = HAL_NAND_STATE_READY;
;;;657      
;;;658      /* Process unlocked */
;;;659      __HAL_UNLOCK(hnand);     
;;;660    
;;;661      return HAL_OK;  
;;;662    }
000050  e8bd87f8          POP      {r3-r10,pc}
                  |L15.84|
000054  f04f44e0          MOV      r4,#0x70000000        ;603
000058  e7e8              B        |L15.44|
                  |L15.90|
00005a  6a45              LDR      r5,[r0,#0x24]         ;621
00005c  f04f0c50          MOV      r12,#0x50             ;624
000060  fb055706          MLA      r7,r5,r6,r5           ;621
000064  f4443580          ORR      r5,r4,#0x10000        ;624
000068  46aa              MOV      r10,r5                ;624
00006a  f885c000          STRB     r12,[r5,#0]           ;624
00006e  f4443500          ORR      r5,r4,#0x20000        ;626
000072  f8858000          STRB     r8,[r5,#0]            ;626
000076  7029              STRB     r1,[r5,#0]            ;627
000078  ea4f2c11          LSR      r12,r1,#8             ;628
00007c  f885c000          STRB     r12,[r5,#0]           ;628
000080  ea4f4c11          LSR      r12,r1,#16            ;629
000084  f885c000          STRB     r12,[r5,#0]           ;629
000088  f8d0c030          LDR      r12,[r0,#0x30]        ;632
00008c  f5bc6f80          CMP      r12,#0x400            ;632
000090  d303              BCC      |L15.154|
000092  ea4f6c11          LSR      r12,r1,#24            ;634
000096  f885c000          STRB     r12,[r5,#0]           ;634
                  |L15.154|
00009a  f04f0c30          MOV      r12,#0x30             ;637
00009e  f88ac000          STRB     r12,[r10,#0]          ;637
0000a2  9d00              LDR      r5,[sp,#0]            ;640
0000a4  e005              B        |L15.178|
                  |L15.166|
0000a6  7825              LDRB     r5,[r4,#0]            ;642
0000a8  f8025b01          STRB     r5,[r2],#1            ;642
0000ac  9d00              LDR      r5,[sp,#0]            ;640
0000ae  1c6d              ADDS     r5,r5,#1              ;640
0000b0  9500              STR      r5,[sp,#0]            ;640
                  |L15.178|
0000b2  42bd              CMP      r5,r7                 ;640
0000b4  d3f7              BCC      |L15.166|
0000b6  6a85              LDR      r5,[r0,#0x28]         ;652
0000b8  1e5b              SUBS     r3,r3,#1              ;652
0000ba  4429              ADD      r1,r1,r5              ;652
0000bc  1c76              ADDS     r6,r6,#1              ;652
                  |L15.190|
0000be  b123              CBZ      r3,|L15.202|
0000c0  e9d0750a          LDRD     r7,r5,[r0,#0x28]      ;617
0000c4  437d              MULS     r5,r7,r5              ;617
0000c6  428d              CMP      r5,r1                 ;617
0000c8  d8c7              BHI      |L15.90|
                  |L15.202|
0000ca  f8809021          STRB     r9,[r0,#0x21]         ;656
0000ce  f8808020          STRB     r8,[r0,#0x20]         ;659
0000d2  2000              MOVS     r0,#0                 ;661
0000d4  e7bc              B        |L15.80|
;;;663    
                          ENDP


                          AREA ||i.HAL_NAND_Read_Status||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Read_Status PROC
;;;826      */
;;;827    uint32_t HAL_NAND_Read_Status(NAND_HandleTypeDef *hnand)
000000  6840              LDR      r0,[r0,#4]
;;;828    {
;;;829      uint32_t data = 0;
;;;830      uint32_t DeviceAddress = 0;
;;;831      
;;;832      /* Identify the device address */
;;;833      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000002  2810              CMP      r0,#0x10
000004  d00a              BEQ      |L16.28|
;;;834      {
;;;835        DeviceAddress = NAND_DEVICE1;
;;;836      }
;;;837      else
;;;838      {
;;;839        DeviceAddress = NAND_DEVICE2;
000006  f04f4000          MOV      r0,#0x80000000
                  |L16.10|
;;;840      } 
;;;841    
;;;842      /* Send Read status operation command */
;;;843      *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = 0x70;
00000a  f4403280          ORR      r2,r0,#0x10000
00000e  2170              MOVS     r1,#0x70
000010  7011              STRB     r1,[r2,#0]
;;;844      
;;;845      /* Read status register data */
;;;846      data = *(__IO uint8_t *)DeviceAddress;
000012  7800              LDRB     r0,[r0,#0]
;;;847    
;;;848      /* Return the status */
;;;849      if((data & NAND_ERROR) == NAND_ERROR)
000014  07c1              LSLS     r1,r0,#31
000016  d004              BEQ      |L16.34|
;;;850      {
;;;851        return NAND_ERROR;
000018  2001              MOVS     r0,#1
;;;852      } 
;;;853      else if((data & NAND_READY) == NAND_READY)
;;;854      {
;;;855        return NAND_READY;
;;;856      }
;;;857    
;;;858      return NAND_BUSY; 
;;;859     
;;;860    }
00001a  4770              BX       lr
                  |L16.28|
00001c  f04f40e0          MOV      r0,#0x70000000        ;835
000020  e7f3              B        |L16.10|
                  |L16.34|
000022  0640              LSLS     r0,r0,#25             ;853
000024  d501              BPL      |L16.42|
000026  2040              MOVS     r0,#0x40              ;855
000028  4770              BX       lr
                  |L16.42|
00002a  2000              MOVS     r0,#0                 ;858
00002c  4770              BX       lr
;;;861    
                          ENDP


                          AREA ||i.HAL_NAND_Reset||, CODE, READONLY, ALIGN=1

                  HAL_NAND_Reset PROC
;;;348      */
;;;349    HAL_StatusTypeDef HAL_NAND_Reset(NAND_HandleTypeDef *hnand)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;350    {
;;;351      uint32_t deviceAddress = 0;
;;;352      
;;;353      /* Process Locked */
;;;354      __HAL_LOCK(hnand);
000004  2901              CMP      r1,#1
000006  d017              BEQ      |L17.56|
000008  2201              MOVS     r2,#1
00000a  f8802020          STRB     r2,[r0,#0x20]
;;;355        
;;;356      /* Check the NAND controller state */
;;;357      if(hnand->State == HAL_NAND_STATE_BUSY)
00000e  f8901021          LDRB     r1,[r0,#0x21]
000012  2902              CMP      r1,#2
000014  d010              BEQ      |L17.56|
;;;358      {
;;;359         return HAL_BUSY;
;;;360      }
;;;361    
;;;362      /* Identify the device address */  
;;;363      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000016  6841              LDR      r1,[r0,#4]
000018  2910              CMP      r1,#0x10
00001a  d00f              BEQ      |L17.60|
;;;364      {
;;;365        deviceAddress = NAND_DEVICE1;
;;;366      }
;;;367      else
;;;368      {
;;;369        deviceAddress = NAND_DEVICE2;
00001c  07d1              LSLS     r1,r2,#31
                  |L17.30|
;;;370      }  
;;;371      
;;;372      /* Update the NAND controller state */   
;;;373      hnand->State = HAL_NAND_STATE_BUSY; 
00001e  2302              MOVS     r3,#2
000020  f8003f21          STRB     r3,[r0,#0x21]!
;;;374      
;;;375      /* Send NAND reset command */  
;;;376      *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0xFF;
000024  f4413180          ORR      r1,r1,#0x10000
000028  23ff              MOVS     r3,#0xff
00002a  700b              STRB     r3,[r1,#0]
;;;377        
;;;378      
;;;379      /* Update the NAND controller state */   
;;;380      hnand->State = HAL_NAND_STATE_READY;
00002c  f8002901          STRB     r2,[r0],#-1
;;;381      
;;;382      /* Process unlocked */
;;;383      __HAL_UNLOCK(hnand);    
000030  2100              MOVS     r1,#0
000032  7001              STRB     r1,[r0,#0]
;;;384      
;;;385      return HAL_OK;
000034  4608              MOV      r0,r1
;;;386      
;;;387    }
000036  4770              BX       lr
                  |L17.56|
000038  2002              MOVS     r0,#2                 ;359
00003a  4770              BX       lr
                  |L17.60|
00003c  f04f41e0          MOV      r1,#0x70000000        ;365
000040  e7ed              B        |L17.30|
;;;388    
                          ENDP


                          AREA ||i.HAL_NAND_Write_Page||, CODE, READONLY, ALIGN=2

                  HAL_NAND_Write_Page PROC
;;;484      */
;;;485    HAL_StatusTypeDef HAL_NAND_Write_Page(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress, uint8_t *pBuffer, uint32_t NumPageToWrite)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;486    {
000004  4604              MOV      r4,r0
;;;487      __IO uint32_t index   = 0;
000006  2000              MOVS     r0,#0
000008  4617              MOV      r7,r2                 ;486
;;;488      uint32_t timeout = 0;
;;;489      uint32_t deviceAddress = 0, size = 0 , numPagesWritten = 0, nandAddress = 0;
;;;490      
;;;491      /* Process Locked */
;;;492      __HAL_LOCK(hnand);  
00000a  9000              STR      r0,[sp,#0]
00000c  f8942020          LDRB     r2,[r4,#0x20]
000010  4699              MOV      r9,r3                 ;486
000012  4683              MOV      r11,r0                ;489
000014  2a01              CMP      r2,#1
000016  d019              BEQ      |L18.76|
000018  f04f0a01          MOV      r10,#1
00001c  f884a020          STRB     r10,[r4,#0x20]
;;;493    
;;;494      /* Check the NAND controller state */
;;;495      if(hnand->State == HAL_NAND_STATE_BUSY)
000020  f8942021          LDRB     r2,[r4,#0x21]
000024  2a02              CMP      r2,#2
000026  d011              BEQ      |L18.76|
;;;496      {
;;;497         return HAL_BUSY;
;;;498      }
;;;499      
;;;500      /* Identify the device address */
;;;501      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000028  6862              LDR      r2,[r4,#4]
00002a  2a10              CMP      r2,#0x10
00002c  d011              BEQ      |L18.82|
;;;502      {
;;;503        deviceAddress = NAND_DEVICE1;
;;;504      }
;;;505      else
;;;506      {
;;;507        deviceAddress = NAND_DEVICE2;
00002e  f04f4600          MOV      r6,#0x80000000
                  |L18.50|
;;;508      }
;;;509      
;;;510      /* Update the NAND controller state */ 
;;;511      hnand->State = HAL_NAND_STATE_BUSY;
000032  2202              MOVS     r2,#2
000034  f8842021          STRB     r2,[r4,#0x21]
;;;512      
;;;513      /* NAND raw address calculation */
;;;514      nandAddress = ARRAY_ADDRESS(pAddress, hnand);
000038  888a              LDRH     r2,[r1,#4]
00003a  884b              LDRH     r3,[r1,#2]
00003c  6ae5              LDR      r5,[r4,#0x2c]
00003e  8809              LDRH     r1,[r1,#0]
000040  fb032205          MLA      r2,r3,r5,r2
000044  6b63              LDR      r3,[r4,#0x34]
000046  fb021503          MLA      r5,r2,r3,r1
;;;515      
;;;516      /* Page(s) write loop */
;;;517      while((NumPageToWrite != 0) && (nandAddress < (hnand->Info.BlockSize) * (hnand->Info.PageSize)))
00004a  e03f              B        |L18.204|
                  |L18.76|
00004c  2002              MOVS     r0,#2                 ;497
                  |L18.78|
;;;518      {  
;;;519        /* update the buffer size */
;;;520        size = (hnand->Info.PageSize) + ((hnand->Info.PageSize) * numPagesWritten);
;;;521     
;;;522        /* Send write page command sequence */
;;;523        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
;;;524        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0x80;
;;;525    
;;;526        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00;  
;;;527        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1st_CYCLE(nandAddress);  
;;;528        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2nd_CYCLE(nandAddress);  
;;;529        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3rd_CYCLE(nandAddress);
;;;530      
;;;531        /* for 512 and 1 GB devices, 4th cycle is required */     
;;;532        if(hnand->Info.BlockNbr >= 1024)
;;;533        {
;;;534          *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_4th_CYCLE(nandAddress);
;;;535        }
;;;536      
;;;537        /* Write data to memory */
;;;538        for(; index < size; index++)
;;;539        {
;;;540          *(__IO uint8_t *)deviceAddress = *(uint8_t *)pBuffer++;
;;;541        }
;;;542       
;;;543        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0x10;
;;;544        
;;;545        /* Read status until NAND is ready */
;;;546        while(HAL_NAND_Read_Status(hnand) != NAND_READY)
;;;547        {
;;;548          /* Check for timeout value */
;;;549          timeout = HAL_GetTick() + NAND_WRITE_TIMEOUT;
;;;550        
;;;551          if(HAL_GetTick() >= timeout)
;;;552          {
;;;553            return HAL_TIMEOUT; 
;;;554          } 
;;;555        }    
;;;556     
;;;557        /* Increment written pages number */
;;;558        numPagesWritten++;
;;;559        
;;;560        /* Decrement pages to write */
;;;561        NumPageToWrite--;
;;;562        
;;;563        /* Increment the NAND address */
;;;564        nandAddress = (uint32_t)(nandAddress + (hnand->Info.PageSize * 8));
;;;565          
;;;566      }
;;;567      
;;;568      /* Update the NAND controller state */ 
;;;569      hnand->State = HAL_NAND_STATE_READY;
;;;570      
;;;571      /* Process unlocked */
;;;572      __HAL_UNLOCK(hnand);      
;;;573      
;;;574      return HAL_OK;
;;;575    }
00004e  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.82|
000052  f04f46e0          MOV      r6,#0x70000000        ;503
000056  e7ec              B        |L18.50|
                  |L18.88|
000058  f4463180          ORR      r1,r6,#0x10000        ;523
00005c  fb00020b          MLA      r2,r0,r11,r0          ;520
000060  2300              MOVS     r3,#0                 ;523
000062  700b              STRB     r3,[r1,#0]            ;523
000064  2080              MOVS     r0,#0x80              ;524
000066  7008              STRB     r0,[r1,#0]            ;524
000068  f4463000          ORR      r0,r6,#0x20000        ;526
00006c  7003              STRB     r3,[r0,#0]            ;526
00006e  7005              STRB     r5,[r0,#0]            ;527
000070  0a2b              LSRS     r3,r5,#8              ;528
000072  7003              STRB     r3,[r0,#0]            ;528
000074  0c2b              LSRS     r3,r5,#16             ;529
000076  7003              STRB     r3,[r0,#0]            ;529
000078  6b23              LDR      r3,[r4,#0x30]         ;532
00007a  f5b36f80          CMP      r3,#0x400             ;532
00007e  d309              BCC      |L18.148|
000080  0e2b              LSRS     r3,r5,#24             ;534
000082  7003              STRB     r3,[r0,#0]            ;534
000084  e006              B        |L18.148|
000086  bf00              NOP                            ;540
                  |L18.136|
000088  f8170b01          LDRB     r0,[r7],#1            ;540
00008c  7030              STRB     r0,[r6,#0]            ;540
00008e  9800              LDR      r0,[sp,#0]            ;538
000090  1c40              ADDS     r0,r0,#1              ;538
000092  9000              STR      r0,[sp,#0]            ;538
                  |L18.148|
000094  9800              LDR      r0,[sp,#0]            ;538
000096  4290              CMP      r0,r2                 ;538
000098  d3f6              BCC      |L18.136|
00009a  2010              MOVS     r0,#0x10              ;543
00009c  7008              STRB     r0,[r1,#0]            ;543
00009e  e009              B        |L18.180|
                  |L18.160|
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  f1007880          ADD      r8,r0,#0x1000000      ;549
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  4540              CMP      r0,r8                 ;551
0000ae  d301              BCC      |L18.180|
0000b0  2003              MOVS     r0,#3                 ;553
0000b2  e7cc              B        |L18.78|
                  |L18.180|
0000b4  4620              MOV      r0,r4                 ;546
0000b6  f7fffffe          BL       HAL_NAND_Read_Status
0000ba  2840              CMP      r0,#0x40              ;546
0000bc  d1f0              BNE      |L18.160|
0000be  6a60              LDR      r0,[r4,#0x24]         ;564
0000c0  f10b0b01          ADD      r11,r11,#1            ;558
0000c4  f1a90901          SUB      r9,r9,#1              ;561
0000c8  eb0505c0          ADD      r5,r5,r0,LSL #3       ;564
                  |L18.204|
0000cc  f1b90f00          CMP      r9,#0                 ;517
0000d0  d004              BEQ      |L18.220|
0000d2  6ae1              LDR      r1,[r4,#0x2c]         ;517
0000d4  6a60              LDR      r0,[r4,#0x24]         ;517
0000d6  4341              MULS     r1,r0,r1              ;517
0000d8  42a9              CMP      r1,r5                 ;517
0000da  d8bd              BHI      |L18.88|
                  |L18.220|
0000dc  f884a021          STRB     r10,[r4,#0x21]        ;569
0000e0  2000              MOVS     r0,#0                 ;572
0000e2  f8840020          STRB     r0,[r4,#0x20]         ;572
0000e6  e7b2              B        |L18.78|
;;;576    
                          ENDP


                          AREA ||i.HAL_NAND_Write_SpareArea||, CODE, READONLY, ALIGN=2

                  HAL_NAND_Write_SpareArea PROC
;;;671      */
;;;672    HAL_StatusTypeDef HAL_NAND_Write_SpareArea(NAND_HandleTypeDef *hnand, NAND_AddressTypedef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaTowrite)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;673    {
000004  4604              MOV      r4,r0
;;;674      __IO uint32_t index = 0;
000006  2000              MOVS     r0,#0
000008  4617              MOV      r7,r2                 ;673
;;;675      uint32_t timeout = 0;
;;;676      uint32_t deviceAddress = 0, size = 0, numSpareAreaWritten = 0, nandAddress = 0;
;;;677    
;;;678      /* Process Locked */
;;;679      __HAL_LOCK(hnand); 
00000a  9000              STR      r0,[sp,#0]
00000c  f8942020          LDRB     r2,[r4,#0x20]
000010  4699              MOV      r9,r3                 ;673
000012  4683              MOV      r11,r0                ;676
000014  2a01              CMP      r2,#1
000016  d019              BEQ      |L19.76|
000018  f04f0a01          MOV      r10,#1
00001c  f884a020          STRB     r10,[r4,#0x20]
;;;680      
;;;681      /* Check the NAND controller state */
;;;682      if(hnand->State == HAL_NAND_STATE_BUSY)
000020  f8942021          LDRB     r2,[r4,#0x21]
000024  2a02              CMP      r2,#2
000026  d011              BEQ      |L19.76|
;;;683      {
;;;684         return HAL_BUSY;
;;;685      }
;;;686      
;;;687      /* Identify the device address */
;;;688      if(hnand->Init.NandBank == FMC_NAND_BANK2)
000028  6862              LDR      r2,[r4,#4]
00002a  2a10              CMP      r2,#0x10
00002c  d011              BEQ      |L19.82|
;;;689      {
;;;690        deviceAddress = NAND_DEVICE1;
;;;691      }
;;;692      else
;;;693      {
;;;694        deviceAddress = NAND_DEVICE2;
00002e  f04f4600          MOV      r6,#0x80000000
                  |L19.50|
;;;695      }
;;;696      
;;;697      /* Update the FMC_NAND controller state */
;;;698      hnand->State = HAL_NAND_STATE_BUSY;
000032  2202              MOVS     r2,#2
000034  f8842021          STRB     r2,[r4,#0x21]
;;;699    
;;;700      /* NAND raw address calculation */
;;;701      nandAddress = ARRAY_ADDRESS(pAddress, hnand);  
000038  888a              LDRH     r2,[r1,#4]
00003a  884b              LDRH     r3,[r1,#2]
00003c  6ae5              LDR      r5,[r4,#0x2c]
00003e  8809              LDRH     r1,[r1,#0]
000040  fb032205          MLA      r2,r3,r5,r2
000044  6b63              LDR      r3,[r4,#0x34]
000046  fb021503          MLA      r5,r2,r3,r1
;;;702      
;;;703      /* Spare area(s) write loop */
;;;704      while((NumSpareAreaTowrite != 0) && (nandAddress < (hnand->Info.BlockSize) * (hnand->Info.SpareAreaSize)))
00004a  e040              B        |L19.206|
                  |L19.76|
00004c  2002              MOVS     r0,#2                 ;684
                  |L19.78|
;;;705      {  
;;;706        /* update the buffer size */
;;;707        size = (hnand->Info.PageSize) + ((hnand->Info.PageSize) * numSpareAreaWritten);
;;;708    
;;;709        /* Send write Spare area command sequence */
;;;710        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
;;;711        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0x80;
;;;712    
;;;713        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00;  
;;;714        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1st_CYCLE(nandAddress);  
;;;715        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2nd_CYCLE(nandAddress);  
;;;716        *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3rd_CYCLE(nandAddress); 
;;;717      
;;;718        /* for 512 and 1 GB devices, 4th cycle is required */     
;;;719        if(hnand->Info.BlockNbr >= 1024)
;;;720        {
;;;721          *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_4th_CYCLE(nandAddress);
;;;722        }
;;;723      
;;;724        /* Write data to memory */
;;;725        for(; index < size; index++)
;;;726        {
;;;727          *(__IO uint8_t *)deviceAddress = *(uint8_t *)pBuffer++;
;;;728        }
;;;729       
;;;730        *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0x10;
;;;731        
;;;732       
;;;733        /* Read status until NAND is ready */
;;;734        while(HAL_NAND_Read_Status(hnand) != NAND_READY)
;;;735        {
;;;736          /* Check for timeout value */
;;;737          timeout = HAL_GetTick() + NAND_WRITE_TIMEOUT;
;;;738        
;;;739          if(HAL_GetTick() >= timeout)
;;;740          {
;;;741            return HAL_TIMEOUT; 
;;;742          }   
;;;743        }
;;;744    
;;;745        /* Increment written spare areas number */
;;;746        numSpareAreaWritten++;
;;;747        
;;;748        /* Decrement spare areas to write */
;;;749        NumSpareAreaTowrite--;
;;;750        
;;;751        /* Increment the NAND address */
;;;752        nandAddress = (uint32_t)(nandAddress + (hnand->Info.PageSize));   
;;;753          
;;;754      }
;;;755    
;;;756      /* Update the NAND controller state */
;;;757      hnand->State = HAL_NAND_STATE_READY;
;;;758    
;;;759      /* Process unlocked */
;;;760      __HAL_UNLOCK(hnand);
;;;761        
;;;762      return HAL_OK;  
;;;763    }
00004e  e8bd8ff8          POP      {r3-r11,pc}
                  |L19.82|
000052  f04f46e0          MOV      r6,#0x70000000        ;690
000056  e7ec              B        |L19.50|
                  |L19.88|
000058  6a60              LDR      r0,[r4,#0x24]         ;707
00005a  f4463280          ORR      r2,r6,#0x10000        ;710
00005e  fb00010b          MLA      r1,r0,r11,r0          ;707
000062  2050              MOVS     r0,#0x50              ;710
000064  7010              STRB     r0,[r2,#0]            ;710
000066  2080              MOVS     r0,#0x80              ;711
000068  7010              STRB     r0,[r2,#0]            ;711
00006a  f4463000          ORR      r0,r6,#0x20000        ;713
00006e  2300              MOVS     r3,#0                 ;713
000070  7003              STRB     r3,[r0,#0]            ;713
000072  7005              STRB     r5,[r0,#0]            ;714
000074  0a2b              LSRS     r3,r5,#8              ;715
000076  7003              STRB     r3,[r0,#0]            ;715
000078  0c2b              LSRS     r3,r5,#16             ;716
00007a  7003              STRB     r3,[r0,#0]            ;716
00007c  6b23              LDR      r3,[r4,#0x30]         ;719
00007e  f5b36f80          CMP      r3,#0x400             ;719
000082  d309              BCC      |L19.152|
000084  0e2b              LSRS     r3,r5,#24             ;721
000086  7003              STRB     r3,[r0,#0]            ;721
000088  e006              B        |L19.152|
00008a  bf00              NOP                            ;727
                  |L19.140|
00008c  f8170b01          LDRB     r0,[r7],#1            ;727
000090  7030              STRB     r0,[r6,#0]            ;727
000092  9800              LDR      r0,[sp,#0]            ;725
000094  1c40              ADDS     r0,r0,#1              ;725
000096  9000              STR      r0,[sp,#0]            ;725
                  |L19.152|
000098  9800              LDR      r0,[sp,#0]            ;725
00009a  4288              CMP      r0,r1                 ;725
00009c  d3f6              BCC      |L19.140|
00009e  2010              MOVS     r0,#0x10              ;730
0000a0  7010              STRB     r0,[r2,#0]            ;730
0000a2  e009              B        |L19.184|
                  |L19.164|
0000a4  f7fffffe          BL       HAL_GetTick
0000a8  f1007880          ADD      r8,r0,#0x1000000      ;737
0000ac  f7fffffe          BL       HAL_GetTick
0000b0  4540              CMP      r0,r8                 ;739
0000b2  d301              BCC      |L19.184|
0000b4  2003              MOVS     r0,#3                 ;741
0000b6  e7ca              B        |L19.78|
                  |L19.184|
0000b8  4620              MOV      r0,r4                 ;734
0000ba  f7fffffe          BL       HAL_NAND_Read_Status
0000be  2840              CMP      r0,#0x40              ;734
0000c0  d1f0              BNE      |L19.164|
0000c2  6a60              LDR      r0,[r4,#0x24]         ;752
0000c4  f10b0b01          ADD      r11,r11,#1            ;746
0000c8  f1a90901          SUB      r9,r9,#1              ;749
0000cc  4405              ADD      r5,r5,r0              ;752
                  |L19.206|
0000ce  f1b90f00          CMP      r9,#0                 ;704
0000d2  d004              BEQ      |L19.222|
0000d4  e9d4100a          LDRD     r1,r0,[r4,#0x28]      ;704
0000d8  4348              MULS     r0,r1,r0              ;704
0000da  42a8              CMP      r0,r5                 ;704
0000dc  d8bc              BHI      |L19.88|
                  |L19.222|
0000de  f884a021          STRB     r10,[r4,#0x21]        ;757
0000e2  2000              MOVS     r0,#0                 ;760
0000e4  f8840020          STRB     r0,[r4,#0x20]         ;760
0000e8  e7b1              B        |L19.78|
;;;764    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_nand.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f2xx_hal_nand_c_59aa39c2____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_stm32f2xx_hal_nand_c_59aa39c2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f2xx_hal_nand_c_59aa39c2____REVSH|
#line 144
|__asm___20_stm32f2xx_hal_nand_c_59aa39c2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
