; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_tim.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_tim.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_tim.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;234      */
;;;235    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;236    {  
000002  4604              MOV      r4,r0
;;;237      /* Check the parameters */
;;;238      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;239    
;;;240      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;241       
;;;242      /* Disable the TIM Peripheral Clock */
;;;243      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L1.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L1.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L1.38|
;;;244        
;;;245      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;246      HAL_TIM_Base_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;247      
;;;248      /* Change TIM state */  
;;;249      htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;250      
;;;251      /* Release Lock */
;;;252      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;253    
;;;254      return HAL_OK;
;;;255    }
000036  bd10              POP      {r4,pc}
;;;256    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4240     */
;;;4241   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4242   {
;;;4243     return htim->State;
;;;4244   }
000004  4770              BX       lr
;;;4245   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;198      */
;;;199    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;200    { 
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L3.14|
;;;201      /* Check the TIM handle allocation */
;;;202      if(htim == NULL)
;;;203      {
;;;204        return HAL_ERROR;
;;;205      }
;;;206      
;;;207      /* Check the parameters */
;;;208      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;209      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;210      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;211      
;;;212      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L3.18|
00000c  e004              B        |L3.24|
                  |L3.14|
00000e  2001              MOVS     r0,#1                 ;204
;;;213      {  
;;;214        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;215        HAL_TIM_Base_MspInit(htim);
;;;216      }
;;;217      
;;;218      /* Set the TIM state */
;;;219      htim->State= HAL_TIM_STATE_BUSY;
;;;220      
;;;221      /* Set the Time Base configuration */
;;;222      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;223      
;;;224      /* Initialize the TIM state*/
;;;225      htim->State= HAL_TIM_STATE_READY;
;;;226      
;;;227      return HAL_OK;
;;;228    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  4620              MOV      r0,r4                 ;215
000014  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.24|
000018  2002              MOVS     r0,#2                 ;219
00001a  f8840039          STRB     r0,[r4,#0x39]         ;219
00001e  1d21              ADDS     r1,r4,#4              ;222
000020  6820              LDR      r0,[r4,#0]            ;222
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;225
000028  f8840039          STRB     r0,[r4,#0x39]         ;225
00002c  2000              MOVS     r0,#0                 ;227
00002e  bd10              POP      {r4,pc}
;;;229    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;273      */
;;;274    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;275    {
;;;276      /* NOTE : This function Should not be modified, when the callback is needed,
;;;277                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;278       */
;;;279    }
;;;280    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;261      */
;;;262    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;263    {
;;;264      /* NOTE : This function Should not be modified, when the callback is needed,
;;;265                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;266       */
;;;267    }
;;;268    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;285      */
;;;286    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;287    {
;;;288      /* Check the parameters */
;;;289      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;290      
;;;291      /* Set the TIM state */
;;;292      htim->State= HAL_TIM_STATE_BUSY;
000002  f8801039          STRB     r1,[r0,#0x39]
;;;293      
;;;294      /* Enable the Peripheral */
;;;295      __HAL_TIM_ENABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  680a              LDR      r2,[r1,#0]
00000a  f0420201          ORR      r2,r2,#1
00000e  600a              STR      r2,[r1,#0]
;;;296      
;;;297      /* Change the TIM state*/
;;;298      htim->State= HAL_TIM_STATE_READY;
000010  2101              MOVS     r1,#1
000012  f8801039          STRB     r1,[r0,#0x39]
;;;299      
;;;300      /* Return function status */
;;;301      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;302    }
000018  4770              BX       lr
;;;303    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;372      */
;;;373    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4604              MOV      r4,r0
;;;375      /* Check the parameters */
;;;376      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;377      
;;;378      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L7.24|
;;;379      {
;;;380         return HAL_BUSY;
;;;381      }
;;;382      else if((htim->State == HAL_TIM_STATE_READY))
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2801              CMP      r0,#1
000012  d105              BNE      |L7.32|
;;;383      {
;;;384        if((pData == 0 ) && (Length > 0)) 
000014  b909              CBNZ     r1,|L7.26|
000016  b102              CBZ      r2,|L7.26|
                  |L7.24|
;;;385        {
;;;386          return HAL_ERROR;                                    
;;;387        }
;;;388        else
;;;389        {
;;;390          htim->State = HAL_TIM_STATE_BUSY;
;;;391        }
;;;392      }  
;;;393      /* Set the DMA Period elapsed callback */
;;;394      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;395         
;;;396      /* Set the DMA error callback */
;;;397      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;398      
;;;399      /* Enable the DMA Stream */
;;;400      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;401      
;;;402      /* Enable the TIM Update DMA request */
;;;403      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;404    
;;;405      /* Enable the Peripheral */
;;;406      __HAL_TIM_ENABLE(htim);  
;;;407      
;;;408      /* Return function status */
;;;409      return HAL_OK;
;;;410    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;390
00001c  f8840039          STRB     r0,[r4,#0x39]         ;390
                  |L7.32|
000020  69e3              LDR      r3,[r4,#0x1c]         ;394
000022  480c              LDR      r0,|L7.84|
000024  63d8              STR      r0,[r3,#0x3c]         ;397
000026  69e3              LDR      r3,[r4,#0x1c]         ;397
000028  480b              LDR      r0,|L7.88|
00002a  6498              STR      r0,[r3,#0x48]         ;400
00002c  6825              LDR      r5,[r4,#0]            ;400
00002e  4613              MOV      r3,r2                 ;400
000030  f105022c          ADD      r2,r5,#0x2c           ;400
000034  69e0              LDR      r0,[r4,#0x1c]         ;400
000036  f7fffffe          BL       HAL_DMA_Start_IT
00003a  6820              LDR      r0,[r4,#0]            ;403
00003c  68c1              LDR      r1,[r0,#0xc]          ;403
00003e  f4417180          ORR      r1,r1,#0x100          ;403
000042  60c1              STR      r1,[r0,#0xc]          ;403
000044  6820              LDR      r0,[r4,#0]            ;406
000046  6801              LDR      r1,[r0,#0]            ;406
000048  f0410101          ORR      r1,r1,#1              ;406
00004c  6001              STR      r1,[r0,#0]            ;406
00004e  2000              MOVS     r0,#0                 ;409
000050  bd70              POP      {r4-r6,pc}
;;;411    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;331      */
;;;332    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;333    {
;;;334      /* Check the parameters */
;;;335      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;336      
;;;337      /* Enable the TIM Update interrupt */
;;;338      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;339          
;;;340      /* Enable the Peripheral */
;;;341      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;342          
;;;343      /* Return function status */
;;;344      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;345    }
000016  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;310    {
;;;311      /* Check the parameters */
;;;312      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;313      
;;;314      /* Set the TIM state */
;;;315      htim->State= HAL_TIM_STATE_BUSY;
000002  f8801039          STRB     r1,[r0,#0x39]
;;;316      
;;;317      /* Disable the Peripheral */
;;;318      __HAL_TIM_DISABLE(htim);
000006  6801              LDR      r1,[r0,#0]
000008  6a0a              LDR      r2,[r1,#0x20]
00000a  f2411311          MOV      r3,#0x1111
00000e  421a              TST      r2,r3
000010  d107              BNE      |L9.34|
000012  6a0a              LDR      r2,[r1,#0x20]
000014  109b              ASRS     r3,r3,#2
000016  421a              TST      r2,r3
000018  d103              BNE      |L9.34|
00001a  680a              LDR      r2,[r1,#0]
00001c  f0220201          BIC      r2,r2,#1
000020  600a              STR      r2,[r1,#0]
                  |L9.34|
;;;319      
;;;320      /* Change the TIM state*/
;;;321      htim->State= HAL_TIM_STATE_READY;
000022  2101              MOVS     r1,#1
000024  f8801039          STRB     r1,[r0,#0x39]
;;;322      
;;;323      /* Return function status */
;;;324      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;325    }
00002a  4770              BX       lr
;;;326    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;416      */
;;;417    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;421      
;;;422      /* Disable the TIM Update DMA request */
;;;423      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;424          
;;;425      /* Disable the Peripheral */
;;;426      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;427        
;;;428      /* Change the htim state */
;;;429      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  f8801039          STRB     r1,[r0,#0x39]
;;;430          
;;;431      /* Return function status */
;;;432      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;433    }
00002e  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;351      */
;;;352    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;356      /* Disable the TIM Update interrupt */
;;;357      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;358          
;;;359      /* Disable the Peripheral */
;;;360      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;361        
;;;362      /* Return function status */
;;;363      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;364    }
000028  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3745     */ 
;;;3746   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  b570              PUSH     {r4-r6,lr}
;;;3747   {
000002  4604              MOV      r4,r0
;;;3748     uint32_t tmpsmcr = 0;
;;;3749       
;;;3750     /* Process Locked */
;;;3751     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d017              BEQ      |L12.60|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;3752     
;;;3753     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
;;;3754     
;;;3755     /* Check the parameters */
;;;3756     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3757     assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3758     assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3759     assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3760     
;;;3761     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3762     tmpsmcr = htim->Instance->SMCR;
000018  6820              LDR      r0,[r4,#0]
00001a  6882              LDR      r2,[r0,#8]
;;;3763     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00001c  f0220277          BIC      r2,r2,#0x77
;;;3764     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000020  f422427f          BIC      r2,r2,#0xff00
;;;3765     htim->Instance->SMCR = tmpsmcr;
000024  6082              STR      r2,[r0,#8]
;;;3766     
;;;3767     switch (sClockSourceConfig->ClockSource)
000026  6808              LDR      r0,[r1,#0]
000028  2850              CMP      r0,#0x50
00002a  d037              BEQ      |L12.156|
00002c  dc0d              BGT      |L12.74|
00002e  2820              CMP      r0,#0x20
000030  d059              BEQ      |L12.230|
000032  dc05              BGT      |L12.64|
000034  b388              CBZ      r0,|L12.154|
000036  2810              CMP      r0,#0x10
000038  d141              BNE      |L12.190|
00003a  e051              B        |L12.224|
                  |L12.60|
00003c  2002              MOVS     r0,#2                 ;3751
;;;3768     {
;;;3769       case TIM_CLOCKSOURCE_INTERNAL:
;;;3770       { 
;;;3771         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;3772         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3773         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3774       }
;;;3775       break;
;;;3776       
;;;3777       case TIM_CLOCKSOURCE_ETRMODE1:
;;;3778       {
;;;3779         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3780         /* Configure the ETR Clock source */
;;;3781         TIM_ETR_SetConfig(htim->Instance, 
;;;3782                           sClockSourceConfig->ClockPrescaler, 
;;;3783                           sClockSourceConfig->ClockPolarity, 
;;;3784                           sClockSourceConfig->ClockFilter);
;;;3785         /* Get the TIMx SMCR register value */
;;;3786         tmpsmcr = htim->Instance->SMCR;
;;;3787         /* Reset the SMS and TS Bits */
;;;3788         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3789         /* Select the External clock mode1 and the ETRF trigger */
;;;3790         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3791         /* Write to TIMx SMCR */
;;;3792         htim->Instance->SMCR = tmpsmcr;
;;;3793       }
;;;3794       break;
;;;3795       
;;;3796       case TIM_CLOCKSOURCE_ETRMODE2:
;;;3797       {
;;;3798         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3799         /* Configure the ETR Clock source */
;;;3800         TIM_ETR_SetConfig(htim->Instance, 
;;;3801                           sClockSourceConfig->ClockPrescaler, 
;;;3802                           sClockSourceConfig->ClockPolarity,
;;;3803                           sClockSourceConfig->ClockFilter);
;;;3804         /* Enable the External clock mode2 */
;;;3805         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3806       }
;;;3807       break;
;;;3808       
;;;3809       case TIM_CLOCKSOURCE_TI1:
;;;3810       {
;;;3811         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3812         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;3813                           sClockSourceConfig->ClockPolarity, 
;;;3814                           sClockSourceConfig->ClockFilter);
;;;3815         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;3816       }
;;;3817       break;
;;;3818       case TIM_CLOCKSOURCE_TI2:
;;;3819       {
;;;3820         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3821         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;3822                           sClockSourceConfig->ClockPolarity, 
;;;3823                           sClockSourceConfig->ClockFilter);
;;;3824         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;3825       }
;;;3826       break;
;;;3827       case TIM_CLOCKSOURCE_TI1ED:
;;;3828       {
;;;3829         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3830         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;3831                           sClockSourceConfig->ClockPolarity,
;;;3832                           sClockSourceConfig->ClockFilter);
;;;3833         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;3834       }
;;;3835       break;
;;;3836       case TIM_CLOCKSOURCE_ITR0:
;;;3837       {
;;;3838         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3839         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;3840       }
;;;3841       break;
;;;3842       case TIM_CLOCKSOURCE_ITR1:
;;;3843       {
;;;3844         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3845         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;3846       }
;;;3847       break;
;;;3848       case TIM_CLOCKSOURCE_ITR2:
;;;3849       {
;;;3850         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3851         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;3852       }
;;;3853       break;
;;;3854       case TIM_CLOCKSOURCE_ITR3:
;;;3855       {
;;;3856         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3857         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;3858       }
;;;3859       break;
;;;3860       
;;;3861       default:
;;;3862       break;    
;;;3863     }
;;;3864     htim->State = HAL_TIM_STATE_READY;
;;;3865     
;;;3866     __HAL_UNLOCK(htim);
;;;3867     
;;;3868     return HAL_OK;
;;;3869   }
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2830              CMP      r0,#0x30              ;3767
000042  d053              BEQ      |L12.236|
000044  2840              CMP      r0,#0x40              ;3767
000046  d13a              BNE      |L12.190|
000048  e03f              B        |L12.202|
                  |L12.74|
00004a  2860              CMP      r0,#0x60              ;3767
00004c  d02e              BEQ      |L12.172|
00004e  2870              CMP      r0,#0x70              ;3767
000050  d00b              BEQ      |L12.106|
000052  f5b05f80          CMP      r0,#0x1000            ;3767
000056  d003              BEQ      |L12.96|
000058  f5b05f00          CMP      r0,#0x2000            ;3767
00005c  d12f              BNE      |L12.190|
00005e  e010              B        |L12.130|
                  |L12.96|
000060  6820              LDR      r0,[r4,#0]            ;3773
000062  6881              LDR      r1,[r0,#8]            ;3773
000064  f0210107          BIC      r1,r1,#7              ;3773
000068  e015              B        |L12.150|
                  |L12.106|
00006a  68cb              LDR      r3,[r1,#0xc]          ;3781
00006c  e9d12101          LDRD     r2,r1,[r1,#4]         ;3781
000070  6820              LDR      r0,[r4,#0]            ;3781
000072  f7fffffe          BL       TIM_ETR_SetConfig
000076  6821              LDR      r1,[r4,#0]            ;3786
000078  6888              LDR      r0,[r1,#8]            ;3786
00007a  f0400077          ORR      r0,r0,#0x77           ;3790
00007e  6088              STR      r0,[r1,#8]            ;3792
000080  e01d              B        |L12.190|
                  |L12.130|
000082  68cb              LDR      r3,[r1,#0xc]          ;3800
000084  e9d12101          LDRD     r2,r1,[r1,#4]         ;3800
000088  6820              LDR      r0,[r4,#0]            ;3800
00008a  f7fffffe          BL       TIM_ETR_SetConfig
00008e  6820              LDR      r0,[r4,#0]            ;3805
000090  6881              LDR      r1,[r0,#8]            ;3805
000092  f4414180          ORR      r1,r1,#0x4000         ;3805
                  |L12.150|
000096  6081              STR      r1,[r0,#8]            ;3773
000098  e011              B        |L12.190|
                  |L12.154|
00009a  e01e              B        |L12.218|
                  |L12.156|
00009c  68ca              LDR      r2,[r1,#0xc]          ;3812
00009e  6849              LDR      r1,[r1,#4]            ;3812
0000a0  6820              LDR      r0,[r4,#0]            ;3812
0000a2  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000a6  2150              MOVS     r1,#0x50              ;3815
0000a8  6820              LDR      r0,[r4,#0]            ;3817
0000aa  e006              B        |L12.186|
                  |L12.172|
0000ac  68ca              LDR      r2,[r1,#0xc]          ;3821
0000ae  6849              LDR      r1,[r1,#4]            ;3821
0000b0  6820              LDR      r0,[r4,#0]            ;3821
0000b2  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000b6  2160              MOVS     r1,#0x60              ;3824
0000b8  6820              LDR      r0,[r4,#0]            ;3824
                  |L12.186|
0000ba  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.190|
0000be  f8845039          STRB     r5,[r4,#0x39]         ;3864
0000c2  2000              MOVS     r0,#0                 ;3866
0000c4  f8840038          STRB     r0,[r4,#0x38]         ;3866
0000c8  bd70              POP      {r4-r6,pc}
                  |L12.202|
0000ca  68ca              LDR      r2,[r1,#0xc]          ;3830
0000cc  6849              LDR      r1,[r1,#4]            ;3830
0000ce  6820              LDR      r0,[r4,#0]            ;3830
0000d0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000d4  2140              MOVS     r1,#0x40              ;3833
0000d6  6820              LDR      r0,[r4,#0]            ;3835
0000d8  e7ef              B        |L12.186|
                  |L12.218|
0000da  2100              MOVS     r1,#0                 ;3839
0000dc  6820              LDR      r0,[r4,#0]            ;3841
0000de  e7ec              B        |L12.186|
                  |L12.224|
0000e0  2110              MOVS     r1,#0x10              ;3845
0000e2  6820              LDR      r0,[r4,#0]            ;3847
0000e4  e7e9              B        |L12.186|
                  |L12.230|
0000e6  2120              MOVS     r1,#0x20              ;3851
0000e8  6820              LDR      r0,[r4,#0]            ;3853
0000ea  e7e6              B        |L12.186|
                  |L12.236|
0000ec  2130              MOVS     r1,#0x30              ;3857
0000ee  6820              LDR      r0,[r4,#0]            ;3859
0000f0  e7e3              B        |L12.186|
;;;3870   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3643     */ 
;;;3644   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3645   { 
000004  4604              MOV      r4,r0
;;;3646     /* Check the parameters */
;;;3647     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3648     assert_param(IS_TIM_CHANNELS(Channel));
;;;3649     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3650     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3651     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3652     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3653      
;;;3654     /* Process Locked */
;;;3655     __HAL_LOCK(htim);
000006  f8900038          LDRB     r0,[r0,#0x38]
00000a  4617              MOV      r7,r2                 ;3645
00000c  460d              MOV      r5,r1                 ;3645
00000e  2801              CMP      r0,#1
000010  d009              BEQ      |L13.38|
000012  2601              MOVS     r6,#1
000014  f8846038          STRB     r6,[r4,#0x38]
;;;3656     
;;;3657     htim->State = HAL_TIM_STATE_BUSY;
000018  2002              MOVS     r0,#2
00001a  f8840039          STRB     r0,[r4,#0x39]
;;;3658     
;;;3659     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
00001e  6868              LDR      r0,[r5,#4]
000020  2801              CMP      r0,#1
000022  d003              BEQ      |L13.44|
000024  e008              B        |L13.56|
                  |L13.38|
000026  2002              MOVS     r0,#2                 ;3655
                  |L13.40|
;;;3660     {
;;;3661       TIM_ETR_SetConfig(htim->Instance, 
;;;3662                         sClearInputConfig->ClearInputPrescaler,
;;;3663                         sClearInputConfig->ClearInputPolarity,
;;;3664                         sClearInputConfig->ClearInputFilter);
;;;3665     }
;;;3666     
;;;3667     switch (Channel)
;;;3668     {
;;;3669       case TIM_CHANNEL_1:
;;;3670       {        
;;;3671         if(sClearInputConfig->ClearInputState != RESET)  
;;;3672         {
;;;3673           /* Enable the Ocref clear feature for Channel 1 */
;;;3674           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3675         }
;;;3676         else
;;;3677         {
;;;3678           /* Disable the Ocref clear feature for Channel 1 */
;;;3679           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;3680         }
;;;3681       }    
;;;3682       break;
;;;3683       case TIM_CHANNEL_2:    
;;;3684       { 
;;;3685         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;3686         if(sClearInputConfig->ClearInputState != RESET)  
;;;3687         {
;;;3688           /* Enable the Ocref clear feature for Channel 2 */
;;;3689           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3690         }
;;;3691         else
;;;3692         {
;;;3693           /* Disable the Ocref clear feature for Channel 2 */
;;;3694           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;3695         }
;;;3696       } 
;;;3697       break;
;;;3698       case TIM_CHANNEL_3:   
;;;3699       {  
;;;3700         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3701         if(sClearInputConfig->ClearInputState != RESET)  
;;;3702         {
;;;3703           /* Enable the Ocref clear feature for Channel 3 */
;;;3704           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3705         }
;;;3706         else
;;;3707         {
;;;3708           /* Disable the Ocref clear feature for Channel 3 */
;;;3709           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;3710         }
;;;3711       } 
;;;3712       break;
;;;3713       case TIM_CHANNEL_4:    
;;;3714       {  
;;;3715         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3716         if(sClearInputConfig->ClearInputState != RESET)  
;;;3717         {
;;;3718           /* Enable the Ocref clear feature for Channel 4 */
;;;3719           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3720         }
;;;3721         else
;;;3722         {
;;;3723           /* Disable the Ocref clear feature for Channel 4 */
;;;3724           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;3725         }
;;;3726       } 
;;;3727       break;
;;;3728       default:  
;;;3729       break;
;;;3730     } 
;;;3731   
;;;3732     htim->State = HAL_TIM_STATE_READY;
;;;3733     
;;;3734     __HAL_UNLOCK(htim);
;;;3735     
;;;3736     return HAL_OK;  
;;;3737   }  
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L13.44|
00002c  e9d52102          LDRD     r2,r1,[r5,#8]         ;3661
000030  692b              LDR      r3,[r5,#0x10]         ;3661
000032  6820              LDR      r0,[r4,#0]            ;3661
000034  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.56|
000038  b137              CBZ      r7,|L13.72|
00003a  2f04              CMP      r7,#4                 ;3667
00003c  d00f              BEQ      |L13.94|
00003e  2f08              CMP      r7,#8                 ;3667
000040  d019              BEQ      |L13.118|
000042  2f0c              CMP      r7,#0xc               ;3667
000044  d12d              BNE      |L13.162|
000046  e021              B        |L13.140|
                  |L13.72|
000048  6828              LDR      r0,[r5,#0]            ;3671
00004a  2800              CMP      r0,#0                 ;3671
00004c  6820              LDR      r0,[r4,#0]            ;3679
00004e  6981              LDR      r1,[r0,#0x18]         ;3679
000050  d002              BEQ      |L13.88|
000052  f0410180          ORR      r1,r1,#0x80           ;3674
000056  e00c              B        |L13.114|
                  |L13.88|
000058  f0210180          BIC      r1,r1,#0x80           ;3679
00005c  e009              B        |L13.114|
                  |L13.94|
00005e  6828              LDR      r0,[r5,#0]            ;3686
000060  2800              CMP      r0,#0                 ;3686
000062  6820              LDR      r0,[r4,#0]            ;3694
000064  6981              LDR      r1,[r0,#0x18]         ;3694
000066  d002              BEQ      |L13.110|
000068  f4414100          ORR      r1,r1,#0x8000         ;3689
00006c  e001              B        |L13.114|
                  |L13.110|
00006e  f4214100          BIC      r1,r1,#0x8000         ;3694
                  |L13.114|
000072  6181              STR      r1,[r0,#0x18]         ;3689
000074  e015              B        |L13.162|
                  |L13.118|
000076  6828              LDR      r0,[r5,#0]            ;3701
000078  2800              CMP      r0,#0                 ;3701
00007a  6820              LDR      r0,[r4,#0]            ;3709
00007c  69c1              LDR      r1,[r0,#0x1c]         ;3709
00007e  d002              BEQ      |L13.134|
000080  f0410180          ORR      r1,r1,#0x80           ;3704
000084  e00c              B        |L13.160|
                  |L13.134|
000086  f0210180          BIC      r1,r1,#0x80           ;3709
00008a  e009              B        |L13.160|
                  |L13.140|
00008c  6828              LDR      r0,[r5,#0]            ;3716
00008e  2800              CMP      r0,#0                 ;3716
000090  6820              LDR      r0,[r4,#0]            ;3724
000092  69c1              LDR      r1,[r0,#0x1c]         ;3724
000094  d002              BEQ      |L13.156|
000096  f4414100          ORR      r1,r1,#0x8000         ;3719
00009a  e001              B        |L13.160|
                  |L13.156|
00009c  f4214100          BIC      r1,r1,#0x8000         ;3724
                  |L13.160|
0000a0  61c1              STR      r1,[r0,#0x1c]         ;3719
                  |L13.162|
0000a2  f8846039          STRB     r6,[r4,#0x39]         ;3732
0000a6  2000              MOVS     r0,#0                 ;3734
0000a8  f8840038          STRB     r0,[r4,#0x38]         ;3734
0000ac  e7bc              B        |L13.40|
;;;3738   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;3882     */
;;;3883   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6802              LDR      r2,[r0,#0]
;;;3884   {
;;;3885     uint32_t tmpcr2 = 0;
;;;3886     
;;;3887     /* Check the parameters */
;;;3888     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;3889     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;3890   
;;;3891     /* Get the TIMx CR2 register value */
;;;3892     tmpcr2 = htim->Instance->CR2;
000002  6850              LDR      r0,[r2,#4]
;;;3893   
;;;3894     /* Reset the TI1 selection */
;;;3895     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0200080          BIC      r0,r0,#0x80
;;;3896   
;;;3897     /* Set the the TI1 selection */
;;;3898     tmpcr2 |= TI1_Selection;
000008  4308              ORRS     r0,r0,r1
;;;3899     
;;;3900     /* Write to TIMxCR2 */
;;;3901     htim->Instance->CR2 = tmpcr2;
00000a  6050              STR      r0,[r2,#4]
;;;3902   
;;;3903     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;3904   }
00000e  4770              BX       lr
;;;3905   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3444     */
;;;3445   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3446                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3447   {
000004  4604              MOV      r4,r0
;;;3448     /* Check the parameters */
;;;3449     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3450     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3451     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3452     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3453     
;;;3454     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3447
00000e  4616              MOV      r6,r2                 ;3447
000010  4688              MOV      r8,r1                 ;3447
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L15.38|
;;;3455     {
;;;3456        return HAL_BUSY;
;;;3457     }
;;;3458     else if((htim->State == HAL_TIM_STATE_READY))
000016  f8940039          LDRB     r0,[r4,#0x39]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L15.48|
;;;3459     {
;;;3460       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L15.42|
000024  b10d              CBZ      r5,|L15.42|
                  |L15.38|
;;;3461       {
;;;3462         return HAL_ERROR;                                    
;;;3463       }
;;;3464       else
;;;3465       {
;;;3466         htim->State = HAL_TIM_STATE_BUSY;
;;;3467       }
;;;3468     }  
;;;3469     switch(BurstRequestSrc)
;;;3470     {
;;;3471       case TIM_DMA_UPDATE:
;;;3472       {  
;;;3473         /* Set the DMA Period elapsed callback */
;;;3474         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3475        
;;;3476         /* Set the DMA error callback */
;;;3477         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3478     
;;;3479         /* Enable the DMA Stream */
;;;3480          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3481       }
;;;3482       break;
;;;3483       case TIM_DMA_CC1:
;;;3484       {  
;;;3485         /* Set the DMA Period elapsed callback */
;;;3486         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3487        
;;;3488         /* Set the DMA error callback */
;;;3489         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3490     
;;;3491         /* Enable the DMA Stream */
;;;3492         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3493       }
;;;3494       break;
;;;3495       case TIM_DMA_CC2:
;;;3496       {  
;;;3497         /* Set the DMA Period elapsed callback */
;;;3498         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3499        
;;;3500         /* Set the DMA error callback */
;;;3501         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3502     
;;;3503         /* Enable the DMA Stream */
;;;3504         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3505       }
;;;3506       break;
;;;3507       case TIM_DMA_CC3:
;;;3508       {  
;;;3509         /* Set the DMA Period elapsed callback */
;;;3510         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3511        
;;;3512         /* Set the DMA error callback */
;;;3513         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3514     
;;;3515         /* Enable the DMA Stream */
;;;3516         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3517       }
;;;3518       break;
;;;3519       case TIM_DMA_CC4:
;;;3520       {  
;;;3521         /* Set the DMA Period elapsed callback */
;;;3522         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3523        
;;;3524         /* Set the DMA error callback */
;;;3525         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3526     
;;;3527         /* Enable the DMA Stream */
;;;3528         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3529       }
;;;3530       break;
;;;3531       case TIM_DMA_COM:
;;;3532       {  
;;;3533         /* Set the DMA Period elapsed callback */
;;;3534         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3535        
;;;3536         /* Set the DMA error callback */
;;;3537         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3538     
;;;3539         /* Enable the DMA Stream */
;;;3540         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3541       }
;;;3542       break;
;;;3543       case TIM_DMA_TRIGGER:
;;;3544       {  
;;;3545         /* Set the DMA Period elapsed callback */
;;;3546         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3547        
;;;3548         /* Set the DMA error callback */
;;;3549         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3550     
;;;3551         /* Enable the DMA Stream */
;;;3552         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3553       }
;;;3554       break;
;;;3555       default:
;;;3556       break;  
;;;3557     }
;;;3558   
;;;3559     /* configure the DMA Burst Mode */
;;;3560     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3561     
;;;3562     /* Enable the TIM DMA Request */
;;;3563     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3564     
;;;3565     htim->State = HAL_TIM_STATE_READY;
;;;3566     
;;;3567     /* Return function status */
;;;3568     return HAL_OK;
;;;3569   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L15.42|
00002a  2002              MOVS     r0,#2                 ;3466
00002c  f8840039          STRB     r0,[r4,#0x39]         ;3466
                  |L15.48|
000030  2701              MOVS     r7,#1                 ;3462
000032  482f              LDR      r0,|L15.240|
000034  492f              LDR      r1,|L15.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3480
00003a  f5b66f00          CMP      r6,#0x800             ;3469
00003e  d039              BEQ      |L15.180|
000040  dc09              BGT      |L15.86|
000042  f5b67f80          CMP      r6,#0x100             ;3469
000046  d010              BEQ      |L15.106|
000048  f5b67f00          CMP      r6,#0x200             ;3469
00004c  d015              BEQ      |L15.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3469
000052  d11c              BNE      |L15.142|
000054  e027              B        |L15.166|
                  |L15.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3469
00005a  d032              BEQ      |L15.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3469
000060  d036              BEQ      |L15.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3469
000066  d112              BNE      |L15.142|
000068  e03a              B        |L15.224|
                  |L15.106|
00006a  69e2              LDR      r2,[r4,#0x1c]         ;3474
00006c  4922              LDR      r1,|L15.248|
00006e  63d1              STR      r1,[r2,#0x3c]         ;3477
000070  69e1              LDR      r1,[r4,#0x1c]         ;3477
000072  6488              STR      r0,[r1,#0x48]         ;3480
000074  6821              LDR      r1,[r4,#0]            ;3482
000076  69e0              LDR      r0,[r4,#0x1c]         ;3482
000078  e005              B        |L15.134|
                  |L15.122|
00007a  6a22              LDR      r2,[r4,#0x20]         ;3486
00007c  63d1              STR      r1,[r2,#0x3c]         ;3489
00007e  6a21              LDR      r1,[r4,#0x20]         ;3489
000080  6488              STR      r0,[r1,#0x48]         ;3492
000082  6821              LDR      r1,[r4,#0]            ;3492
000084  6a20              LDR      r0,[r4,#0x20]         ;3492
                  |L15.134|
000086  4662              MOV      r2,r12                ;3480
000088  314c              ADDS     r1,r1,#0x4c           ;3480
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.142|
00008e  6821              LDR      r1,[r4,#0]            ;3560
000090  ea480005          ORR      r0,r8,r5              ;3560
000094  6488              STR      r0,[r1,#0x48]         ;3560
000096  6820              LDR      r0,[r4,#0]            ;3563
000098  68c1              LDR      r1,[r0,#0xc]          ;3563
00009a  4331              ORRS     r1,r1,r6              ;3563
00009c  60c1              STR      r1,[r0,#0xc]          ;3563
00009e  f8847039          STRB     r7,[r4,#0x39]         ;3565
0000a2  2000              MOVS     r0,#0                 ;3568
0000a4  e7bf              B        |L15.38|
                  |L15.166|
0000a6  6a62              LDR      r2,[r4,#0x24]         ;3498
0000a8  63d1              STR      r1,[r2,#0x3c]         ;3501
0000aa  6a61              LDR      r1,[r4,#0x24]         ;3501
0000ac  6488              STR      r0,[r1,#0x48]         ;3504
0000ae  6821              LDR      r1,[r4,#0]            ;3506
0000b0  6a60              LDR      r0,[r4,#0x24]         ;3506
0000b2  e7e8              B        |L15.134|
                  |L15.180|
0000b4  6aa2              LDR      r2,[r4,#0x28]         ;3510
0000b6  63d1              STR      r1,[r2,#0x3c]         ;3513
0000b8  6aa1              LDR      r1,[r4,#0x28]         ;3513
0000ba  6488              STR      r0,[r1,#0x48]         ;3516
0000bc  6821              LDR      r1,[r4,#0]            ;3518
0000be  6aa0              LDR      r0,[r4,#0x28]         ;3518
0000c0  e7e1              B        |L15.134|
                  |L15.194|
0000c2  6ae2              LDR      r2,[r4,#0x2c]         ;3522
0000c4  63d1              STR      r1,[r2,#0x3c]         ;3525
0000c6  6ae1              LDR      r1,[r4,#0x2c]         ;3525
0000c8  6488              STR      r0,[r1,#0x48]         ;3528
0000ca  6821              LDR      r1,[r4,#0]            ;3530
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;3530
0000ce  e7da              B        |L15.134|
                  |L15.208|
0000d0  6b22              LDR      r2,[r4,#0x30]         ;3534
0000d2  490a              LDR      r1,|L15.252|
0000d4  63d1              STR      r1,[r2,#0x3c]         ;3537
0000d6  6b21              LDR      r1,[r4,#0x30]         ;3537
0000d8  6488              STR      r0,[r1,#0x48]         ;3540
0000da  6821              LDR      r1,[r4,#0]            ;3542
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3542
0000de  e7d2              B        |L15.134|
                  |L15.224|
0000e0  6b62              LDR      r2,[r4,#0x34]         ;3546
0000e2  4907              LDR      r1,|L15.256|
0000e4  63d1              STR      r1,[r2,#0x3c]         ;3549
0000e6  6b61              LDR      r1,[r4,#0x34]         ;3549
0000e8  6488              STR      r0,[r1,#0x48]         ;3552
0000ea  6821              LDR      r1,[r4,#0]            ;3554
0000ec  6b60              LDR      r0,[r4,#0x34]         ;3554
0000ee  e7ca              B        |L15.134|
;;;3570   
                          ENDP

                  |L15.240|
                          DCD      HAL_TIM_DMAError
                  |L15.244|
                          DCD      HAL_TIM_DMACaptureCplt
                  |L15.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.252|
                          DCD      HAL_TIMEx_DMACommutationCplt
                  |L15.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3576     */
;;;3577   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  6800              LDR      r0,[r0,#0]
;;;3578   {
;;;3579     /* Check the parameters */
;;;3580     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3581     
;;;3582     /* Disable the TIM Update DMA request */
;;;3583     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000002  68c2              LDR      r2,[r0,#0xc]
000004  438a              BICS     r2,r2,r1
000006  60c2              STR      r2,[r0,#0xc]
;;;3584         
;;;3585     /* Return function status */
;;;3586     return HAL_OK;  
000008  2000              MOVS     r0,#0
;;;3587   }
00000a  4770              BX       lr
;;;3588   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3263     */
;;;3264   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3265                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3266   {
000004  4604              MOV      r4,r0
;;;3267     /* Check the parameters */
;;;3268     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3269     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3270     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3271     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3272     
;;;3273     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9d06              LDR      r5,[sp,#0x18]
00000c  469c              MOV      r12,r3                ;3266
00000e  4616              MOV      r6,r2                 ;3266
000010  4688              MOV      r8,r1                 ;3266
000012  2802              CMP      r0,#2
000014  d007              BEQ      |L17.38|
;;;3274     {
;;;3275        return HAL_BUSY;
;;;3276     }
;;;3277     else if((htim->State == HAL_TIM_STATE_READY))
000016  f8940039          LDRB     r0,[r4,#0x39]
00001a  2801              CMP      r0,#1
00001c  d108              BNE      |L17.48|
;;;3278     {
;;;3279       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
00001e  f1bc0f00          CMP      r12,#0
000022  d102              BNE      |L17.42|
000024  b10d              CBZ      r5,|L17.42|
                  |L17.38|
;;;3280       {
;;;3281         return HAL_ERROR;                                    
;;;3282       }
;;;3283       else
;;;3284       {
;;;3285         htim->State = HAL_TIM_STATE_BUSY;
;;;3286       }
;;;3287     }
;;;3288     switch(BurstRequestSrc)
;;;3289     {
;;;3290       case TIM_DMA_UPDATE:
;;;3291       {  
;;;3292         /* Set the DMA Period elapsed callback */
;;;3293         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3294        
;;;3295         /* Set the DMA error callback */
;;;3296         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3297     
;;;3298         /* Enable the DMA Stream */
;;;3299         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3300       }
;;;3301       break;
;;;3302       case TIM_DMA_CC1:
;;;3303       {  
;;;3304         /* Set the DMA Period elapsed callback */
;;;3305         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3306        
;;;3307         /* Set the DMA error callback */
;;;3308         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3309     
;;;3310         /* Enable the DMA Stream */
;;;3311         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3312       }
;;;3313       break;
;;;3314       case TIM_DMA_CC2:
;;;3315       {  
;;;3316         /* Set the DMA Period elapsed callback */
;;;3317         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3318        
;;;3319         /* Set the DMA error callback */
;;;3320         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3321     
;;;3322         /* Enable the DMA Stream */
;;;3323         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3324       }
;;;3325       break;
;;;3326       case TIM_DMA_CC3:
;;;3327       {  
;;;3328         /* Set the DMA Period elapsed callback */
;;;3329         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3330        
;;;3331         /* Set the DMA error callback */
;;;3332         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3333     
;;;3334         /* Enable the DMA Stream */
;;;3335         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3336       }
;;;3337       break;
;;;3338       case TIM_DMA_CC4:
;;;3339       {  
;;;3340         /* Set the DMA Period elapsed callback */
;;;3341         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3342        
;;;3343         /* Set the DMA error callback */
;;;3344         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3345     
;;;3346         /* Enable the DMA Stream */
;;;3347         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3348       }
;;;3349       break;
;;;3350       case TIM_DMA_COM:
;;;3351       {  
;;;3352         /* Set the DMA Period elapsed callback */
;;;3353         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3354        
;;;3355         /* Set the DMA error callback */
;;;3356         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3357     
;;;3358         /* Enable the DMA Stream */
;;;3359         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3360       }
;;;3361       break;
;;;3362       case TIM_DMA_TRIGGER:
;;;3363       {  
;;;3364         /* Set the DMA Period elapsed callback */
;;;3365         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3366        
;;;3367         /* Set the DMA error callback */
;;;3368         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3369     
;;;3370         /* Enable the DMA Stream */
;;;3371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3372       }
;;;3373       break;
;;;3374       default:
;;;3375       break;  
;;;3376     }
;;;3377      /* configure the DMA Burst Mode */
;;;3378      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3379      
;;;3380      /* Enable the TIM DMA Request */
;;;3381      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3382      
;;;3383      htim->State = HAL_TIM_STATE_READY;
;;;3384     
;;;3385     /* Return function status */
;;;3386     return HAL_OK;
;;;3387   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L17.42|
00002a  2002              MOVS     r0,#2                 ;3285
00002c  f8840039          STRB     r0,[r4,#0x39]         ;3285
                  |L17.48|
000030  2701              MOVS     r7,#1                 ;3281
000032  482f              LDR      r0,|L17.240|
000034  492f              LDR      r1,|L17.244|
000036  eb072315          ADD      r3,r7,r5,LSR #8       ;3299
00003a  f5b66f00          CMP      r6,#0x800             ;3288
00003e  d039              BEQ      |L17.180|
000040  dc09              BGT      |L17.86|
000042  f5b67f80          CMP      r6,#0x100             ;3288
000046  d010              BEQ      |L17.106|
000048  f5b67f00          CMP      r6,#0x200             ;3288
00004c  d015              BEQ      |L17.122|
00004e  f5b66f80          CMP      r6,#0x400             ;3288
000052  d11c              BNE      |L17.142|
000054  e027              B        |L17.166|
                  |L17.86|
000056  f5b65f80          CMP      r6,#0x1000            ;3288
00005a  d032              BEQ      |L17.194|
00005c  f5b65f00          CMP      r6,#0x2000            ;3288
000060  d036              BEQ      |L17.208|
000062  f5b64f80          CMP      r6,#0x4000            ;3288
000066  d112              BNE      |L17.142|
000068  e03a              B        |L17.224|
                  |L17.106|
00006a  69e2              LDR      r2,[r4,#0x1c]         ;3293
00006c  4922              LDR      r1,|L17.248|
00006e  63d1              STR      r1,[r2,#0x3c]         ;3296
000070  69e1              LDR      r1,[r4,#0x1c]         ;3296
000072  6488              STR      r0,[r1,#0x48]         ;3299
000074  6822              LDR      r2,[r4,#0]            ;3301
000076  69e0              LDR      r0,[r4,#0x1c]         ;3301
000078  e005              B        |L17.134|
                  |L17.122|
00007a  6a22              LDR      r2,[r4,#0x20]         ;3305
00007c  63d1              STR      r1,[r2,#0x3c]         ;3308
00007e  6a21              LDR      r1,[r4,#0x20]         ;3308
000080  6488              STR      r0,[r1,#0x48]         ;3311
000082  6822              LDR      r2,[r4,#0]            ;3311
000084  6a20              LDR      r0,[r4,#0x20]         ;3311
                  |L17.134|
000086  4661              MOV      r1,r12                ;3299
000088  324c              ADDS     r2,r2,#0x4c           ;3299
00008a  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.142|
00008e  6821              LDR      r1,[r4,#0]            ;3378
000090  ea480005          ORR      r0,r8,r5              ;3378
000094  6488              STR      r0,[r1,#0x48]         ;3378
000096  6820              LDR      r0,[r4,#0]            ;3381
000098  68c1              LDR      r1,[r0,#0xc]          ;3381
00009a  4331              ORRS     r1,r1,r6              ;3381
00009c  60c1              STR      r1,[r0,#0xc]          ;3381
00009e  f8847039          STRB     r7,[r4,#0x39]         ;3383
0000a2  2000              MOVS     r0,#0                 ;3386
0000a4  e7bf              B        |L17.38|
                  |L17.166|
0000a6  6a62              LDR      r2,[r4,#0x24]         ;3317
0000a8  63d1              STR      r1,[r2,#0x3c]         ;3320
0000aa  6a61              LDR      r1,[r4,#0x24]         ;3320
0000ac  6488              STR      r0,[r1,#0x48]         ;3323
0000ae  6822              LDR      r2,[r4,#0]            ;3325
0000b0  6a60              LDR      r0,[r4,#0x24]         ;3325
0000b2  e7e8              B        |L17.134|
                  |L17.180|
0000b4  6aa2              LDR      r2,[r4,#0x28]         ;3329
0000b6  63d1              STR      r1,[r2,#0x3c]         ;3332
0000b8  6aa1              LDR      r1,[r4,#0x28]         ;3332
0000ba  6488              STR      r0,[r1,#0x48]         ;3335
0000bc  6822              LDR      r2,[r4,#0]            ;3337
0000be  6aa0              LDR      r0,[r4,#0x28]         ;3337
0000c0  e7e1              B        |L17.134|
                  |L17.194|
0000c2  6ae2              LDR      r2,[r4,#0x2c]         ;3341
0000c4  63d1              STR      r1,[r2,#0x3c]         ;3344
0000c6  6ae1              LDR      r1,[r4,#0x2c]         ;3344
0000c8  6488              STR      r0,[r1,#0x48]         ;3347
0000ca  6822              LDR      r2,[r4,#0]            ;3349
0000cc  6ae0              LDR      r0,[r4,#0x2c]         ;3349
0000ce  e7da              B        |L17.134|
                  |L17.208|
0000d0  6b22              LDR      r2,[r4,#0x30]         ;3353
0000d2  490a              LDR      r1,|L17.252|
0000d4  63d1              STR      r1,[r2,#0x3c]         ;3356
0000d6  6b21              LDR      r1,[r4,#0x30]         ;3356
0000d8  6488              STR      r0,[r1,#0x48]         ;3359
0000da  6822              LDR      r2,[r4,#0]            ;3361
0000dc  6b20              LDR      r0,[r4,#0x30]         ;3361
0000de  e7d2              B        |L17.134|
                  |L17.224|
0000e0  6b62              LDR      r2,[r4,#0x34]         ;3365
0000e2  4907              LDR      r1,|L17.256|
0000e4  63d1              STR      r1,[r2,#0x3c]         ;3368
0000e6  6b61              LDR      r1,[r4,#0x34]         ;3368
0000e8  6488              STR      r0,[r1,#0x48]         ;3371
0000ea  6822              LDR      r2,[r4,#0]            ;3373
0000ec  6b60              LDR      r0,[r4,#0x34]         ;3373
0000ee  e7ca              B        |L17.134|
;;;3388   
                          ENDP

                  |L17.240|
                          DCD      HAL_TIM_DMAError
                  |L17.244|
                          DCD      HAL_TIM_DMADelayPulseCplt
                  |L17.248|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.252|
                          DCD      HAL_TIMEx_DMACommutationCplt
                  |L17.256|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3394     */
;;;3395   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  6800              LDR      r0,[r0,#0]
;;;3396   {
;;;3397     /* Check the parameters */
;;;3398     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3399     
;;;3400     /* Disable the TIM Update DMA request */
;;;3401     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000002  68c2              LDR      r2,[r0,#0xc]
000004  438a              BICS     r2,r2,r1
000006  60c2              STR      r2,[r0,#0xc]
;;;3402         
;;;3403     /* Return function status */
;;;3404     return HAL_OK;  
000008  2000              MOVS     r0,#0
;;;3405   }
00000a  4770              BX       lr
;;;3406   
                          ENDP


                          AREA ||i.HAL_TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMACaptureCplt PROC
;;;4331     */
;;;4332   void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4333   {
;;;4334     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;4335       
;;;4336      htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4337       
;;;4338     HAL_TIM_IC_CaptureCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4339   
;;;4340   }
00000e  bd10              POP      {r4,pc}
;;;4341   
                          ENDP


                          AREA ||i.HAL_TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMADelayPulseCplt PROC
;;;4318     */
;;;4319   void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4320   {
;;;4321     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;4322     
;;;4323     htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4324     
;;;4325     HAL_TIM_PWM_PulseFinishedCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4326   }
00000e  bd10              POP      {r4,pc}
;;;4327   /**
                          ENDP


                          AREA ||i.HAL_TIM_DMAError||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMAError PROC
;;;4304     */
;;;4305   void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4306   {
;;;4307     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;4308     
;;;4309     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4310      
;;;4311     HAL_TIM_ErrorCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4312   }
00000e  bd10              POP      {r4,pc}
;;;4313   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2277     */
;;;2278   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2279   {
000002  4604              MOV      r4,r0
;;;2280     /* Check the parameters */
;;;2281     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2282     
;;;2283     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;2284     
;;;2285     /* Disable the TIM Peripheral Clock */
;;;2286     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L22.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L22.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L22.38|
;;;2287     
;;;2288     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2289     HAL_TIM_Encoder_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2290       
;;;2291     /* Change TIM state */  
;;;2292     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;2293    
;;;2294     /* Release Lock */
;;;2295     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;2296   
;;;2297     return HAL_OK;
;;;2298   }
000036  bd10              POP      {r4,pc}
;;;2299   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4290     */
;;;4291   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4292   {
;;;4293     return htim->State;
;;;4294   }
000004  4770              BX       lr
;;;4295   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2191     */
;;;2192   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2193   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d003              BEQ      |L24.18|
;;;2194     uint32_t tmpsmcr = 0;
;;;2195     uint32_t tmpccmr1 = 0;
;;;2196     uint32_t tmpccer = 0;
;;;2197     
;;;2198     /* Check the TIM handle allocation */
;;;2199     if(htim == NULL)
;;;2200     {
;;;2201       return HAL_ERROR;
;;;2202     }
;;;2203      
;;;2204     /* Check the parameters */
;;;2205     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2206     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2207     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2208     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2209     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2210     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2211     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2212     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2213     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2214     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2215   
;;;2216     if(htim->State == HAL_TIM_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  b118              CBZ      r0,|L24.24|
000010  e005              B        |L24.30|
                  |L24.18|
000012  2001              MOVS     r0,#1                 ;2201
                  |L24.20|
;;;2217     { 
;;;2218       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2219       HAL_TIM_Encoder_MspInit(htim);
;;;2220     }
;;;2221     
;;;2222     /* Set the TIM state */
;;;2223     htim->State= HAL_TIM_STATE_BUSY;   
;;;2224       
;;;2225     /* Reset the SMS bits */
;;;2226     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2227     
;;;2228     /* Configure the Time base in the Encoder Mode */
;;;2229     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2230     
;;;2231     /* Get the TIMx SMCR register value */
;;;2232     tmpsmcr = htim->Instance->SMCR;
;;;2233   
;;;2234     /* Get the TIMx CCMR1 register value */
;;;2235     tmpccmr1 = htim->Instance->CCMR1;
;;;2236   
;;;2237     /* Get the TIMx CCER register value */
;;;2238     tmpccer = htim->Instance->CCER;
;;;2239   
;;;2240     /* Set the encoder Mode */
;;;2241     tmpsmcr |= sConfig->EncoderMode;
;;;2242   
;;;2243     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2244     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2245     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2246     
;;;2247     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2248     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2249     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2250     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2251     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2252   
;;;2253     /* Set the TI1 and the TI2 Polarities */
;;;2254     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2255     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2256     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2257     
;;;2258     /* Write to TIMx SMCR */
;;;2259     htim->Instance->SMCR = tmpsmcr;
;;;2260   
;;;2261     /* Write to TIMx CCMR1 */
;;;2262     htim->Instance->CCMR1 = tmpccmr1;
;;;2263   
;;;2264     /* Write to TIMx CCER */
;;;2265     htim->Instance->CCER = tmpccer;
;;;2266     
;;;2267     /* Initialize the TIM state*/
;;;2268     htim->State= HAL_TIM_STATE_READY;
;;;2269     
;;;2270     return HAL_OK;
;;;2271   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L24.24|
000018  4620              MOV      r0,r4                 ;2219
00001a  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L24.30|
00001e  2002              MOVS     r0,#2                 ;2223
000020  f8840039          STRB     r0,[r4,#0x39]         ;2223
000024  6820              LDR      r0,[r4,#0]            ;2226
000026  6881              LDR      r1,[r0,#8]            ;2226
000028  f0210107          BIC      r1,r1,#7              ;2226
00002c  6081              STR      r1,[r0,#8]            ;2226
00002e  1d21              ADDS     r1,r4,#4              ;2229
000030  6820              LDR      r0,[r4,#0]            ;2229
000032  f7fffffe          BL       TIM_Base_SetConfig
000036  6822              LDR      r2,[r4,#0]            ;2232
000038  6890              LDR      r0,[r2,#8]            ;2232
00003a  6991              LDR      r1,[r2,#0x18]         ;2235
00003c  6a16              LDR      r6,[r2,#0x20]         ;2238
00003e  682b              LDR      r3,[r5,#0]            ;2241
000040  69af              LDR      r7,[r5,#0x18]         ;2245
000042  4303              ORRS     r3,r3,r0              ;2241
000044  f2403003          MOV      r0,#0x303             ;2244
000048  4381              BICS     r1,r1,r0              ;2244
00004a  ea412107          ORR      r1,r1,r7,LSL #8       ;2245
00004e  68a8              LDR      r0,[r5,#8]            ;2245
000050  69ef              LDR      r7,[r5,#0x1c]         ;2250
000052  4308              ORRS     r0,r0,r1              ;2245
000054  f64f41fc          MOV      r1,#0xfcfc            ;2248
000058  4388              BICS     r0,r0,r1              ;2248
00005a  68e9              LDR      r1,[r5,#0xc]          ;2250
00005c  ea402007          ORR      r0,r0,r7,LSL #8       ;2250
000060  4301              ORRS     r1,r1,r0              ;2250
000062  6928              LDR      r0,[r5,#0x10]         ;2251
000064  6a2f              LDR      r7,[r5,#0x20]         ;2251
000066  0100              LSLS     r0,r0,#4              ;2251
000068  ea403007          ORR      r0,r0,r7,LSL #12      ;2251
00006c  4308              ORRS     r0,r0,r1              ;2251
00006e  6869              LDR      r1,[r5,#4]            ;2256
000070  696d              LDR      r5,[r5,#0x14]         ;2256
000072  f02606aa          BIC      r6,r6,#0xaa           ;2255
000076  ea461505          ORR      r5,r6,r5,LSL #4       ;2256
00007a  4329              ORRS     r1,r1,r5              ;2256
00007c  6093              STR      r3,[r2,#8]            ;2259
00007e  6822              LDR      r2,[r4,#0]            ;2262
000080  6190              STR      r0,[r2,#0x18]         ;2262
000082  6820              LDR      r0,[r4,#0]            ;2265
000084  6201              STR      r1,[r0,#0x20]         ;2265
000086  2001              MOVS     r0,#1                 ;2268
000088  f8840039          STRB     r0,[r4,#0x39]         ;2268
00008c  2000              MOVS     r0,#0                 ;2270
00008e  e7c1              B        |L24.20|
;;;2272   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2316     */
;;;2317   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2318   {
;;;2319     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2320               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2321      */
;;;2322   }
;;;2323   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2304     */
;;;2305   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2306   {
;;;2307     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2308               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2309      */
;;;2310   }
;;;2311   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start PROC
;;;2332     */
;;;2333   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2334   {
000002  4604              MOV      r4,r0
;;;2335     /* Check the parameters */
;;;2336     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2337     
;;;2338     /* Enable the encoder interface channels */
;;;2339     switch (Channel)
;;;2340     {
;;;2341       case TIM_CHANNEL_1:
;;;2342       {
;;;2343         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b191              CBZ      r1,|L27.46|
000008  2904              CMP      r1,#4                 ;2339
00000a  d004              BEQ      |L27.22|
;;;2344         break; 
;;;2345       }
;;;2346       case TIM_CHANNEL_2:
;;;2347       { 
;;;2348         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2349         break;
;;;2350       }  
;;;2351       default :
;;;2352       {
;;;2353        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000c  2201              MOVS     r2,#1
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2354        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L27.22|
000016  2201              MOVS     r2,#1                 ;2348
000018  f05f0104          MOVS.W   r1,#4                 ;2348
                  |L27.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2355        break; 
;;;2356       }
;;;2357     }  
;;;2358     /* Enable the Peripheral */
;;;2359     __HAL_TIM_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0410101          ORR      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
;;;2360     
;;;2361     /* Return function status */
;;;2362     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2363   }
00002c  bd10              POP      {r4,pc}
                  |L27.46|
00002e  2201              MOVS     r2,#1                 ;2343
000030  2100              MOVS     r1,#0                 ;2343
000032  e7f3              B        |L27.28|
;;;2364   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2515     */
;;;2516   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2517   {
000004  4604              MOV      r4,r0
;;;2518     /* Check the parameters */
;;;2519     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2520     
;;;2521     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8900039          LDRB     r0,[r0,#0x39]
00000a  9f06              LDR      r7,[sp,#0x18]
00000c  4698              MOV      r8,r3                 ;2517
00000e  2802              CMP      r0,#2
000010  d009              BEQ      |L28.38|
;;;2522     {
;;;2523        return HAL_BUSY;
;;;2524     }
;;;2525     else if((htim->State == HAL_TIM_STATE_READY))
000012  f8940039          LDRB     r0,[r4,#0x39]
000016  2801              CMP      r0,#1
000018  d10a              BNE      |L28.48|
;;;2526     {
;;;2527       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
00001a  b112              CBZ      r2,|L28.34|
00001c  f1b80f00          CMP      r8,#0
000020  d103              BNE      |L28.42|
                  |L28.34|
000022  b117              CBZ      r7,|L28.42|
;;;2528       {
;;;2529         return HAL_ERROR;                                    
000024  2001              MOVS     r0,#1
                  |L28.38|
;;;2530       }
;;;2531       else
;;;2532       {
;;;2533         htim->State = HAL_TIM_STATE_BUSY;
;;;2534       }
;;;2535     }  
;;;2536      
;;;2537     switch (Channel)
;;;2538     {
;;;2539       case TIM_CHANNEL_1:
;;;2540       {
;;;2541         /* Set the DMA Period elapsed callback */
;;;2542         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2543        
;;;2544         /* Set the DMA error callback */
;;;2545         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2546         
;;;2547         /* Enable the DMA Stream */
;;;2548         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2549         
;;;2550         /* Enable the TIM Input Capture DMA request */      
;;;2551         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2552               
;;;2553         /* Enable the Peripheral */
;;;2554         __HAL_TIM_ENABLE(htim);
;;;2555         
;;;2556         /* Enable the Capture compare channel */
;;;2557         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2558       }
;;;2559       break;
;;;2560       
;;;2561       case TIM_CHANNEL_2:
;;;2562       {
;;;2563         /* Set the DMA Period elapsed callback */
;;;2564         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2565        
;;;2566         /* Set the DMA error callback */
;;;2567         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
;;;2568         /* Enable the DMA Stream */
;;;2569         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2570         
;;;2571         /* Enable the TIM Input Capture  DMA request */
;;;2572         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2573        
;;;2574         /* Enable the Peripheral */
;;;2575         __HAL_TIM_ENABLE(htim);
;;;2576         
;;;2577         /* Enable the Capture compare channel */
;;;2578         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2579       }
;;;2580       break;
;;;2581       
;;;2582       case TIM_CHANNEL_ALL:
;;;2583       {
;;;2584         /* Set the DMA Period elapsed callback */
;;;2585         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2586        
;;;2587         /* Set the DMA error callback */
;;;2588         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2589         
;;;2590         /* Enable the DMA Stream */
;;;2591         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2592         
;;;2593         /* Set the DMA Period elapsed callback */
;;;2594         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2595        
;;;2596         /* Set the DMA error callback */
;;;2597         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2598         
;;;2599         /* Enable the DMA Stream */
;;;2600         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2601             
;;;2602        /* Enable the Peripheral */
;;;2603         __HAL_TIM_ENABLE(htim);
;;;2604         
;;;2605         /* Enable the Capture compare channel */
;;;2606         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2607         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2608         
;;;2609         /* Enable the TIM Input Capture  DMA request */
;;;2610         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2611         /* Enable the TIM Input Capture  DMA request */
;;;2612         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2613       }
;;;2614       break;
;;;2615       
;;;2616       default:
;;;2617       break;
;;;2618     }  
;;;2619     /* Return function status */
;;;2620     return HAL_OK;
;;;2621   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L28.42|
00002a  2002              MOVS     r0,#2                 ;2533
00002c  f8840039          STRB     r0,[r4,#0x39]         ;2533
                  |L28.48|
000030  4d35              LDR      r5,|L28.264|
000032  4e36              LDR      r6,|L28.268|
000034  b121              CBZ      r1,|L28.64|
000036  2904              CMP      r1,#4                 ;2537
000038  d01a              BEQ      |L28.112|
00003a  2918              CMP      r1,#0x18              ;2537
00003c  d161              BNE      |L28.258|
00003e  e032              B        |L28.166|
                  |L28.64|
000040  6a20              LDR      r0,[r4,#0x20]         ;2542
000042  463b              MOV      r3,r7                 ;2548
000044  63c5              STR      r5,[r0,#0x3c]         ;2545
000046  6a20              LDR      r0,[r4,#0x20]         ;2545
000048  6486              STR      r6,[r0,#0x48]         ;2548
00004a  6821              LDR      r1,[r4,#0]            ;2548
00004c  6a20              LDR      r0,[r4,#0x20]         ;2548
00004e  3134              ADDS     r1,r1,#0x34           ;2548
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;2551
000056  68c1              LDR      r1,[r0,#0xc]          ;2551
000058  f4417100          ORR      r1,r1,#0x200          ;2551
00005c  60c1              STR      r1,[r0,#0xc]          ;2551
00005e  6820              LDR      r0,[r4,#0]            ;2554
000060  6801              LDR      r1,[r0,#0]            ;2554
000062  f0410101          ORR      r1,r1,#1              ;2554
000066  6001              STR      r1,[r0,#0]            ;2554
000068  2201              MOVS     r2,#1                 ;2557
00006a  2100              MOVS     r1,#0                 ;2557
00006c  6820              LDR      r0,[r4,#0]            ;2559
00006e  e017              B        |L28.160|
                  |L28.112|
000070  6a60              LDR      r0,[r4,#0x24]         ;2564
000072  463b              MOV      r3,r7                 ;2569
000074  4642              MOV      r2,r8                 ;2569
000076  63c5              STR      r5,[r0,#0x3c]         ;2567
000078  6a60              LDR      r0,[r4,#0x24]         ;2567
00007a  6486              STR      r6,[r0,#0x48]         ;2569
00007c  6821              LDR      r1,[r4,#0]            ;2569
00007e  6a60              LDR      r0,[r4,#0x24]         ;2569
000080  3138              ADDS     r1,r1,#0x38           ;2569
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;2572
000088  68c1              LDR      r1,[r0,#0xc]          ;2572
00008a  f4416180          ORR      r1,r1,#0x400          ;2572
00008e  60c1              STR      r1,[r0,#0xc]          ;2572
000090  6820              LDR      r0,[r4,#0]            ;2575
000092  6801              LDR      r1,[r0,#0]            ;2575
000094  f0410101          ORR      r1,r1,#1              ;2575
000098  6001              STR      r1,[r0,#0]            ;2575
00009a  2201              MOVS     r2,#1                 ;2578
00009c  2104              MOVS     r1,#4                 ;2578
00009e  6820              LDR      r0,[r4,#0]            ;2578
                  |L28.160|
0000a0  f7fffffe          BL       TIM_CCxChannelCmd
0000a4  e02d              B        |L28.258|
                  |L28.166|
0000a6  6a20              LDR      r0,[r4,#0x20]         ;2585
0000a8  463b              MOV      r3,r7                 ;2591
0000aa  63c5              STR      r5,[r0,#0x3c]         ;2588
0000ac  6a20              LDR      r0,[r4,#0x20]         ;2588
0000ae  6486              STR      r6,[r0,#0x48]         ;2591
0000b0  6821              LDR      r1,[r4,#0]            ;2591
0000b2  6a20              LDR      r0,[r4,#0x20]         ;2591
0000b4  3134              ADDS     r1,r1,#0x34           ;2591
0000b6  f7fffffe          BL       HAL_DMA_Start_IT
0000ba  6a60              LDR      r0,[r4,#0x24]         ;2594
0000bc  463b              MOV      r3,r7                 ;2600
0000be  4642              MOV      r2,r8                 ;2600
0000c0  63c5              STR      r5,[r0,#0x3c]         ;2597
0000c2  6a60              LDR      r0,[r4,#0x24]         ;2597
0000c4  6486              STR      r6,[r0,#0x48]         ;2600
0000c6  6821              LDR      r1,[r4,#0]            ;2600
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2600
0000ca  3138              ADDS     r1,r1,#0x38           ;2600
0000cc  f7fffffe          BL       HAL_DMA_Start_IT
0000d0  6820              LDR      r0,[r4,#0]            ;2603
0000d2  6801              LDR      r1,[r0,#0]            ;2603
0000d4  f0410101          ORR      r1,r1,#1              ;2603
0000d8  6001              STR      r1,[r0,#0]            ;2603
0000da  2201              MOVS     r2,#1                 ;2606
0000dc  2100              MOVS     r1,#0                 ;2606
0000de  6820              LDR      r0,[r4,#0]            ;2606
0000e0  f7fffffe          BL       TIM_CCxChannelCmd
0000e4  2201              MOVS     r2,#1                 ;2607
0000e6  2104              MOVS     r1,#4                 ;2607
0000e8  6820              LDR      r0,[r4,#0]            ;2607
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  6820              LDR      r0,[r4,#0]            ;2610
0000f0  68c1              LDR      r1,[r0,#0xc]          ;2610
0000f2  f4417100          ORR      r1,r1,#0x200          ;2610
0000f6  60c1              STR      r1,[r0,#0xc]          ;2610
0000f8  6820              LDR      r0,[r4,#0]            ;2612
0000fa  68c1              LDR      r1,[r0,#0xc]          ;2612
0000fc  f4416180          ORR      r1,r1,#0x400          ;2612
000100  60c1              STR      r1,[r0,#0xc]          ;2612
                  |L28.258|
000102  2000              MOVS     r0,#0                 ;2620
000104  e78f              B        |L28.38|
;;;2622   
                          ENDP

000106  0000              DCW      0x0000
                  |L28.264|
                          DCD      HAL_TIM_DMACaptureCplt
                  |L28.268|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2415     */
;;;2416   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2417   {
000002  4604              MOV      r4,r0
;;;2418     /* Check the parameters */
;;;2419     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2420     
;;;2421     /* Enable the encoder interface channels */
;;;2422     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2423     switch (Channel)
;;;2424     {
;;;2425       case TIM_CHANNEL_1:
;;;2426       {
;;;2427         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b189              CBZ      r1,|L29.44|
000008  2904              CMP      r1,#4                 ;2423
;;;2428         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2429         break; 
;;;2430       }
;;;2431       case TIM_CHANNEL_2:
;;;2432       { 
;;;2433         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000a  f04f0201          MOV      r2,#1
00000e  d016              BEQ      |L29.62|
;;;2434         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
;;;2435         break;
;;;2436       }  
;;;2437       default :
;;;2438       {
;;;2439        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2440        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  2201              MOVS     r2,#1
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2441        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410102          ORR      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2442        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2443        break; 
00002a  e00b              B        |L29.68|
                  |L29.44|
00002c  2201              MOVS     r2,#1                 ;2427
00002e  2100              MOVS     r1,#0                 ;2427
000030  f7fffffe          BL       TIM_CCxChannelCmd
000034  6820              LDR      r0,[r4,#0]            ;2428
000036  68c1              LDR      r1,[r0,#0xc]          ;2428
000038  f0410102          ORR      r1,r1,#2              ;2428
00003c  e006              B        |L29.76|
                  |L29.62|
00003e  2104              MOVS     r1,#4                 ;2433
000040  f7fffffe          BL       TIM_CCxChannelCmd
                  |L29.68|
000044  6820              LDR      r0,[r4,#0]            ;2442
000046  68c1              LDR      r1,[r0,#0xc]          ;2442
000048  f0410104          ORR      r1,r1,#4              ;2442
                  |L29.76|
00004c  60c1              STR      r1,[r0,#0xc]          ;2428
;;;2444       }
;;;2445     }
;;;2446     
;;;2447     /* Enable the Peripheral */
;;;2448     __HAL_TIM_ENABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6801              LDR      r1,[r0,#0]
000052  f0410101          ORR      r1,r1,#1
000056  6001              STR      r1,[r0,#0]
;;;2449     
;;;2450     /* Return function status */
;;;2451     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;2452   }
00005a  bd10              POP      {r4,pc}
;;;2453   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2373     */
;;;2374   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2375   {
000002  4604              MOV      r4,r0
;;;2376     /* Check the parameters */
;;;2377       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2378       
;;;2379      /* Disable the Input Capture channels 1 and 2
;;;2380       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2381     switch (Channel)
;;;2382     {
;;;2383       case TIM_CHANNEL_1:
;;;2384       {
;;;2385         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b1d9              CBZ      r1,|L30.64|
000008  2904              CMP      r1,#4                 ;2381
00000a  d004              BEQ      |L30.22|
;;;2386         break; 
;;;2387       }
;;;2388       case TIM_CHANNEL_2:
;;;2389       { 
;;;2390         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2391         break;
;;;2392       }  
;;;2393       default :
;;;2394       {
;;;2395        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2396        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L30.22|
000016  2200              MOVS     r2,#0                 ;2390
000018  f05f0104          MOVS.W   r1,#4                 ;2390
                  |L30.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2397        break; 
;;;2398       }
;;;2399     }  
;;;2400     /* Disable the Peripheral */
;;;2401     __HAL_TIM_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a01              LDR      r1,[r0,#0x20]
000024  f2411211          MOV      r2,#0x1111
000028  4211              TST      r1,r2
00002a  d107              BNE      |L30.60|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  1092              ASRS     r2,r2,#2
000030  4211              TST      r1,r2
000032  d103              BNE      |L30.60|
000034  6801              LDR      r1,[r0,#0]
000036  f0210101          BIC      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L30.60|
;;;2402     
;;;2403     /* Return function status */
;;;2404     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2405   }
00003e  bd10              POP      {r4,pc}
                  |L30.64|
000040  2200              MOVS     r2,#0                 ;2385
000042  4611              MOV      r1,r2                 ;2385
000044  e7ea              B        |L30.28|
;;;2406   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2631     */
;;;2632   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2633   {
000002  4604              MOV      r4,r0
;;;2634     /* Check the parameters */
;;;2635     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2636     
;;;2637     /* Disable the Input Capture channels 1 and 2
;;;2638       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2639     if(Channel == TIM_CHANNEL_1)
;;;2640     {
;;;2641       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L31.90|
;;;2642       
;;;2643       /* Disable the capture compare DMA Request 1 */
;;;2644       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2645     }  
;;;2646     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2647     {  
;;;2648       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2649       
;;;2650       /* Disable the capture compare DMA Request 2 */
;;;2651       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2652     }  
;;;2653     else
;;;2654     {
;;;2655       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L31.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2656       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2657       
;;;2658       /* Disable the capture compare DMA Request 1 and 2 */
;;;2659       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
                  |L31.42|
00002a  6820              LDR      r0,[r4,#0]            ;2651
00002c  68c1              LDR      r1,[r0,#0xc]          ;2651
00002e  f4216180          BIC      r1,r1,#0x400          ;2651
                  |L31.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2651
;;;2660       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2661     }
;;;2662     
;;;2663     /* Disable the Peripheral */
;;;2664     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L31.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L31.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L31.80|
;;;2665     
;;;2666     /* Change the htim state */
;;;2667     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f8840039          STRB     r0,[r4,#0x39]
;;;2668     
;;;2669     /* Return function status */
;;;2670     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2671   }
000058  bd10              POP      {r4,pc}
                  |L31.90|
00005a  2200              MOVS     r2,#0                 ;2641
00005c  4611              MOV      r1,r2                 ;2641
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2644
000064  68c1              LDR      r1,[r0,#0xc]          ;2644
000066  f4217100          BIC      r1,r1,#0x200          ;2644
00006a  e7e2              B        |L31.50|
                  |L31.108|
00006c  2104              MOVS     r1,#4                 ;2648
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L31.42|
;;;2672   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2462     */
;;;2463   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2464   {
000002  4604              MOV      r4,r0
;;;2465     /* Check the parameters */
;;;2466     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2467       
;;;2468     /* Disable the Input Capture channels 1 and 2
;;;2469       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2470     if(Channel == TIM_CHANNEL_1)
;;;2471     {
;;;2472       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  b341              CBZ      r1,|L32.90|
;;;2473       
;;;2474       /* Disable the capture compare Interrupts 1 */
;;;2475     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2476     }  
;;;2477     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2478     {  
;;;2479       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2480       
;;;2481       /* Disable the capture compare Interrupts 2 */
;;;2482     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2483     }  
;;;2484     else
;;;2485     {
;;;2486       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00000a  f04f0200          MOV      r2,#0
00000e  d02d              BEQ      |L32.108|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2487       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000016  2200              MOVS     r2,#0
000018  2104              MOVS     r1,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2488       
;;;2489       /* Disable the capture compare Interrupts 1 and 2 */
;;;2490       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0210102          BIC      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
                  |L32.42|
00002a  6820              LDR      r0,[r4,#0]            ;2482
00002c  68c1              LDR      r1,[r0,#0xc]          ;2482
00002e  f0210104          BIC      r1,r1,#4              ;2482
                  |L32.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2482
;;;2491       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2492     }
;;;2493       
;;;2494     /* Disable the Peripheral */
;;;2495     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  f2411211          MOV      r2,#0x1111
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L32.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L32.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L32.80|
;;;2496     
;;;2497     /* Change the htim state */
;;;2498     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f8840039          STRB     r0,[r4,#0x39]
;;;2499     
;;;2500     /* Return function status */
;;;2501     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2502   }
000058  bd10              POP      {r4,pc}
                  |L32.90|
00005a  2200              MOVS     r2,#0                 ;2472
00005c  4611              MOV      r1,r2                 ;2472
00005e  f7fffffe          BL       TIM_CCxChannelCmd
000062  6820              LDR      r0,[r4,#0]            ;2475
000064  68c1              LDR      r1,[r0,#0xc]          ;2475
000066  f0210102          BIC      r1,r1,#2              ;2475
00006a  e7e2              B        |L32.50|
                  |L32.108|
00006c  2104              MOVS     r1,#4                 ;2479
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  e7da              B        |L32.42|
;;;2503   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4209     */
;;;4210   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4211   {
;;;4212     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4213               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4214      */
;;;4215   }
;;;4216   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3606   
;;;3607   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  f8902038          LDRB     r2,[r0,#0x38]
;;;3608   {
;;;3609     /* Check the parameters */
;;;3610     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3611     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3612     
;;;3613     /* Process Locked */
;;;3614     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00c              BEQ      |L34.34|
000008  2201              MOVS     r2,#1
00000a  f8002f38          STRB     r2,[r0,#0x38]!
;;;3615     
;;;3616     /* Change the TIM state */
;;;3617     htim->State = HAL_TIM_STATE_BUSY;
00000e  2302              MOVS     r3,#2
000010  7043              STRB     r3,[r0,#1]
;;;3618     
;;;3619     /* Set the event sources */
;;;3620     htim->Instance->EGR = EventSource;
000012  f8503c38          LDR      r3,[r0,#-0x38]
000016  6159              STR      r1,[r3,#0x14]
;;;3621     
;;;3622     /* Change the TIM state */
;;;3623     htim->State = HAL_TIM_STATE_READY;
000018  7042              STRB     r2,[r0,#1]
;;;3624     
;;;3625     __HAL_UNLOCK(htim);
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;3626     
;;;3627     /* Return function status */
;;;3628     return HAL_OK;  
00001e  4608              MOV      r0,r1
;;;3629   }
000020  4770              BX       lr
                  |L34.34|
000022  2002              MOVS     r0,#2                 ;3614
000024  4770              BX       lr
;;;3630   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4173     */
;;;4174   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4175   {
;;;4176     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4177               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4178      */
;;;4179   }
;;;4180   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_ConfigChannel PROC
;;;2929     */
;;;2930   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2931   {
000004  4604              MOV      r4,r0
;;;2932     /* Check the parameters */
;;;2933     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2934     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;2935     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;2936     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;2937     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;2938     
;;;2939     __HAL_LOCK(htim);
000006  f8900038          LDRB     r0,[r0,#0x38]
00000a  460d              MOV      r5,r1                 ;2931
00000c  2801              CMP      r0,#1
00000e  d037              BEQ      |L36.128|
000010  2601              MOVS     r6,#1
000012  f8846038          STRB     r6,[r4,#0x38]
;;;2940     
;;;2941     htim->State = HAL_TIM_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f8840039          STRB     r0,[r4,#0x39]
00001c  b37a              CBZ      r2,|L36.126|
;;;2942     
;;;2943     if (Channel == TIM_CHANNEL_1)
;;;2944     {
;;;2945       /* TI1 Configuration */
;;;2946       TIM_TI1_SetConfig(htim->Instance,
;;;2947                  sConfig->ICPolarity,
;;;2948                  sConfig->ICSelection,
;;;2949                  sConfig->ICFilter);
;;;2950                  
;;;2951       /* Reset the IC1PSC Bits */
;;;2952       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;2953   
;;;2954       /* Set the IC1PSC value */
;;;2955       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;2956     }
;;;2957     else if (Channel == TIM_CHANNEL_2)
00001e  2a04              CMP      r2,#4
000020  d040              BEQ      |L36.164|
;;;2958     {
;;;2959       /* TI2 Configuration */
;;;2960       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2961       
;;;2962       TIM_TI2_SetConfig(htim->Instance, 
;;;2963                         sConfig->ICPolarity,
;;;2964                         sConfig->ICSelection,
;;;2965                         sConfig->ICFilter);
;;;2966                  
;;;2967       /* Reset the IC2PSC Bits */
;;;2968       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;2969   
;;;2970       /* Set the IC2PSC value */
;;;2971       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;2972     }
;;;2973     else if (Channel == TIM_CHANNEL_3)
000022  6820              LDR      r0,[r4,#0]
000024  2a08              CMP      r2,#8
000026  d04f              BEQ      |L36.200|
;;;2974     {
;;;2975       /* TI3 Configuration */
;;;2976       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2977       
;;;2978       TIM_TI3_SetConfig(htim->Instance,  
;;;2979                  sConfig->ICPolarity,
;;;2980                  sConfig->ICSelection,
;;;2981                  sConfig->ICFilter);
;;;2982                  
;;;2983       /* Reset the IC3PSC Bits */
;;;2984       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;2985   
;;;2986       /* Set the IC3PSC value */
;;;2987       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;2988     }
;;;2989     else
;;;2990     {
;;;2991       /* TI4 Configuration */
;;;2992       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2993       
;;;2994       TIM_TI4_SetConfig(htim->Instance, 
000028  e9d53200          LDRD     r3,r2,[r5,#0]
00002c  68e9              LDR      r1,[r5,#0xc]
00002e  6a07              LDR      r7,[r0,#0x20]
000030  f4275780          BIC      r7,r7,#0x1000
000034  6207              STR      r7,[r0,#0x20]
000036  f8d0c01c          LDR      r12,[r0,#0x1c]
00003a  6a07              LDR      r7,[r0,#0x20]
00003c  f42c7c40          BIC      r12,r12,#0x300
000040  ea4c2202          ORR      r2,r12,r2,LSL #8
000044  f4224270          BIC      r2,r2,#0xf000
000048  ea423101          ORR      r1,r2,r1,LSL #12
00004c  f4274220          BIC      r2,r7,#0xa000
000050  ea423203          ORR      r2,r2,r3,LSL #12
000054  61c1              STR      r1,[r0,#0x1c]
000056  6202              STR      r2,[r0,#0x20]
;;;2995                  sConfig->ICPolarity,
;;;2996                  sConfig->ICSelection,
;;;2997                  sConfig->ICFilter);
;;;2998                  
;;;2999       /* Reset the IC4PSC Bits */
;;;3000       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000058  6820              LDR      r0,[r4,#0]
00005a  69c1              LDR      r1,[r0,#0x1c]
00005c  f4216140          BIC      r1,r1,#0xc00
000060  61c1              STR      r1,[r0,#0x1c]
;;;3001   
;;;3002       /* Set the IC4PSC value */
;;;3003       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
000062  6820              LDR      r0,[r4,#0]
000064  69c1              LDR      r1,[r0,#0x1c]
000066  68aa              LDR      r2,[r5,#8]
000068  ea412102          ORR      r1,r1,r2,LSL #8
                  |L36.108|
00006c  f8c0101c          STR.W    r1,[r0,#0x1c]         ;2987
                  |L36.112|
;;;3004     }
;;;3005     
;;;3006     htim->State = HAL_TIM_STATE_READY;
000070  f8846039          STRB     r6,[r4,#0x39]
;;;3007       
;;;3008     __HAL_UNLOCK(htim);
000074  2000              MOVS     r0,#0
000076  f8840038          STRB     r0,[r4,#0x38]
                  |L36.122|
;;;3009     
;;;3010     return HAL_OK; 
;;;3011   }
00007a  e8bd81f0          POP      {r4-r8,pc}
                  |L36.126|
00007e  e001              B        |L36.132|
                  |L36.128|
000080  2002              MOVS     r0,#2                 ;2939
000082  e7fa              B        |L36.122|
                  |L36.132|
000084  e9d51200          LDRD     r1,r2,[r5,#0]         ;2946
000088  68eb              LDR      r3,[r5,#0xc]          ;2946
00008a  6820              LDR      r0,[r4,#0]            ;2946
00008c  f7fffffe          BL       TIM_TI1_SetConfig
000090  6820              LDR      r0,[r4,#0]            ;2952
000092  6981              LDR      r1,[r0,#0x18]         ;2952
000094  f021010c          BIC      r1,r1,#0xc            ;2952
000098  6181              STR      r1,[r0,#0x18]         ;2952
00009a  6820              LDR      r0,[r4,#0]            ;2955
00009c  6981              LDR      r1,[r0,#0x18]         ;2955
00009e  68aa              LDR      r2,[r5,#8]            ;2955
0000a0  4311              ORRS     r1,r1,r2              ;2955
0000a2  e00f              B        |L36.196|
                  |L36.164|
0000a4  e9d51200          LDRD     r1,r2,[r5,#0]         ;2962
0000a8  68eb              LDR      r3,[r5,#0xc]          ;2962
0000aa  6820              LDR      r0,[r4,#0]            ;2962
0000ac  f7fffffe          BL       TIM_TI2_SetConfig
0000b0  6820              LDR      r0,[r4,#0]            ;2968
0000b2  6981              LDR      r1,[r0,#0x18]         ;2968
0000b4  f4216140          BIC      r1,r1,#0xc00          ;2968
0000b8  6181              STR      r1,[r0,#0x18]         ;2968
0000ba  6820              LDR      r0,[r4,#0]            ;2971
0000bc  6981              LDR      r1,[r0,#0x18]         ;2971
0000be  68aa              LDR      r2,[r5,#8]            ;2971
0000c0  ea412102          ORR      r1,r1,r2,LSL #8       ;2971
                  |L36.196|
0000c4  6181              STR      r1,[r0,#0x18]         ;2971
0000c6  e7d3              B        |L36.112|
                  |L36.200|
0000c8  e9d53c00          LDRD     r3,r12,[r5,#0]        ;2978
0000cc  68ea              LDR      r2,[r5,#0xc]          ;2978
0000ce  6a01              LDR      r1,[r0,#0x20]         ;2978
0000d0  f4217180          BIC      r1,r1,#0x100          ;2978
0000d4  6201              STR      r1,[r0,#0x20]         ;2978
0000d6  69c1              LDR      r1,[r0,#0x1c]         ;2978
0000d8  6a07              LDR      r7,[r0,#0x20]         ;2978
0000da  f0210103          BIC      r1,r1,#3              ;2978
0000de  ea41010c          ORR      r1,r1,r12             ;2978
0000e2  f02101f0          BIC      r1,r1,#0xf0           ;2978
0000e6  ea411102          ORR      r1,r1,r2,LSL #4       ;2978
0000ea  f4276220          BIC      r2,r7,#0xa00          ;2978
0000ee  ea422203          ORR      r2,r2,r3,LSL #8       ;2978
0000f2  61c1              STR      r1,[r0,#0x1c]         ;2978
0000f4  6202              STR      r2,[r0,#0x20]         ;2978
0000f6  6820              LDR      r0,[r4,#0]            ;2984
0000f8  69c1              LDR      r1,[r0,#0x1c]         ;2984
0000fa  f021010c          BIC      r1,r1,#0xc            ;2984
0000fe  61c1              STR      r1,[r0,#0x1c]         ;2984
000100  6820              LDR      r0,[r4,#0]            ;2987
000102  69c1              LDR      r1,[r0,#0x1c]         ;2987
000104  68aa              LDR      r2,[r5,#8]            ;2987
000106  4311              ORRS     r1,r1,r2              ;2987
000108  e7b0              B        |L36.108|
;;;3012   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1498     */
;;;1499   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1500   {
000002  4604              MOV      r4,r0
;;;1501     /* Check the parameters */
;;;1502     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1503   
;;;1504     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1505     
;;;1506     /* Disable the TIM Peripheral Clock */
;;;1507     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L37.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L37.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L37.38|
;;;1508       
;;;1509     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1510     HAL_TIM_IC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1511       
;;;1512     /* Change TIM state */  
;;;1513     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;1514   
;;;1515     /* Release Lock */
;;;1516     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;1517   
;;;1518     return HAL_OK;
;;;1519   }
000036  bd10              POP      {r4,pc}
;;;1520   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4270     */
;;;4271   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4272   {
;;;4273     return htim->State;
;;;4274   }
000004  4770              BX       lr
;;;4275   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1462     */
;;;1463   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1464   {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L39.14|
;;;1465     /* Check the TIM handle allocation */
;;;1466     if(htim == NULL)
;;;1467     {
;;;1468       return HAL_ERROR;
;;;1469     }
;;;1470   
;;;1471     /* Check the parameters */
;;;1472     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1473     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1474     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1475   
;;;1476     if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L39.18|
00000c  e004              B        |L39.24|
                  |L39.14|
00000e  2001              MOVS     r0,#1                 ;1468
;;;1477     {  
;;;1478       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1479       HAL_TIM_IC_MspInit(htim);
;;;1480     }
;;;1481     
;;;1482     /* Set the TIM state */
;;;1483     htim->State= HAL_TIM_STATE_BUSY;   
;;;1484     
;;;1485     /* Init the base time for the input capture */  
;;;1486     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1487      
;;;1488     /* Initialize the TIM state*/
;;;1489     htim->State= HAL_TIM_STATE_READY;
;;;1490     
;;;1491     return HAL_OK;
;;;1492   }
000010  bd10              POP      {r4,pc}
                  |L39.18|
000012  4620              MOV      r0,r4                 ;1479
000014  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L39.24|
000018  2002              MOVS     r0,#2                 ;1483
00001a  f8840039          STRB     r0,[r4,#0x39]         ;1483
00001e  1d21              ADDS     r1,r4,#4              ;1486
000020  6820              LDR      r0,[r4,#0]            ;1486
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1489
000028  f8840039          STRB     r0,[r4,#0x39]         ;1489
00002c  2000              MOVS     r0,#0                 ;1491
00002e  bd10              POP      {r4,pc}
;;;1493   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1537     */
;;;1538   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1539   {
;;;1540     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1541               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1542      */
;;;1543   }
;;;1544   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1525     */
;;;1526   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1527   {
;;;1528     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1529               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1530      */
;;;1531   }
;;;1532   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1555     */
;;;1556   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1557   {
000002  4604              MOV      r4,r0
;;;1558     /* Check the parameters */
;;;1559     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1560     
;;;1561     /* Enable the Input Capture channel */
;;;1562     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1563       
;;;1564     /* Enable the Peripheral */
;;;1565     __HAL_TIM_ENABLE(htim);  
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0410101          ORR      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;1566   
;;;1567     /* Return function status */
;;;1568     return HAL_OK;  
000016  2000              MOVS     r0,#0
;;;1569   } 
000018  bd10              POP      {r4,pc}
;;;1570   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1728     */
;;;1729   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1730   {
000002  4604              MOV      r4,r0
;;;1731     /* Check the parameters */
;;;1732     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1733     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1734     
;;;1735     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  460e              MOV      r6,r1                 ;1730
00000a  2802              CMP      r0,#2
00000c  d005              BEQ      |L43.26|
;;;1736     {
;;;1737        return HAL_BUSY;
;;;1738     }
;;;1739     else if((htim->State == HAL_TIM_STATE_READY))
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2801              CMP      r0,#1
000014  d105              BNE      |L43.34|
;;;1740     {
;;;1741       if((pData == 0 ) && (Length > 0)) 
000016  b90a              CBNZ     r2,|L43.28|
000018  b103              CBZ      r3,|L43.28|
                  |L43.26|
;;;1742       {
;;;1743         return HAL_ERROR;                                    
;;;1744       }
;;;1745       else
;;;1746       {
;;;1747         htim->State = HAL_TIM_STATE_BUSY;
;;;1748       }
;;;1749     }  
;;;1750      
;;;1751     switch (Channel)
;;;1752     {
;;;1753       case TIM_CHANNEL_1:
;;;1754       {
;;;1755         /* Set the DMA Period elapsed callback */
;;;1756         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1757        
;;;1758         /* Set the DMA error callback */
;;;1759         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1760         
;;;1761         /* Enable the DMA Stream */
;;;1762         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1763         
;;;1764         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1765         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1766       }
;;;1767       break;
;;;1768       
;;;1769       case TIM_CHANNEL_2:
;;;1770       {
;;;1771         /* Set the DMA Period elapsed callback */
;;;1772         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1773        
;;;1774         /* Set the DMA error callback */
;;;1775         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1776         
;;;1777         /* Enable the DMA Stream */
;;;1778         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1779         
;;;1780         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1781         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1782       }
;;;1783       break;
;;;1784       
;;;1785       case TIM_CHANNEL_3:
;;;1786       {
;;;1787         /* Set the DMA Period elapsed callback */
;;;1788         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1789        
;;;1790         /* Set the DMA error callback */
;;;1791         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1792         
;;;1793         /* Enable the DMA Stream */
;;;1794         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1795         
;;;1796         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1797         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1798       }
;;;1799       break;
;;;1800       
;;;1801       case TIM_CHANNEL_4:
;;;1802       {
;;;1803         /* Set the DMA Period elapsed callback */
;;;1804         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1805        
;;;1806         /* Set the DMA error callback */
;;;1807         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1808         
;;;1809         /* Enable the DMA Stream */
;;;1810         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1811         
;;;1812         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1813         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1814       }
;;;1815       break;
;;;1816       
;;;1817       default:
;;;1818       break;
;;;1819     }
;;;1820   
;;;1821     /* Enable the Input Capture channel */
;;;1822     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1823      
;;;1824     /* Enable the Peripheral */
;;;1825     __HAL_TIM_ENABLE(htim); 
;;;1826     
;;;1827     /* Return function status */
;;;1828     return HAL_OK;
;;;1829   }
00001a  bd70              POP      {r4-r6,pc}
                  |L43.28|
00001c  2002              MOVS     r0,#2                 ;1747
00001e  f8840039          STRB     r0,[r4,#0x39]         ;1747
                  |L43.34|
000022  4827              LDR      r0,|L43.192|
000024  4d27              LDR      r5,|L43.196|
000026  b136              CBZ      r6,|L43.54|
000028  2e04              CMP      r6,#4                 ;1751
00002a  d012              BEQ      |L43.82|
00002c  2e08              CMP      r6,#8                 ;1751
00002e  d02a              BEQ      |L43.134|
000030  2e0c              CMP      r6,#0xc               ;1751
000032  d11c              BNE      |L43.110|
000034  e035              B        |L43.162|
                  |L43.54|
000036  6a21              LDR      r1,[r4,#0x20]         ;1756
000038  63c8              STR      r0,[r1,#0x3c]         ;1759
00003a  6a20              LDR      r0,[r4,#0x20]         ;1759
00003c  6485              STR      r5,[r0,#0x48]         ;1762
00003e  6821              LDR      r1,[r4,#0]            ;1762
000040  6a20              LDR      r0,[r4,#0x20]         ;1762
000042  3134              ADDS     r1,r1,#0x34           ;1762
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;1765
00004a  68c1              LDR      r1,[r0,#0xc]          ;1765
00004c  f4417100          ORR      r1,r1,#0x200          ;1765
000050  e00c              B        |L43.108|
                  |L43.82|
000052  6a61              LDR      r1,[r4,#0x24]         ;1772
000054  63c8              STR      r0,[r1,#0x3c]         ;1775
000056  6a60              LDR      r0,[r4,#0x24]         ;1775
000058  6485              STR      r5,[r0,#0x48]         ;1778
00005a  6821              LDR      r1,[r4,#0]            ;1778
00005c  6a60              LDR      r0,[r4,#0x24]         ;1778
00005e  3138              ADDS     r1,r1,#0x38           ;1778
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;1781
000066  68c1              LDR      r1,[r0,#0xc]          ;1781
000068  f4416180          ORR      r1,r1,#0x400          ;1781
                  |L43.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;1765
                  |L43.110|
00006e  2201              MOVS     r2,#1                 ;1822
000070  4631              MOV      r1,r6                 ;1822
000072  6820              LDR      r0,[r4,#0]            ;1822
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  6820              LDR      r0,[r4,#0]            ;1825
00007a  6801              LDR      r1,[r0,#0]            ;1825
00007c  f0410101          ORR      r1,r1,#1              ;1825
000080  6001              STR      r1,[r0,#0]            ;1825
000082  2000              MOVS     r0,#0                 ;1828
000084  bd70              POP      {r4-r6,pc}
                  |L43.134|
000086  6aa1              LDR      r1,[r4,#0x28]         ;1788
000088  63c8              STR      r0,[r1,#0x3c]         ;1791
00008a  6aa0              LDR      r0,[r4,#0x28]         ;1791
00008c  6485              STR      r5,[r0,#0x48]         ;1794
00008e  6821              LDR      r1,[r4,#0]            ;1794
000090  6aa0              LDR      r0,[r4,#0x28]         ;1794
000092  313c              ADDS     r1,r1,#0x3c           ;1794
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  6820              LDR      r0,[r4,#0]            ;1797
00009a  68c1              LDR      r1,[r0,#0xc]          ;1797
00009c  f4416100          ORR      r1,r1,#0x800          ;1797
0000a0  e7e4              B        |L43.108|
                  |L43.162|
0000a2  6ae1              LDR      r1,[r4,#0x2c]         ;1804
0000a4  63c8              STR      r0,[r1,#0x3c]         ;1807
0000a6  6ae0              LDR      r0,[r4,#0x2c]         ;1807
0000a8  6485              STR      r5,[r0,#0x48]         ;1810
0000aa  6821              LDR      r1,[r4,#0]            ;1810
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1810
0000ae  3140              ADDS     r1,r1,#0x40           ;1810
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6820              LDR      r0,[r4,#0]            ;1813
0000b6  68c1              LDR      r1,[r0,#0xc]          ;1813
0000b8  f4415180          ORR      r1,r1,#0x1000         ;1813
0000bc  e7d6              B        |L43.108|
;;;1830   
                          ENDP

0000be  0000              DCW      0x0000
                  |L43.192|
                          DCD      HAL_TIM_DMACaptureCplt
                  |L43.196|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1607     */
;;;1608   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1609   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L44.22|
;;;1610     /* Check the parameters */
;;;1611     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1612     
;;;1613     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L44.30|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L44.60|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L44.38|
000014  e016              B        |L44.68|
                  |L44.22|
;;;1614     {
;;;1615       case TIM_CHANNEL_1:
;;;1616       {       
;;;1617         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1618         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1619       }
;;;1620       break;
00001c  e002              B        |L44.36|
                  |L44.30|
;;;1621       
;;;1622       case TIM_CHANNEL_2:
;;;1623       {
;;;1624         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1625         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L44.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1618
                  |L44.38|
;;;1626       }
;;;1627       break;
;;;1628       
;;;1629       case TIM_CHANNEL_3:
;;;1630       {
;;;1631         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1632         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1633       }
;;;1634       break;
;;;1635       
;;;1636       case TIM_CHANNEL_4:
;;;1637       {
;;;1638         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1639         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1640       }
;;;1641       break;
;;;1642       
;;;1643       default:
;;;1644       break;
;;;1645     }  
;;;1646     /* Enable the Input Capture channel */
;;;1647     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1648       
;;;1649     /* Enable the Peripheral */
;;;1650     __HAL_TIM_ENABLE(htim);  
00002e  6820              LDR      r0,[r4,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f0410101          ORR      r1,r1,#1
000036  6001              STR      r1,[r0,#0]
;;;1651   
;;;1652     /* Return function status */
;;;1653     return HAL_OK;  
000038  2000              MOVS     r0,#0
;;;1654   } 
00003a  bd10              POP      {r4,pc}
                  |L44.60|
00003c  68d0              LDR      r0,[r2,#0xc]          ;1632
00003e  f0400008          ORR      r0,r0,#8              ;1632
000042  e7ef              B        |L44.36|
                  |L44.68|
000044  68d0              LDR      r0,[r2,#0xc]          ;1639
000046  f0400010          ORR      r0,r0,#0x10           ;1639
00004a  e7eb              B        |L44.36|
;;;1655   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1581     */
;;;1582   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1583   { 
000002  4604              MOV      r4,r0
;;;1584     /* Check the parameters */
;;;1585     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1586     
;;;1587     /* Disable the Input Capture channel */
;;;1588     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1589     
;;;1590     /* Disable the Peripheral */
;;;1591     __HAL_TIM_DISABLE(htim); 
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  f2411211          MOV      r2,#0x1111
000014  4211              TST      r1,r2
000016  d107              BNE      |L45.40|
000018  6a01              LDR      r1,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4211              TST      r1,r2
00001e  d103              BNE      |L45.40|
000020  6801              LDR      r1,[r0,#0]
000022  f0210101          BIC      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
                  |L45.40|
;;;1592     
;;;1593     /* Return function status */
;;;1594     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1595   }
00002a  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1841     */
;;;1842   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1843   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L46.22|
;;;1844     /* Check the parameters */
;;;1845     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1846     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1847     
;;;1848     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L46.30|
00000c  2908              CMP      r1,#8
00000e  d021              BEQ      |L46.84|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L46.38|
000014  e022              B        |L46.92|
                  |L46.22|
;;;1849     {
;;;1850       case TIM_CHANNEL_1:
;;;1851       {       
;;;1852         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1853         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1854       }
;;;1855       break;
00001c  e002              B        |L46.36|
                  |L46.30|
;;;1856       
;;;1857       case TIM_CHANNEL_2:
;;;1858       {
;;;1859         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1860         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L46.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1853
                  |L46.38|
;;;1861       }
;;;1862       break;
;;;1863       
;;;1864       case TIM_CHANNEL_3:
;;;1865       {
;;;1866         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1867         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1868       }
;;;1869       break;
;;;1870       
;;;1871       case TIM_CHANNEL_4:
;;;1872       {
;;;1873         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1874         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1875       }
;;;1876       break;
;;;1877       
;;;1878       default:
;;;1879       break;
;;;1880     }
;;;1881   
;;;1882     /* Disable the Input Capture channel */
;;;1883     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1884     
;;;1885     /* Disable the Peripheral */
;;;1886     __HAL_TIM_DISABLE(htim); 
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L46.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L46.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L46.74|
;;;1887     
;;;1888     /* Change the htim state */
;;;1889     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840039          STRB     r0,[r4,#0x39]
;;;1890     
;;;1891     /* Return function status */
;;;1892     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1893   }  
000052  bd10              POP      {r4,pc}
                  |L46.84|
000054  68d0              LDR      r0,[r2,#0xc]          ;1867
000056  f4206000          BIC      r0,r0,#0x800          ;1867
00005a  e7e3              B        |L46.36|
                  |L46.92|
00005c  68d0              LDR      r0,[r2,#0xc]          ;1874
00005e  f4205080          BIC      r0,r0,#0x1000         ;1874
000062  e7df              B        |L46.36|
;;;1894   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1666     */
;;;1667   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1668   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L47.22|
;;;1669     /* Check the parameters */
;;;1670     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1671     
;;;1672     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L47.30|
00000c  2908              CMP      r1,#8
00000e  d01e              BEQ      |L47.78|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L47.38|
000014  e01f              B        |L47.86|
                  |L47.22|
;;;1673     {
;;;1674       case TIM_CHANNEL_1:
;;;1675       {       
;;;1676         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1677         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1678       }
;;;1679       break;
00001c  e002              B        |L47.36|
                  |L47.30|
;;;1680       
;;;1681       case TIM_CHANNEL_2:
;;;1682       {
;;;1683         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1684         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L47.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1677
                  |L47.38|
;;;1685       }
;;;1686       break;
;;;1687       
;;;1688       case TIM_CHANNEL_3:
;;;1689       {
;;;1690         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1691         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1692       }
;;;1693       break;
;;;1694       
;;;1695       case TIM_CHANNEL_4:
;;;1696       {
;;;1697         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1698         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1699       }
;;;1700       break;
;;;1701       
;;;1702       default:
;;;1703       break; 
;;;1704     } 
;;;1705     
;;;1706     /* Disable the Input Capture channel */
;;;1707     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1708     
;;;1709     /* Disable the Peripheral */
;;;1710     __HAL_TIM_DISABLE(htim); 
00002e  6820              LDR      r0,[r4,#0]
000030  6a01              LDR      r1,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4211              TST      r1,r2
000038  d107              BNE      |L47.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L47.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L47.74|
;;;1711     
;;;1712     /* Return function status */
;;;1713     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1714   }
00004c  bd10              POP      {r4,pc}
                  |L47.78|
00004e  68d0              LDR      r0,[r2,#0xc]          ;1691
000050  f0200008          BIC      r0,r0,#8              ;1691
000054  e7e6              B        |L47.36|
                  |L47.86|
000056  68d0              LDR      r0,[r2,#0xc]          ;1698
000058  f0200010          BIC      r0,r0,#0x10           ;1698
00005c  e7e2              B        |L47.36|
;;;1715   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2693     */
;;;2694   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2695   {
000002  4604              MOV      r4,r0
;;;2696     /* Capture compare 1 event */
;;;2697     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  43c9              MVNS     r1,r1
00000e  0789              LSLS     r1,r1,#30
000010  d417              BMI      |L48.66|
;;;2698     {
;;;2699       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC1) !=RESET)
000012  68c1              LDR      r1,[r0,#0xc]
000014  43c9              MVNS     r1,r1
000016  0789              LSLS     r1,r1,#30
000018  d413              BMI      |L48.66|
;;;2700       {
;;;2701         {
;;;2702           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  6901              LDR      r1,[r0,#0x10]
00001c  f0210102          BIC      r1,r1,#2
000020  6101              STR      r1,[r0,#0x10]
;;;2703           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000022  2001              MOVS     r0,#1
000024  7620              STRB     r0,[r4,#0x18]
;;;2704           
;;;2705           /* Input capture event */
;;;2706           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000026  6820              LDR      r0,[r4,#0]
000028  6980              LDR      r0,[r0,#0x18]
00002a  0780              LSLS     r0,r0,#30
;;;2707           {
;;;2708             HAL_TIM_IC_CaptureCallback(htim);
;;;2709           }
;;;2710           /* Output compare event */
;;;2711           else
;;;2712           {
;;;2713             HAL_TIM_OC_DelayElapsedCallback(htim);
00002c  4620              MOV      r0,r4
00002e  d002              BEQ      |L48.54|
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e004              B        |L48.64|
                  |L48.54|
000036  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2714             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L48.64|
;;;2715           }
;;;2716           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  7625              STRB     r5,[r4,#0x18]
                  |L48.66|
;;;2717         }
;;;2718       }
;;;2719     }
;;;2720     /* Capture compare 2 event */
;;;2721     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000042  6820              LDR      r0,[r4,#0]
000044  6901              LDR      r1,[r0,#0x10]
000046  43c9              MVNS     r1,r1
000048  0749              LSLS     r1,r1,#29
00004a  d418              BMI      |L48.126|
;;;2722     {
;;;2723       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC2) !=RESET)
00004c  68c1              LDR      r1,[r0,#0xc]
00004e  43c9              MVNS     r1,r1
000050  0749              LSLS     r1,r1,#29
000052  d414              BMI      |L48.126|
;;;2724       {
;;;2725         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000054  6901              LDR      r1,[r0,#0x10]
000056  f0210104          BIC      r1,r1,#4
00005a  6101              STR      r1,[r0,#0x10]
;;;2726         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00005c  2002              MOVS     r0,#2
00005e  7620              STRB     r0,[r4,#0x18]
;;;2727         /* Input capture event */
;;;2728         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
000060  6820              LDR      r0,[r4,#0]
000062  6980              LDR      r0,[r0,#0x18]
000064  f4107f40          TST      r0,#0x300
;;;2729         {          
;;;2730           HAL_TIM_IC_CaptureCallback(htim);
;;;2731         }
;;;2732         /* Output compare event */
;;;2733         else
;;;2734         {
;;;2735           HAL_TIM_OC_DelayElapsedCallback(htim);
000068  4620              MOV      r0,r4
00006a  d002              BEQ      |L48.114|
00006c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000070  e004              B        |L48.124|
                  |L48.114|
000072  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2736           HAL_TIM_PWM_PulseFinishedCallback(htim);
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L48.124|
;;;2737         }
;;;2738         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00007c  7625              STRB     r5,[r4,#0x18]
                  |L48.126|
;;;2739       }
;;;2740     }
;;;2741     /* Capture compare 3 event */
;;;2742     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007e  6820              LDR      r0,[r4,#0]
000080  6901              LDR      r1,[r0,#0x10]
000082  43c9              MVNS     r1,r1
000084  0709              LSLS     r1,r1,#28
000086  d417              BMI      |L48.184|
;;;2743     {
;;;2744       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC3) !=RESET)
000088  68c1              LDR      r1,[r0,#0xc]
00008a  43c9              MVNS     r1,r1
00008c  0709              LSLS     r1,r1,#28
00008e  d413              BMI      |L48.184|
;;;2745       {
;;;2746         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
000090  6901              LDR      r1,[r0,#0x10]
000092  f0210108          BIC      r1,r1,#8
000096  6101              STR      r1,[r0,#0x10]
;;;2747         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000098  2004              MOVS     r0,#4
00009a  7620              STRB     r0,[r4,#0x18]
;;;2748         /* Input capture event */
;;;2749         if((htim->Instance->CCMR1 & TIM_CCMR2_CC3S) != 0x00)
00009c  6820              LDR      r0,[r4,#0]
00009e  6980              LDR      r0,[r0,#0x18]
0000a0  0780              LSLS     r0,r0,#30
;;;2750         {          
;;;2751           HAL_TIM_IC_CaptureCallback(htim);
;;;2752         }
;;;2753         /* Output compare event */
;;;2754         else
;;;2755         {
;;;2756           HAL_TIM_OC_DelayElapsedCallback(htim);
0000a2  4620              MOV      r0,r4
0000a4  d002              BEQ      |L48.172|
0000a6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000aa  e004              B        |L48.182|
                  |L48.172|
0000ac  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2757           HAL_TIM_PWM_PulseFinishedCallback(htim); 
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L48.182|
;;;2758         }
;;;2759         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b6  7625              STRB     r5,[r4,#0x18]
                  |L48.184|
;;;2760       }
;;;2761     }
;;;2762     /* Capture compare 4 event */
;;;2763     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b8  6820              LDR      r0,[r4,#0]
0000ba  6901              LDR      r1,[r0,#0x10]
0000bc  43c9              MVNS     r1,r1
0000be  06c9              LSLS     r1,r1,#27
0000c0  d418              BMI      |L48.244|
;;;2764     {
;;;2765       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC4) !=RESET)
0000c2  68c1              LDR      r1,[r0,#0xc]
0000c4  43c9              MVNS     r1,r1
0000c6  06c9              LSLS     r1,r1,#27
0000c8  d414              BMI      |L48.244|
;;;2766       {
;;;2767         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000ca  6901              LDR      r1,[r0,#0x10]
0000cc  f0210110          BIC      r1,r1,#0x10
0000d0  6101              STR      r1,[r0,#0x10]
;;;2768         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000d2  2008              MOVS     r0,#8
0000d4  7620              STRB     r0,[r4,#0x18]
;;;2769         /* Input capture event */
;;;2770         if((htim->Instance->CCMR1 & TIM_CCMR2_CC4S) != 0x00)
0000d6  6820              LDR      r0,[r4,#0]
0000d8  6980              LDR      r0,[r0,#0x18]
0000da  f4107f40          TST      r0,#0x300
;;;2771         {          
;;;2772           HAL_TIM_IC_CaptureCallback(htim);
;;;2773         }
;;;2774         /* Output compare event */
;;;2775         else
;;;2776         {
;;;2777           HAL_TIM_OC_DelayElapsedCallback(htim);
0000de  4620              MOV      r0,r4
0000e0  d002              BEQ      |L48.232|
0000e2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e6  e004              B        |L48.242|
                  |L48.232|
0000e8  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2778           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L48.242|
;;;2779         }
;;;2780         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000f2  7625              STRB     r5,[r4,#0x18]
                  |L48.244|
;;;2781       }
;;;2782     }
;;;2783     /* TIM Update event */
;;;2784     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000f4  6820              LDR      r0,[r4,#0]
0000f6  6901              LDR      r1,[r0,#0x10]
0000f8  43c9              MVNS     r1,r1
0000fa  07c9              LSLS     r1,r1,#31
0000fc  d10a              BNE      |L48.276|
;;;2785     {
;;;2786       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_UPDATE) !=RESET)
0000fe  68c1              LDR      r1,[r0,#0xc]
000100  43c9              MVNS     r1,r1
000102  07c9              LSLS     r1,r1,#31
000104  d106              BNE      |L48.276|
;;;2787       {
;;;2788         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000106  6901              LDR      r1,[r0,#0x10]
000108  f0210101          BIC      r1,r1,#1
00010c  6101              STR      r1,[r0,#0x10]
;;;2789         HAL_TIM_PeriodElapsedCallback(htim);
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L48.276|
;;;2790       }
;;;2791     }
;;;2792     /* TIM Break input event */
;;;2793     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000114  6820              LDR      r0,[r4,#0]
000116  6901              LDR      r1,[r0,#0x10]
000118  43c9              MVNS     r1,r1
00011a  0609              LSLS     r1,r1,#24
00011c  d40a              BMI      |L48.308|
;;;2794     {
;;;2795       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_BREAK) !=RESET)
00011e  68c1              LDR      r1,[r0,#0xc]
000120  43c9              MVNS     r1,r1
000122  0609              LSLS     r1,r1,#24
000124  d406              BMI      |L48.308|
;;;2796       {
;;;2797         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000126  6901              LDR      r1,[r0,#0x10]
000128  f0210180          BIC      r1,r1,#0x80
00012c  6101              STR      r1,[r0,#0x10]
;;;2798         HAL_TIMEx_BreakCallback(htim);
00012e  4620              MOV      r0,r4
000130  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L48.308|
;;;2799       }
;;;2800     }
;;;2801     /* TIM Trigger detection event */
;;;2802     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000134  6820              LDR      r0,[r4,#0]
000136  6901              LDR      r1,[r0,#0x10]
000138  43c9              MVNS     r1,r1
00013a  0649              LSLS     r1,r1,#25
00013c  d40a              BMI      |L48.340|
;;;2803     {
;;;2804       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_TRIGGER) !=RESET)
00013e  68c1              LDR      r1,[r0,#0xc]
000140  43c9              MVNS     r1,r1
000142  0649              LSLS     r1,r1,#25
000144  d406              BMI      |L48.340|
;;;2805       {
;;;2806         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000146  6901              LDR      r1,[r0,#0x10]
000148  f0210140          BIC      r1,r1,#0x40
00014c  6101              STR      r1,[r0,#0x10]
;;;2807         HAL_TIM_TriggerCallback(htim);
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L48.340|
;;;2808       }
;;;2809     }
;;;2810     /* TIM commutation event */
;;;2811     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000154  6820              LDR      r0,[r4,#0]
000156  6901              LDR      r1,[r0,#0x10]
000158  43c9              MVNS     r1,r1
00015a  0689              LSLS     r1,r1,#26
00015c  d40c              BMI      |L48.376|
;;;2812     {
;;;2813       if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_COM) !=RESET)
00015e  68c1              LDR      r1,[r0,#0xc]
000160  43c9              MVNS     r1,r1
000162  0689              LSLS     r1,r1,#26
000164  d408              BMI      |L48.376|
;;;2814       {
;;;2815         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
000166  6901              LDR      r1,[r0,#0x10]
000168  f0210120          BIC      r1,r1,#0x20
00016c  6101              STR      r1,[r0,#0x10]
;;;2816         HAL_TIMEx_CommutationCallback(htim);
00016e  4620              MOV      r0,r4
000170  e8bd4070          POP      {r4-r6,lr}
000174  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L48.376|
;;;2817       }
;;;2818     }
;;;2819   }
000178  bd70              POP      {r4-r6,pc}
;;;2820   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2856     */
;;;2857   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2858   {
000002  4604              MOV      r4,r0
;;;2859     /* Check the parameters */ 
;;;2860     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2861     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2862     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2863     assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
;;;2864     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;2865     assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
;;;2866     assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
;;;2867     
;;;2868     /* Check input state */
;;;2869     __HAL_LOCK(htim); 
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d00d              BEQ      |L49.40|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;2870     
;;;2871     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
000018  b142              CBZ      r2,|L49.44|
;;;2872     
;;;2873     switch (Channel)
00001a  2a04              CMP      r2,#4
00001c  d00a              BEQ      |L49.52|
00001e  2a08              CMP      r2,#8
000020  d00c              BEQ      |L49.60|
000022  2a0c              CMP      r2,#0xc
000024  d111              BNE      |L49.74|
000026  e00d              B        |L49.68|
                  |L49.40|
000028  2002              MOVS     r0,#2                 ;2869
;;;2874     {
;;;2875       case TIM_CHANNEL_1:
;;;2876       {
;;;2877         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2878         /* Configure the TIM Channel 1 in Output Compare */
;;;2879         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2880       }
;;;2881       break;
;;;2882       
;;;2883       case TIM_CHANNEL_2:
;;;2884       {
;;;2885         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2886         /* Configure the TIM Channel 2 in Output Compare */
;;;2887         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2888       }
;;;2889       break;
;;;2890       
;;;2891       case TIM_CHANNEL_3:
;;;2892       {
;;;2893          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2894         /* Configure the TIM Channel 3 in Output Compare */
;;;2895         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2896       }
;;;2897       break;
;;;2898       
;;;2899       case TIM_CHANNEL_4:
;;;2900       {
;;;2901         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2902         /* Configure the TIM Channel 4 in Output Compare */
;;;2903         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2904       }
;;;2905       break;
;;;2906       
;;;2907       default:
;;;2908       break;    
;;;2909     }
;;;2910     htim->State = HAL_TIM_STATE_READY;
;;;2911     
;;;2912     __HAL_UNLOCK(htim); 
;;;2913     
;;;2914     return HAL_OK;
;;;2915   }
00002a  bd70              POP      {r4-r6,pc}
                  |L49.44|
00002c  6820              LDR      r0,[r4,#0]            ;2879
00002e  f7fffffe          BL       TIM_OC1_SetConfig
000032  e00a              B        |L49.74|
                  |L49.52|
000034  6820              LDR      r0,[r4,#0]            ;2887
000036  f7fffffe          BL       TIM_OC2_SetConfig
00003a  e006              B        |L49.74|
                  |L49.60|
00003c  6820              LDR      r0,[r4,#0]            ;2895
00003e  f7fffffe          BL       TIM_OC3_SetConfig
000042  e002              B        |L49.74|
                  |L49.68|
000044  6820              LDR      r0,[r4,#0]            ;2903
000046  f7fffffe          BL       TIM_OC4_SetConfig
                  |L49.74|
00004a  f8845039          STRB     r5,[r4,#0x39]         ;2910
00004e  2000              MOVS     r0,#0                 ;2912
000050  f8840038          STRB     r0,[r4,#0x38]         ;2912
000054  bd70              POP      {r4-r6,pc}
;;;2916   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;501      */
;;;502    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;503    {
000002  4604              MOV      r4,r0
;;;504      /* Check the parameters */
;;;505      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;506      
;;;507       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;508       
;;;509      /* Disable the TIM Peripheral Clock */
;;;510      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L50.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L50.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L50.38|
;;;511      
;;;512      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;513      HAL_TIM_OC_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;514        
;;;515      /* Change TIM state */  
;;;516      htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;517    
;;;518      /* Release Lock */
;;;519      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;520    
;;;521      return HAL_OK;
;;;522    }
000036  bd10              POP      {r4,pc}
;;;523    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4162     */
;;;4163   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4164   {
;;;4165     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4166               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4167      */
;;;4168   }
;;;4169   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4250     */
;;;4251   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4252   {
;;;4253     return htim->State;
;;;4254   }
000004  4770              BX       lr
;;;4255   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;465      */
;;;466    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;467    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L53.14|
;;;468      /* Check the TIM handle allocation */
;;;469      if(htim == NULL)
;;;470      {
;;;471        return HAL_ERROR;
;;;472      }
;;;473    
;;;474      /* Check the parameters */
;;;475      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;476      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;477      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;478     
;;;479      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L53.18|
00000c  e004              B        |L53.24|
                  |L53.14|
00000e  2001              MOVS     r0,#1                 ;471
;;;480      {   
;;;481        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;482        HAL_TIM_OC_MspInit(htim);
;;;483      }
;;;484      
;;;485      /* Set the TIM state */
;;;486      htim->State= HAL_TIM_STATE_BUSY;
;;;487      
;;;488      /* Init the base time for the Output Compare */  
;;;489      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;490      
;;;491      /* Initialize the TIM state*/
;;;492      htim->State= HAL_TIM_STATE_READY;
;;;493      
;;;494      return HAL_OK;
;;;495    }
000010  bd10              POP      {r4,pc}
                  |L53.18|
000012  4620              MOV      r0,r4                 ;482
000014  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L53.24|
000018  2002              MOVS     r0,#2                 ;486
00001a  f8840039          STRB     r0,[r4,#0x39]         ;486
00001e  1d21              ADDS     r1,r4,#4              ;489
000020  6820              LDR      r0,[r4,#0]            ;489
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;492
000028  f8840039          STRB     r0,[r4,#0x39]         ;492
00002c  2000              MOVS     r0,#0                 ;494
00002e  bd10              POP      {r4,pc}
;;;496    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;540      */
;;;541    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;542    {
;;;543      /* NOTE : This function Should not be modified, when the callback is needed,
;;;544                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;545       */
;;;546    }
;;;547    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;528      */
;;;529    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;530    {
;;;531      /* NOTE : This function Should not be modified, when the callback is needed,
;;;532                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;533       */
;;;534    }
;;;535    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;558      */
;;;559    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;560    {
000002  4604              MOV      r4,r0
;;;561      /* Check the parameters */
;;;562      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;563      
;;;564      /* Enable the Output compare channel */
;;;565      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;566      
;;;567      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4908              LDR      r1,|L56.48|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d002              BEQ      |L56.26|
000014  4907              LDR      r1,|L56.52|
000016  4288              CMP      r0,r1
000018  d103              BNE      |L56.34|
                  |L56.26|
;;;568      {
;;;569        /* Enable the main output */
;;;570        __HAL_TIM_MOE_ENABLE(htim);
00001a  6c41              LDR      r1,[r0,#0x44]
00001c  f4414100          ORR      r1,r1,#0x8000
000020  6441              STR      r1,[r0,#0x44]
                  |L56.34|
;;;571      }
;;;572      
;;;573      /* Enable the Peripheral */
;;;574      __HAL_TIM_ENABLE(htim); 
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
;;;575      
;;;576      /* Return function status */
;;;577      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;578    }
00002e  bd10              POP      {r4,pc}
;;;579    
                          ENDP

                  |L56.48|
                          DCD      0x40010000
                  |L56.52|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;756      */
;;;757    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;758    {
000002  4604              MOV      r4,r0
;;;759      /* Check the parameters */
;;;760      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;761      
;;;762      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;758
00000a  460d              MOV      r5,r1                 ;758
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L57.28|
;;;763      {
;;;764         return HAL_BUSY;
;;;765      }
;;;766      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L57.36|
;;;767      {
;;;768        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000018  b90e              CBNZ     r6,|L57.30|
00001a  b103              CBZ      r3,|L57.30|
                  |L57.28|
;;;769        {
;;;770          return HAL_ERROR;                                    
;;;771        }
;;;772        else
;;;773        {
;;;774          htim->State = HAL_TIM_STATE_BUSY;
;;;775        }
;;;776      }    
;;;777      switch (Channel)
;;;778      {
;;;779        case TIM_CHANNEL_1:
;;;780        {      
;;;781          /* Set the DMA Period elapsed callback */
;;;782          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;783         
;;;784          /* Set the DMA error callback */
;;;785          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;786          
;;;787          /* Enable the DMA Stream */
;;;788          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;789          
;;;790          /* Enable the TIM Capture/Compare 1 DMA request */
;;;791          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;792        }
;;;793        break;
;;;794        
;;;795        case TIM_CHANNEL_2:
;;;796        {
;;;797          /* Set the DMA Period elapsed callback */
;;;798          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;799         
;;;800          /* Set the DMA error callback */
;;;801          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;802          
;;;803          /* Enable the DMA Stream */
;;;804          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;805          
;;;806          /* Enable the TIM Capture/Compare 2 DMA request */
;;;807          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;808        }
;;;809        break;
;;;810        
;;;811        case TIM_CHANNEL_3:
;;;812        {
;;;813          /* Set the DMA Period elapsed callback */
;;;814          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;815         
;;;816          /* Set the DMA error callback */
;;;817          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;818          
;;;819          /* Enable the DMA Stream */
;;;820          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;821          
;;;822          /* Enable the TIM Capture/Compare 3 DMA request */
;;;823          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;824        }
;;;825        break;
;;;826        
;;;827        case TIM_CHANNEL_4:
;;;828        {
;;;829         /* Set the DMA Period elapsed callback */
;;;830          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;831         
;;;832          /* Set the DMA error callback */
;;;833          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;834          
;;;835          /* Enable the DMA Stream */
;;;836          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;837          
;;;838          /* Enable the TIM Capture/Compare 4 DMA request */
;;;839          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;840        }
;;;841        break;
;;;842        
;;;843        default:
;;;844        break;
;;;845      }
;;;846    
;;;847      /* Enable the Output compare channel */
;;;848      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;849      
;;;850      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;851      {
;;;852        /* Enable the main output */
;;;853        __HAL_TIM_MOE_ENABLE(htim);
;;;854      }  
;;;855      
;;;856      /* Enable the Peripheral */
;;;857      __HAL_TIM_ENABLE(htim); 
;;;858      
;;;859      /* Return function status */
;;;860      return HAL_OK;
;;;861    }
00001c  bd70              POP      {r4-r6,pc}
                  |L57.30|
00001e  2002              MOVS     r0,#2                 ;774
000020  f8840039          STRB     r0,[r4,#0x39]         ;774
                  |L57.36|
000024  482e              LDR      r0,|L57.224|
000026  492f              LDR      r1,|L57.228|
000028  b135              CBZ      r5,|L57.56|
00002a  2d04              CMP      r5,#4                 ;777
00002c  d013              BEQ      |L57.86|
00002e  2d08              CMP      r5,#8                 ;777
000030  d037              BEQ      |L57.162|
000032  2d0c              CMP      r5,#0xc               ;777
000034  d11e              BNE      |L57.116|
000036  e043              B        |L57.192|
                  |L57.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;782
00003a  63d0              STR      r0,[r2,#0x3c]         ;785
00003c  6a20              LDR      r0,[r4,#0x20]         ;785
00003e  6481              STR      r1,[r0,#0x48]         ;788
000040  6822              LDR      r2,[r4,#0]            ;788
000042  4631              MOV      r1,r6                 ;788
000044  3234              ADDS     r2,r2,#0x34           ;788
000046  6a20              LDR      r0,[r4,#0x20]         ;788
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;791
00004e  68c1              LDR      r1,[r0,#0xc]          ;791
000050  f4417100          ORR      r1,r1,#0x200          ;791
000054  e00d              B        |L57.114|
                  |L57.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;798
000058  63d0              STR      r0,[r2,#0x3c]         ;801
00005a  6a60              LDR      r0,[r4,#0x24]         ;801
00005c  6481              STR      r1,[r0,#0x48]         ;804
00005e  6822              LDR      r2,[r4,#0]            ;804
000060  4631              MOV      r1,r6                 ;804
000062  3238              ADDS     r2,r2,#0x38           ;804
000064  6a60              LDR      r0,[r4,#0x24]         ;804
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;807
00006c  68c1              LDR      r1,[r0,#0xc]          ;807
00006e  f4416180          ORR      r1,r1,#0x400          ;807
                  |L57.114|
000072  60c1              STR      r1,[r0,#0xc]          ;791
                  |L57.116|
000074  2201              MOVS     r2,#1                 ;848
000076  4629              MOV      r1,r5                 ;848
000078  6820              LDR      r0,[r4,#0]            ;848
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  491a              LDR      r1,|L57.232|
000080  6820              LDR      r0,[r4,#0]            ;850
000082  4288              CMP      r0,r1                 ;850
000084  d002              BEQ      |L57.140|
000086  4919              LDR      r1,|L57.236|
000088  4288              CMP      r0,r1                 ;850
00008a  d103              BNE      |L57.148|
                  |L57.140|
00008c  6c41              LDR      r1,[r0,#0x44]         ;853
00008e  f4414100          ORR      r1,r1,#0x8000         ;853
000092  6441              STR      r1,[r0,#0x44]         ;853
                  |L57.148|
000094  6820              LDR      r0,[r4,#0]            ;857
000096  6801              LDR      r1,[r0,#0]            ;857
000098  f0410101          ORR      r1,r1,#1              ;857
00009c  6001              STR      r1,[r0,#0]            ;857
00009e  2000              MOVS     r0,#0                 ;860
0000a0  bd70              POP      {r4-r6,pc}
                  |L57.162|
0000a2  6aa2              LDR      r2,[r4,#0x28]         ;814
0000a4  63d0              STR      r0,[r2,#0x3c]         ;817
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;817
0000a8  6481              STR      r1,[r0,#0x48]         ;820
0000aa  6822              LDR      r2,[r4,#0]            ;820
0000ac  4631              MOV      r1,r6                 ;820
0000ae  323c              ADDS     r2,r2,#0x3c           ;820
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;820
0000b2  f7fffffe          BL       HAL_DMA_Start_IT
0000b6  6820              LDR      r0,[r4,#0]            ;823
0000b8  68c1              LDR      r1,[r0,#0xc]          ;823
0000ba  f4416100          ORR      r1,r1,#0x800          ;823
0000be  e7d8              B        |L57.114|
                  |L57.192|
0000c0  6ae2              LDR      r2,[r4,#0x2c]         ;830
0000c2  63d0              STR      r0,[r2,#0x3c]         ;833
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;833
0000c6  6481              STR      r1,[r0,#0x48]         ;836
0000c8  6822              LDR      r2,[r4,#0]            ;836
0000ca  4631              MOV      r1,r6                 ;836
0000cc  3240              ADDS     r2,r2,#0x40           ;836
0000ce  6ae0              LDR      r0,[r4,#0x2c]         ;836
0000d0  f7fffffe          BL       HAL_DMA_Start_IT
0000d4  6820              LDR      r0,[r4,#0]            ;839
0000d6  68c1              LDR      r1,[r0,#0xc]          ;839
0000d8  f4415180          ORR      r1,r1,#0x1000         ;839
0000dc  e7c9              B        |L57.114|
;;;862    
                          ENDP

0000de  0000              DCW      0x0000
                  |L57.224|
                          DCD      HAL_TIM_DMADelayPulseCplt
                  |L57.228|
                          DCD      HAL_TIM_DMAError
                  |L57.232|
                          DCD      0x40010000
                  |L57.236|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;622      */
;;;623    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;624    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L58.22|
;;;625      /* Check the parameters */
;;;626      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;627      
;;;628      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L58.30|
00000c  2908              CMP      r1,#8
00000e  d020              BEQ      |L58.82|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L58.38|
000014  e021              B        |L58.90|
                  |L58.22|
;;;629      {
;;;630        case TIM_CHANNEL_1:
;;;631        {       
;;;632          /* Enable the TIM Capture/Compare 1 interrupt */
;;;633          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;634        }
;;;635        break;
00001c  e002              B        |L58.36|
                  |L58.30|
;;;636        
;;;637        case TIM_CHANNEL_2:
;;;638        {
;;;639          /* Enable the TIM Capture/Compare 2 interrupt */
;;;640          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L58.36|
000024  60d0              STR      r0,[r2,#0xc]          ;633
                  |L58.38|
;;;641        }
;;;642        break;
;;;643        
;;;644        case TIM_CHANNEL_3:
;;;645        {
;;;646          /* Enable the TIM Capture/Compare 3 interrupt */
;;;647          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;648        }
;;;649        break;
;;;650        
;;;651        case TIM_CHANNEL_4:
;;;652        {
;;;653          /* Enable the TIM Capture/Compare 4 interrupt */
;;;654          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;655        }
;;;656        break;
;;;657        
;;;658        default:
;;;659        break;
;;;660      } 
;;;661    
;;;662      /* Enable the Output compare channel */
;;;663      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;664      
;;;665      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  490d              LDR      r1,|L58.100|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d002              BEQ      |L58.60|
000036  490c              LDR      r1,|L58.104|
000038  4288              CMP      r0,r1
00003a  d103              BNE      |L58.68|
                  |L58.60|
;;;666      {
;;;667        /* Enable the main output */
;;;668        __HAL_TIM_MOE_ENABLE(htim);
00003c  6c41              LDR      r1,[r0,#0x44]
00003e  f4414100          ORR      r1,r1,#0x8000
000042  6441              STR      r1,[r0,#0x44]
                  |L58.68|
;;;669      }
;;;670    
;;;671      /* Enable the Peripheral */
;;;672      __HAL_TIM_ENABLE(htim);
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  f0410101          ORR      r1,r1,#1
00004c  6001              STR      r1,[r0,#0]
;;;673      
;;;674      /* Return function status */
;;;675      return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;676    }
000050  bd10              POP      {r4,pc}
                  |L58.82|
000052  68d0              LDR      r0,[r2,#0xc]          ;647
000054  f0400008          ORR      r0,r0,#8              ;647
000058  e7e4              B        |L58.36|
                  |L58.90|
00005a  68d0              LDR      r0,[r2,#0xc]          ;654
00005c  f0400010          ORR      r0,r0,#0x10           ;654
000060  e7e0              B        |L58.36|
;;;677    
                          ENDP

000062  0000              DCW      0x0000
                  |L58.100|
                          DCD      0x40010000
                  |L58.104|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;590      */
;;;591    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;592    {
000002  4604              MOV      r4,r0
;;;593      /* Check the parameters */
;;;594      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;595      
;;;596      /* Disable the Output compare channel */
;;;597      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;598      
;;;599      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4810              LDR      r0,|L59.80|
;;;600      {
;;;601        /* Disable the Main Ouput */
;;;602        __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;599
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;599
000018  d002              BEQ      |L59.32|
00001a  480e              LDR      r0,|L59.84|
00001c  4281              CMP      r1,r0                 ;599
00001e  d109              BNE      |L59.52|
                  |L59.32|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4210              TST      r0,r2
000024  d106              BNE      |L59.52|
000026  6a08              LDR      r0,[r1,#0x20]
000028  4218              TST      r0,r3
00002a  d103              BNE      |L59.52|
00002c  6c48              LDR      r0,[r1,#0x44]
00002e  f4204000          BIC      r0,r0,#0x8000
000032  6448              STR      r0,[r1,#0x44]
                  |L59.52|
;;;603      }  
;;;604      
;;;605      /* Disable the Peripheral */
;;;606      __HAL_TIM_DISABLE(htim);  
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L59.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L59.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L59.74|
;;;607      
;;;608      /* Return function status */
;;;609      return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;610    }  
00004c  bd10              POP      {r4,pc}
;;;611    
                          ENDP

00004e  0000              DCW      0x0000
                  |L59.80|
                          DCD      0x40010000
                  |L59.84|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;873      */
;;;874    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;875    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L60.22|
;;;876      /* Check the parameters */
;;;877      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;878      
;;;879      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L60.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L60.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L60.38|
000014  e033              B        |L60.126|
                  |L60.22|
;;;880      {
;;;881        case TIM_CHANNEL_1:
;;;882        {       
;;;883          /* Disable the TIM Capture/Compare 1 DMA request */
;;;884          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;885        }
;;;886        break;
00001c  e002              B        |L60.36|
                  |L60.30|
;;;887        
;;;888        case TIM_CHANNEL_2:
;;;889        {
;;;890          /* Disable the TIM Capture/Compare 2 DMA request */
;;;891          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L60.36|
000024  60d0              STR      r0,[r2,#0xc]          ;884
                  |L60.38|
;;;892        }
;;;893        break;
;;;894        
;;;895        case TIM_CHANNEL_3:
;;;896        {
;;;897          /* Disable the TIM Capture/Compare 3 DMA request */
;;;898          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;899        }
;;;900        break;
;;;901        
;;;902        case TIM_CHANNEL_4:
;;;903        {
;;;904          /* Disable the TIM Capture/Compare 4 interrupt */
;;;905          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;906        }
;;;907        break;
;;;908        
;;;909        default:
;;;910        break;
;;;911      } 
;;;912      
;;;913      /* Disable the Output compare channel */
;;;914      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;915      
;;;916      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  4b16              LDR      r3,|L60.136|
;;;917      {
;;;918        /* Disable the Main Ouput */
;;;919        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;916
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;916
00003a  d002              BEQ      |L60.66|
00003c  4b13              LDR      r3,|L60.140|
00003e  4298              CMP      r0,r3                 ;916
000040  d109              BNE      |L60.86|
                  |L60.66|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d106              BNE      |L60.86|
000048  6a03              LDR      r3,[r0,#0x20]
00004a  420b              TST      r3,r1
00004c  d103              BNE      |L60.86|
00004e  6c43              LDR      r3,[r0,#0x44]
000050  f4234300          BIC      r3,r3,#0x8000
000054  6443              STR      r3,[r0,#0x44]
                  |L60.86|
;;;920      }
;;;921      
;;;922      /* Disable the Peripheral */
;;;923      __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a03              LDR      r3,[r0,#0x20]
00005a  4213              TST      r3,r2
00005c  d106              BNE      |L60.108|
00005e  6a02              LDR      r2,[r0,#0x20]
000060  420a              TST      r2,r1
000062  d103              BNE      |L60.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L60.108|
;;;924      
;;;925      /* Change the htim state */
;;;926      htim->State = HAL_TIM_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  f8840039          STRB     r0,[r4,#0x39]
;;;927      
;;;928      /* Return function status */
;;;929      return HAL_OK;
000072  2000              MOVS     r0,#0
;;;930    }
000074  bd10              POP      {r4,pc}
                  |L60.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;898
000078  f4206000          BIC      r0,r0,#0x800          ;898
00007c  e7d2              B        |L60.36|
                  |L60.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;905
000080  f4205080          BIC      r0,r0,#0x1000         ;905
000084  e7ce              B        |L60.36|
;;;931    
                          ENDP

000086  0000              DCW      0x0000
                  |L60.136|
                          DCD      0x40010000
                  |L60.140|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;688      */
;;;689    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;690    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L61.22|
;;;691      /* Check the parameters */
;;;692      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;693      
;;;694      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L61.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L61.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L61.38|
000014  e030              B        |L61.120|
                  |L61.22|
;;;695      {
;;;696        case TIM_CHANNEL_1:
;;;697        {       
;;;698          /* Disable the TIM Capture/Compare 1 interrupt */
;;;699          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;700        }
;;;701        break;
00001c  e002              B        |L61.36|
                  |L61.30|
;;;702        
;;;703        case TIM_CHANNEL_2:
;;;704        {
;;;705          /* Disable the TIM Capture/Compare 2 interrupt */
;;;706          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L61.36|
000024  60d0              STR      r0,[r2,#0xc]          ;699
                  |L61.38|
;;;707        }
;;;708        break;
;;;709        
;;;710        case TIM_CHANNEL_3:
;;;711        {
;;;712          /* Disable the TIM Capture/Compare 3 interrupt */
;;;713          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;714        }
;;;715        break;
;;;716        
;;;717        case TIM_CHANNEL_4:
;;;718        {
;;;719          /* Disable the TIM Capture/Compare 4 interrupt */
;;;720          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;721        }
;;;722        break;
;;;723        
;;;724        default:
;;;725        break; 
;;;726      } 
;;;727      
;;;728      /* Disable the Output compare channel */
;;;729      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;730      
;;;731      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  4814              LDR      r0,|L61.128|
;;;732      {
;;;733        /* Disable the Main Ouput */
;;;734        __HAL_TIM_MOE_DISABLE(htim);
000030  f2411311          MOV      r3,#0x1111
000034  6821              LDR      r1,[r4,#0]            ;731
000036  109a              ASRS     r2,r3,#2
000038  4281              CMP      r1,r0                 ;731
00003a  d002              BEQ      |L61.66|
00003c  4811              LDR      r0,|L61.132|
00003e  4281              CMP      r1,r0                 ;731
000040  d109              BNE      |L61.86|
                  |L61.66|
000042  6a08              LDR      r0,[r1,#0x20]
000044  4218              TST      r0,r3
000046  d106              BNE      |L61.86|
000048  6a08              LDR      r0,[r1,#0x20]
00004a  4210              TST      r0,r2
00004c  d103              BNE      |L61.86|
00004e  6c48              LDR      r0,[r1,#0x44]
000050  f4204000          BIC      r0,r0,#0x8000
000054  6448              STR      r0,[r1,#0x44]
                  |L61.86|
;;;735      }
;;;736      
;;;737      /* Disable the Peripheral */
;;;738      __HAL_TIM_DISABLE(htim);  
000056  6820              LDR      r0,[r4,#0]
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4219              TST      r1,r3
00005c  d106              BNE      |L61.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L61.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L61.108|
;;;739      
;;;740      /* Return function status */
;;;741      return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;742    }
00006e  bd10              POP      {r4,pc}
                  |L61.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;713
000072  f0200008          BIC      r0,r0,#8              ;713
000076  e7d5              B        |L61.36|
                  |L61.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;720
00007a  f0200010          BIC      r0,r0,#0x10           ;720
00007e  e7d1              B        |L61.36|
;;;743    
                          ENDP

                  |L61.128|
                          DCD      0x40010000
                  |L61.132|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3127     */
;;;3128   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3129   {
000002  461e              MOV      r6,r3
000004  b087              SUB      sp,sp,#0x1c
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;3130     TIM_OC_InitTypeDef temp1;
;;;3131     
;;;3132     /* Check the parameters */
;;;3133     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3134     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3135   
;;;3136     if(OutputChannel != InputChannel)  
00000a  42b2              CMP      r2,r6
00000c  d063              BEQ      |L62.214|
;;;3137     {
;;;3138       __HAL_LOCK(htim);
00000e  f8940038          LDRB     r0,[r4,#0x38]
000012  2801              CMP      r0,#1
000014  d015              BEQ      |L62.66|
000016  2701              MOVS     r7,#1
000018  f8847038          STRB     r7,[r4,#0x38]
;;;3139     
;;;3140       htim->State = HAL_TIM_STATE_BUSY;
00001c  2002              MOVS     r0,#2
00001e  f8840039          STRB     r0,[r4,#0x39]
;;;3141   
;;;3142       /* Extract the Ouput compare configuration from sConfig structure */  
;;;3143       temp1.OCMode = sConfig->OCMode;
000022  6828              LDR      r0,[r5,#0]
;;;3144       temp1.Pulse = sConfig->Pulse;
000024  9000              STR      r0,[sp,#0]
000026  6868              LDR      r0,[r5,#4]
;;;3145       temp1.OCPolarity = sConfig->OCPolarity;
000028  9001              STR      r0,[sp,#4]
00002a  68a8              LDR      r0,[r5,#8]
;;;3146       temp1.OCNPolarity = sConfig->OCNPolarity;
00002c  9002              STR      r0,[sp,#8]
00002e  68e8              LDR      r0,[r5,#0xc]
;;;3147       temp1.OCIdleState = sConfig->OCIdleState;
000030  9003              STR      r0,[sp,#0xc]
000032  6928              LDR      r0,[r5,#0x10]
;;;3148       temp1.OCNIdleState = sConfig->OCNIdleState; 
000034  9005              STR      r0,[sp,#0x14]
000036  6968              LDR      r0,[r5,#0x14]
000038  9006              STR      r0,[sp,#0x18]         ;3138
00003a  b12a              CBZ      r2,|L62.72|
;;;3149       
;;;3150       switch (OutputChannel)
00003c  2a04              CMP      r2,#4
00003e  d10c              BNE      |L62.90|
000040  e007              B        |L62.82|
                  |L62.66|
000042  2002              MOVS     r0,#2                 ;3138
                  |L62.68|
;;;3151       {
;;;3152         case TIM_CHANNEL_1:
;;;3153         {
;;;3154           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3155         
;;;3156           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3157         }
;;;3158         break;
;;;3159         case TIM_CHANNEL_2:
;;;3160         {
;;;3161           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3162         
;;;3163           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3164         }
;;;3165         break;
;;;3166         default:
;;;3167         break;  
;;;3168       } 
;;;3169       switch (InputChannel)
;;;3170       {
;;;3171         case TIM_CHANNEL_1:
;;;3172         {
;;;3173           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3174         
;;;3175           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3176                           sConfig->ICSelection, sConfig->ICFilter);
;;;3177                  
;;;3178           /* Reset the IC1PSC Bits */
;;;3179           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3180   
;;;3181           /* Select the Trigger source */
;;;3182           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3183           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3184         
;;;3185           /* Select the Slave Mode */      
;;;3186           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3187           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3188         }
;;;3189         break;
;;;3190         case TIM_CHANNEL_2:
;;;3191         {
;;;3192           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3193         
;;;3194           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3195                    sConfig->ICSelection, sConfig->ICFilter);
;;;3196                  
;;;3197           /* Reset the IC2PSC Bits */
;;;3198           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3199   
;;;3200           /* Select the Trigger source */
;;;3201           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3202           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3203         
;;;3204           /* Select the Slave Mode */      
;;;3205           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3206           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3207         }
;;;3208         break;
;;;3209       
;;;3210         default:
;;;3211         break;  
;;;3212       }
;;;3213     
;;;3214       htim->State = HAL_TIM_STATE_READY;
;;;3215       
;;;3216       __HAL_UNLOCK(htim);
;;;3217     
;;;3218       return HAL_OK;
;;;3219     }
;;;3220     else
;;;3221     {
;;;3222       return HAL_ERROR;
;;;3223     }
;;;3224   } 
000044  b007              ADD      sp,sp,#0x1c
000046  bdf0              POP      {r4-r7,pc}
                  |L62.72|
000048  4669              MOV      r1,sp                 ;3156
00004a  6820              LDR      r0,[r4,#0]            ;3156
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e003              B        |L62.90|
                  |L62.82|
000052  4669              MOV      r1,sp                 ;3163
000054  6820              LDR      r0,[r4,#0]            ;3163
000056  f7fffffe          BL       TIM_OC2_SetConfig
                  |L62.90|
00005a  b116              CBZ      r6,|L62.98|
00005c  2e04              CMP      r6,#4                 ;3169
00005e  d134              BNE      |L62.202|
000060  e014              B        |L62.140|
                  |L62.98|
000062  3518              ADDS     r5,r5,#0x18           ;3169
000064  6820              LDR      r0,[r4,#0]            ;3175
000066  e895000e          LDM      r5,{r1-r3}            ;3169
00006a  f7fffffe          BL       TIM_TI1_SetConfig
00006e  6820              LDR      r0,[r4,#0]            ;3179
000070  6981              LDR      r1,[r0,#0x18]         ;3179
000072  f021010c          BIC      r1,r1,#0xc            ;3179
000076  6181              STR      r1,[r0,#0x18]         ;3179
000078  6820              LDR      r0,[r4,#0]            ;3182
00007a  6881              LDR      r1,[r0,#8]            ;3182
00007c  f0210170          BIC      r1,r1,#0x70           ;3182
000080  6081              STR      r1,[r0,#8]            ;3182
000082  6820              LDR      r0,[r4,#0]            ;3183
000084  6881              LDR      r1,[r0,#8]            ;3183
000086  f0410150          ORR      r1,r1,#0x50           ;3183
00008a  e013              B        |L62.180|
                  |L62.140|
00008c  3518              ADDS     r5,r5,#0x18           ;3189
00008e  6820              LDR      r0,[r4,#0]            ;3194
000090  e895000e          LDM      r5,{r1-r3}            ;3189
000094  f7fffffe          BL       TIM_TI2_SetConfig
000098  6820              LDR      r0,[r4,#0]            ;3198
00009a  6981              LDR      r1,[r0,#0x18]         ;3198
00009c  f4216140          BIC      r1,r1,#0xc00          ;3198
0000a0  6181              STR      r1,[r0,#0x18]         ;3198
0000a2  6820              LDR      r0,[r4,#0]            ;3201
0000a4  6881              LDR      r1,[r0,#8]            ;3201
0000a6  f0210170          BIC      r1,r1,#0x70           ;3201
0000aa  6081              STR      r1,[r0,#8]            ;3201
0000ac  6820              LDR      r0,[r4,#0]            ;3202
0000ae  6881              LDR      r1,[r0,#8]            ;3202
0000b0  f0410160          ORR      r1,r1,#0x60           ;3202
                  |L62.180|
0000b4  6081              STR      r1,[r0,#8]            ;3183
0000b6  6820              LDR      r0,[r4,#0]            ;3186
0000b8  6881              LDR      r1,[r0,#8]            ;3186
0000ba  f0210107          BIC      r1,r1,#7              ;3186
0000be  6081              STR      r1,[r0,#8]            ;3186
0000c0  6820              LDR      r0,[r4,#0]            ;3187
0000c2  6881              LDR      r1,[r0,#8]            ;3187
0000c4  f0410106          ORR      r1,r1,#6              ;3187
0000c8  6081              STR      r1,[r0,#8]            ;3187
                  |L62.202|
0000ca  f8847039          STRB     r7,[r4,#0x39]         ;3214
0000ce  2000              MOVS     r0,#0                 ;3216
0000d0  f8840038          STRB     r0,[r4,#0x38]         ;3216
0000d4  e7b6              B        |L62.68|
                  |L62.214|
0000d6  2001              MOVS     r0,#1                 ;3222
0000d8  e7b4              B        |L62.68|
;;;3225   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;1971     */
;;;1972   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1973   {
000002  4604              MOV      r4,r0
;;;1974     /* Check the parameters */
;;;1975     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1976     
;;;1977     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1978     
;;;1979     /* Disable the TIM Peripheral Clock */
;;;1980     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L63.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L63.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L63.38|
;;;1981     
;;;1982     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;1983     HAL_TIM_OnePulse_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;1984       
;;;1985     /* Change TIM state */  
;;;1986     htim->State = HAL_TIM_STATE_RESET;
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;1987   
;;;1988     /* Release Lock */
;;;1989     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;1990   
;;;1991     return HAL_OK;
;;;1992   }
000036  bd10              POP      {r4,pc}
;;;1993   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4280     */
;;;4281   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4282   {
;;;4283     return htim->State;
;;;4284   }
000004  4770              BX       lr
;;;4285   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1928     */
;;;1929   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1930   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d003              BEQ      |L65.16|
;;;1931     /* Check the TIM handle allocation */
;;;1932     if(htim == NULL)
;;;1933     {
;;;1934       return HAL_ERROR;
;;;1935     }
;;;1936   
;;;1937     /* Check the parameters */
;;;1938     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1939     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1940     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1941     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1942     
;;;1943     if(htim->State == HAL_TIM_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  b110              CBZ      r0,|L65.20|
00000e  e004              B        |L65.26|
                  |L65.16|
000010  2001              MOVS     r0,#1                 ;1934
;;;1944     {   
;;;1945       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1946       HAL_TIM_OnePulse_MspInit(htim);
;;;1947     }
;;;1948     
;;;1949     /* Set the TIM state */
;;;1950     htim->State= HAL_TIM_STATE_BUSY;  
;;;1951     
;;;1952     /* Configure the Time base in the One Pulse Mode */
;;;1953     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1954     
;;;1955     /* Reset the OPM Bit */
;;;1956     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;1957   
;;;1958     /* Configure the OPM Mode */
;;;1959     htim->Instance->CR1 |= OnePulseMode;
;;;1960      
;;;1961     /* Initialize the TIM state*/
;;;1962     htim->State= HAL_TIM_STATE_READY;
;;;1963     
;;;1964     return HAL_OK;
;;;1965   }
000012  bd70              POP      {r4-r6,pc}
                  |L65.20|
000014  4620              MOV      r0,r4                 ;1946
000016  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L65.26|
00001a  2002              MOVS     r0,#2                 ;1950
00001c  f8840039          STRB     r0,[r4,#0x39]         ;1950
000020  1d21              ADDS     r1,r4,#4              ;1953
000022  6820              LDR      r0,[r4,#0]            ;1953
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;1956
00002a  6801              LDR      r1,[r0,#0]            ;1956
00002c  f0210108          BIC      r1,r1,#8              ;1956
000030  6001              STR      r1,[r0,#0]            ;1956
000032  6820              LDR      r0,[r4,#0]            ;1959
000034  6801              LDR      r1,[r0,#0]            ;1959
000036  4329              ORRS     r1,r1,r5              ;1959
000038  6001              STR      r1,[r0,#0]            ;1959
00003a  2001              MOVS     r0,#1                 ;1962
00003c  f8840039          STRB     r0,[r4,#0x39]         ;1962
000040  2000              MOVS     r0,#0                 ;1964
000042  bd70              POP      {r4-r6,pc}
;;;1966   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2010     */
;;;2011   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2012   {
;;;2013     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2014               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2015      */
;;;2016   }
;;;2017   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;1998     */
;;;1999   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2000   {
;;;2001     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2002               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2003      */
;;;2004   }
;;;2005   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2026     */
;;;2027   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2028   {
000002  4604              MOV      r4,r0
;;;2029     /* Enable the Capture compare and the Input Capture channels 
;;;2030       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2031       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2032       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2033       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2034       
;;;2035       No need to enable the counter, it's enabled automatically by hardware 
;;;2036       (the counter starts in response to a stimulus and generate a pulse */
;;;2037     
;;;2038     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2039     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
00000e  2201              MOVS     r2,#1
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2040     
;;;2041     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000018  4906              LDR      r1,|L68.52|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d002              BEQ      |L68.38|
000020  4905              LDR      r1,|L68.56|
000022  4288              CMP      r0,r1
000024  d103              BNE      |L68.46|
                  |L68.38|
;;;2042     {
;;;2043       /* Enable the main output */
;;;2044       __HAL_TIM_MOE_ENABLE(htim);
000026  6c41              LDR      r1,[r0,#0x44]
000028  f4414100          ORR      r1,r1,#0x8000
00002c  6441              STR      r1,[r0,#0x44]
                  |L68.46|
;;;2045     }
;;;2046     
;;;2047     /* Return function status */
;;;2048     return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;2049   }
000030  bd10              POP      {r4,pc}
;;;2050   
                          ENDP

000032  0000              DCW      0x0000
                  |L68.52|
                          DCD      0x40010000
                  |L68.56|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2092     */
;;;2093   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2094   {
000002  4604              MOV      r4,r0
;;;2095     /* Enable the Capture compare and the Input Capture channels 
;;;2096       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2097       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2098       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2099       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2100       
;;;2101       No need to enable the counter, it's enabled automatically by hardware 
;;;2102       (the counter starts in response to a stimulus and generate a pulse */
;;;2103    
;;;2104     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2105     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2106     
;;;2107     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2108     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0410104          ORR      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2109     
;;;2110     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000018  2201              MOVS     r2,#1
00001a  2100              MOVS     r1,#0
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2111     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000022  2201              MOVS     r2,#1
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2112     
;;;2113     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002c  4906              LDR      r1,|L69.72|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d002              BEQ      |L69.58|
000034  4905              LDR      r1,|L69.76|
000036  4288              CMP      r0,r1
000038  d103              BNE      |L69.66|
                  |L69.58|
;;;2114     {
;;;2115       /* Enable the main output */
;;;2116       __HAL_TIM_MOE_ENABLE(htim);
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
                  |L69.66|
;;;2117     }
;;;2118     
;;;2119     /* Return function status */
;;;2120     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;2121   }
000044  bd10              POP      {r4,pc}
;;;2122   
                          ENDP

000046  0000              DCW      0x0000
                  |L69.72|
                          DCD      0x40010000
                  |L69.76|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2061   {
000002  4604              MOV      r4,r0
;;;2062     /* Disable the Capture compare and the Input Capture channels 
;;;2063     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2064     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2065     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2066     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2067     
;;;2068     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2069     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
00000e  2200              MOVS     r2,#0
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2070       
;;;2071     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000018  4810              LDR      r0,|L70.92|
;;;2072     {
;;;2073       /* Disable the Main Ouput */
;;;2074       __HAL_TIM_MOE_DISABLE(htim);
00001a  f2411211          MOV      r2,#0x1111
00001e  6821              LDR      r1,[r4,#0]            ;2071
000020  1093              ASRS     r3,r2,#2
000022  4281              CMP      r1,r0                 ;2071
000024  d002              BEQ      |L70.44|
000026  480e              LDR      r0,|L70.96|
000028  4281              CMP      r1,r0                 ;2071
00002a  d109              BNE      |L70.64|
                  |L70.44|
00002c  6a08              LDR      r0,[r1,#0x20]
00002e  4210              TST      r0,r2
000030  d106              BNE      |L70.64|
000032  6a08              LDR      r0,[r1,#0x20]
000034  4218              TST      r0,r3
000036  d103              BNE      |L70.64|
000038  6c48              LDR      r0,[r1,#0x44]
00003a  f4204000          BIC      r0,r0,#0x8000
00003e  6448              STR      r0,[r1,#0x44]
                  |L70.64|
;;;2075     }
;;;2076       
;;;2077     /* Disable the Peripheral */
;;;2078     __HAL_TIM_DISABLE(htim); 
000040  6820              LDR      r0,[r4,#0]
000042  6a01              LDR      r1,[r0,#0x20]
000044  4211              TST      r1,r2
000046  d106              BNE      |L70.86|
000048  6a01              LDR      r1,[r0,#0x20]
00004a  4219              TST      r1,r3
00004c  d103              BNE      |L70.86|
00004e  6801              LDR      r1,[r0,#0]
000050  f0210101          BIC      r1,r1,#1
000054  6001              STR      r1,[r0,#0]
                  |L70.86|
;;;2079     
;;;2080     /* Return function status */
;;;2081     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2082   }
000058  bd10              POP      {r4,pc}
;;;2083   
                          ENDP

00005a  0000              DCW      0x0000
                  |L70.92|
                          DCD      0x40010000
                  |L70.96|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2131     */
;;;2132   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2133   {
000002  4604              MOV      r4,r0
;;;2134     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2135     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2136     
;;;2137     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2138     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2139     
;;;2140     /* Disable the Capture compare and the Input Capture channels 
;;;2141     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2142     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2143     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2144     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2145     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2146     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000022  2200              MOVS     r2,#0
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2147       
;;;2148     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002c  4b10              LDR      r3,|L71.112|
;;;2149     {
;;;2150       /* Disable the Main Ouput */
;;;2151       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  6820              LDR      r0,[r4,#0]            ;2148
000034  108a              ASRS     r2,r1,#2
000036  4298              CMP      r0,r3                 ;2148
000038  d002              BEQ      |L71.64|
00003a  4b0e              LDR      r3,|L71.116|
00003c  4298              CMP      r0,r3                 ;2148
00003e  d109              BNE      |L71.84|
                  |L71.64|
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L71.84|
000046  6a03              LDR      r3,[r0,#0x20]
000048  4213              TST      r3,r2
00004a  d103              BNE      |L71.84|
00004c  6c43              LDR      r3,[r0,#0x44]
00004e  f4234300          BIC      r3,r3,#0x8000
000052  6443              STR      r3,[r0,#0x44]
                  |L71.84|
;;;2152     }
;;;2153       
;;;2154     /* Disable the Peripheral */
;;;2155      __HAL_TIM_DISABLE(htim);  
000054  6820              LDR      r0,[r4,#0]
000056  6a03              LDR      r3,[r0,#0x20]
000058  420b              TST      r3,r1
00005a  d106              BNE      |L71.106|
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  4211              TST      r1,r2
000060  d103              BNE      |L71.106|
000062  6801              LDR      r1,[r0,#0]
000064  f0210101          BIC      r1,r1,#1
000068  6001              STR      r1,[r0,#0]
                  |L71.106|
;;;2156     
;;;2157     /* Return function status */
;;;2158     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;2159   }
00006c  bd10              POP      {r4,pc}
;;;2160   
                          ENDP

00006e  0000              DCW      0x0000
                  |L71.112|
                          DCD      0x40010000
                  |L71.116|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3025     */
;;;3026   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3027   {
000002  4604              MOV      r4,r0
;;;3028     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  460d              MOV      r5,r1                 ;3027
00000a  2801              CMP      r0,#1
00000c  d00d              BEQ      |L72.42|
00000e  2601              MOVS     r6,#1
000010  f8846038          STRB     r6,[r4,#0x38]
;;;3029     
;;;3030     /* Check the parameters */ 
;;;3031     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3032     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3033     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3034     assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
;;;3035     assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
;;;3036     assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
;;;3037     
;;;3038     htim->State = HAL_TIM_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f8840039          STRB     r0,[r4,#0x39]
00001a  b142              CBZ      r2,|L72.46|
;;;3039       
;;;3040     switch (Channel)
00001c  2a04              CMP      r2,#4
00001e  d018              BEQ      |L72.82|
000020  2a08              CMP      r2,#8
000022  d02a              BEQ      |L72.122|
000024  2a0c              CMP      r2,#0xc
000026  d14d              BNE      |L72.196|
000028  e039              B        |L72.158|
                  |L72.42|
00002a  2002              MOVS     r0,#2                 ;3028
;;;3041     {
;;;3042       case TIM_CHANNEL_1:
;;;3043       {
;;;3044         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3045         /* Configure the Channel 1 in PWM mode */
;;;3046         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3047         
;;;3048         /* Set the Preload enable bit for channel1 */
;;;3049         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3050         
;;;3051         /* Configure the Output Fast mode */
;;;3052         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3053         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3054       }
;;;3055       break;
;;;3056       
;;;3057       case TIM_CHANNEL_2:
;;;3058       {
;;;3059         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3060         /* Configure the Channel 2 in PWM mode */
;;;3061         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3062         
;;;3063         /* Set the Preload enable bit for channel2 */
;;;3064         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3065         
;;;3066         /* Configure the Output Fast mode */
;;;3067         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3068         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3069       }
;;;3070       break;
;;;3071       
;;;3072       case TIM_CHANNEL_3:
;;;3073       {
;;;3074         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3075         /* Configure the Channel 3 in PWM mode */
;;;3076         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3077         
;;;3078         /* Set the Preload enable bit for channel3 */
;;;3079         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3080         
;;;3081        /* Configure the Output Fast mode */
;;;3082         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3083         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3084       }
;;;3085       break;
;;;3086       
;;;3087       case TIM_CHANNEL_4:
;;;3088       {
;;;3089         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3090         /* Configure the Channel 4 in PWM mode */
;;;3091         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3092         
;;;3093         /* Set the Preload enable bit for channel4 */
;;;3094         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3095         
;;;3096        /* Configure the Output Fast mode */
;;;3097         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3098         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3099       }
;;;3100       break;
;;;3101       
;;;3102       default:
;;;3103       break;    
;;;3104     }
;;;3105     
;;;3106     htim->State = HAL_TIM_STATE_READY;
;;;3107       
;;;3108     __HAL_UNLOCK(htim);
;;;3109     
;;;3110     return HAL_OK;
;;;3111   }
00002c  bd70              POP      {r4-r6,pc}
                  |L72.46|
00002e  6820              LDR      r0,[r4,#0]            ;3046
000030  f7fffffe          BL       TIM_OC1_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;3049
000036  6981              LDR      r1,[r0,#0x18]         ;3049
000038  f0410108          ORR      r1,r1,#8              ;3049
00003c  6181              STR      r1,[r0,#0x18]         ;3049
00003e  6820              LDR      r0,[r4,#0]            ;3052
000040  6981              LDR      r1,[r0,#0x18]         ;3052
000042  f0210104          BIC      r1,r1,#4              ;3052
000046  6181              STR      r1,[r0,#0x18]         ;3052
000048  6820              LDR      r0,[r4,#0]            ;3053
00004a  6981              LDR      r1,[r0,#0x18]         ;3053
00004c  692a              LDR      r2,[r5,#0x10]         ;3053
00004e  4311              ORRS     r1,r1,r2              ;3053
000050  e011              B        |L72.118|
                  |L72.82|
000052  6820              LDR      r0,[r4,#0]            ;3061
000054  f7fffffe          BL       TIM_OC2_SetConfig
000058  6820              LDR      r0,[r4,#0]            ;3064
00005a  6981              LDR      r1,[r0,#0x18]         ;3064
00005c  f4416100          ORR      r1,r1,#0x800          ;3064
000060  6181              STR      r1,[r0,#0x18]         ;3064
000062  6820              LDR      r0,[r4,#0]            ;3067
000064  6981              LDR      r1,[r0,#0x18]         ;3067
000066  f4216180          BIC      r1,r1,#0x400          ;3067
00006a  6181              STR      r1,[r0,#0x18]         ;3067
00006c  6820              LDR      r0,[r4,#0]            ;3068
00006e  6981              LDR      r1,[r0,#0x18]         ;3068
000070  692a              LDR      r2,[r5,#0x10]         ;3068
000072  ea412102          ORR      r1,r1,r2,LSL #8       ;3068
                  |L72.118|
000076  6181              STR      r1,[r0,#0x18]         ;3053
000078  e024              B        |L72.196|
                  |L72.122|
00007a  6820              LDR      r0,[r4,#0]            ;3076
00007c  f7fffffe          BL       TIM_OC3_SetConfig
000080  6820              LDR      r0,[r4,#0]            ;3079
000082  69c1              LDR      r1,[r0,#0x1c]         ;3079
000084  f0410108          ORR      r1,r1,#8              ;3079
000088  61c1              STR      r1,[r0,#0x1c]         ;3079
00008a  6820              LDR      r0,[r4,#0]            ;3082
00008c  69c1              LDR      r1,[r0,#0x1c]         ;3082
00008e  f0210104          BIC      r1,r1,#4              ;3082
000092  61c1              STR      r1,[r0,#0x1c]         ;3082
000094  6820              LDR      r0,[r4,#0]            ;3083
000096  69c1              LDR      r1,[r0,#0x1c]         ;3083
000098  692a              LDR      r2,[r5,#0x10]         ;3083
00009a  4311              ORRS     r1,r1,r2              ;3083
00009c  e011              B        |L72.194|
                  |L72.158|
00009e  6820              LDR      r0,[r4,#0]            ;3091
0000a0  f7fffffe          BL       TIM_OC4_SetConfig
0000a4  6820              LDR      r0,[r4,#0]            ;3094
0000a6  69c1              LDR      r1,[r0,#0x1c]         ;3094
0000a8  f4416100          ORR      r1,r1,#0x800          ;3094
0000ac  61c1              STR      r1,[r0,#0x1c]         ;3094
0000ae  6820              LDR      r0,[r4,#0]            ;3097
0000b0  69c1              LDR      r1,[r0,#0x1c]         ;3097
0000b2  f4216180          BIC      r1,r1,#0x400          ;3097
0000b6  61c1              STR      r1,[r0,#0x1c]         ;3097
0000b8  6820              LDR      r0,[r4,#0]            ;3098
0000ba  69c1              LDR      r1,[r0,#0x1c]         ;3098
0000bc  692a              LDR      r2,[r5,#0x10]         ;3098
0000be  ea412102          ORR      r1,r1,r2,LSL #8       ;3098
                  |L72.194|
0000c2  61c1              STR      r1,[r0,#0x1c]         ;3083
                  |L72.196|
0000c4  f8846039          STRB     r6,[r4,#0x39]         ;3106
0000c8  2000              MOVS     r0,#0                 ;3108
0000ca  f8840038          STRB     r0,[r4,#0x38]         ;3108
0000ce  bd70              POP      {r4-r6,pc}
;;;3112   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;998      */
;;;999    HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1000   {
000002  4604              MOV      r4,r0
;;;1001     /* Check the parameters */
;;;1002     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1003     
;;;1004     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;1005     
;;;1006     /* Disable the TIM Peripheral Clock */
;;;1007     __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L73.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L73.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L73.38|
;;;1008       
;;;1009     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1010     HAL_TIM_PWM_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1011       
;;;1012     /* Change TIM state */  
;;;1013     htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;1014   
;;;1015     /* Release Lock */
;;;1016     __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;1017   
;;;1018     return HAL_OK;
;;;1019   }
000036  bd10              POP      {r4,pc}
;;;1020   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4260     */
;;;4261   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;4262   {
;;;4263     return htim->State;
;;;4264   }
000004  4770              BX       lr
;;;4265   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;962      */
;;;963    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;964    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L75.14|
;;;965      /* Check the TIM handle allocation */
;;;966      if(htim == NULL)
;;;967      {
;;;968        return HAL_ERROR;
;;;969      }
;;;970    
;;;971      /* Check the parameters */
;;;972      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;973      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;974      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;975    
;;;976      if(htim->State == HAL_TIM_STATE_RESET)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b110              CBZ      r0,|L75.18|
00000c  e004              B        |L75.24|
                  |L75.14|
00000e  2001              MOVS     r0,#1                 ;968
;;;977      {
;;;978        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;979        HAL_TIM_PWM_MspInit(htim);
;;;980      }
;;;981    
;;;982      /* Set the TIM state */
;;;983      htim->State= HAL_TIM_STATE_BUSY;  
;;;984      
;;;985      /* Init the base time for the PWM */  
;;;986      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;987       
;;;988      /* Initialize the TIM state*/
;;;989      htim->State= HAL_TIM_STATE_READY;
;;;990      
;;;991      return HAL_OK;
;;;992    }  
000010  bd10              POP      {r4,pc}
                  |L75.18|
000012  4620              MOV      r0,r4                 ;979
000014  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L75.24|
000018  2002              MOVS     r0,#2                 ;983
00001a  f8840039          STRB     r0,[r4,#0x39]         ;983
00001e  1d21              ADDS     r1,r4,#4              ;986
000020  6820              LDR      r0,[r4,#0]            ;986
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;989
000028  f8840039          STRB     r0,[r4,#0x39]         ;989
00002c  2000              MOVS     r0,#0                 ;991
00002e  bd10              POP      {r4,pc}
;;;993    
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1037     */
;;;1038   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1039   {
;;;1040     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1041               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1042      */
;;;1043   }
;;;1044   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1025     */
;;;1026   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1027   {
;;;1028     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1029               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1030      */
;;;1031   }
;;;1032   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4185     */
;;;4186   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4187   {
;;;4188     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4189               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4190      */
;;;4191   }
;;;4192   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1055     */
;;;1056   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1057   {
000002  4604              MOV      r4,r0
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1060   
;;;1061     /* Enable the Capture compare channel */
;;;1062     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1063     
;;;1064     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4908              LDR      r1,|L79.48|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d002              BEQ      |L79.26|
000014  4907              LDR      r1,|L79.52|
000016  4288              CMP      r0,r1
000018  d103              BNE      |L79.34|
                  |L79.26|
;;;1065     {
;;;1066       /* Enable the main output */
;;;1067       __HAL_TIM_MOE_ENABLE(htim);
00001a  6c41              LDR      r1,[r0,#0x44]
00001c  f4414100          ORR      r1,r1,#0x8000
000020  6441              STR      r1,[r0,#0x44]
                  |L79.34|
;;;1068     }
;;;1069       
;;;1070     /* Enable the Peripheral */
;;;1071     __HAL_TIM_ENABLE(htim);
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
;;;1072     
;;;1073     /* Return function status */
;;;1074     return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;1075   } 
00002e  bd10              POP      {r4,pc}
;;;1076   
                          ENDP

                  |L79.48|
                          DCD      0x40010000
                  |L79.52|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1256     */
;;;1257   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1258   {
000002  4604              MOV      r4,r0
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1261     
;;;1262     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;1258
00000a  460d              MOV      r5,r1                 ;1258
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L80.28|
;;;1263     {
;;;1264        return HAL_BUSY;
;;;1265     }
;;;1266     else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L80.36|
;;;1267     {
;;;1268       if(((uint32_t)pData == 0 ) && (Length > 0)) 
000018  b90e              CBNZ     r6,|L80.30|
00001a  b103              CBZ      r3,|L80.30|
                  |L80.28|
;;;1269       {
;;;1270         return HAL_ERROR;                                    
;;;1271       }
;;;1272       else
;;;1273       {
;;;1274         htim->State = HAL_TIM_STATE_BUSY;
;;;1275       }
;;;1276     }    
;;;1277     switch (Channel)
;;;1278     {
;;;1279       case TIM_CHANNEL_1:
;;;1280       {      
;;;1281         /* Set the DMA Period elapsed callback */
;;;1282         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1283        
;;;1284         /* Set the DMA error callback */
;;;1285         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1286         
;;;1287         /* Enable the DMA Stream */
;;;1288         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1289         
;;;1290         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1291         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1292       }
;;;1293       break;
;;;1294       
;;;1295       case TIM_CHANNEL_2:
;;;1296       {
;;;1297         /* Set the DMA Period elapsed callback */
;;;1298         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1299        
;;;1300         /* Set the DMA error callback */
;;;1301         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1302         
;;;1303         /* Enable the DMA Stream */
;;;1304         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1305         
;;;1306         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1307         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1308       }
;;;1309       break;
;;;1310       
;;;1311       case TIM_CHANNEL_3:
;;;1312       {
;;;1313         /* Set the DMA Period elapsed callback */
;;;1314         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1315        
;;;1316         /* Set the DMA error callback */
;;;1317         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1318         
;;;1319         /* Enable the DMA Stream */
;;;1320         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1321         
;;;1322         /* Enable the TIM Output Capture/Compare 3 request */
;;;1323         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1324       }
;;;1325       break;
;;;1326       
;;;1327       case TIM_CHANNEL_4:
;;;1328       {
;;;1329        /* Set the DMA Period elapsed callback */
;;;1330         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1331        
;;;1332         /* Set the DMA error callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1334         
;;;1335         /* Enable the DMA Stream */
;;;1336         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1337         
;;;1338         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1339         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1340       }
;;;1341       break;
;;;1342       
;;;1343       default:
;;;1344       break;
;;;1345     }
;;;1346   
;;;1347     /* Enable the Capture compare channel */
;;;1348     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1349       
;;;1350     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1351     {
;;;1352       /* Enable the main output */
;;;1353       __HAL_TIM_MOE_ENABLE(htim);
;;;1354     }
;;;1355     
;;;1356     /* Enable the Peripheral */
;;;1357     __HAL_TIM_ENABLE(htim); 
;;;1358     
;;;1359     /* Return function status */
;;;1360     return HAL_OK;
;;;1361   }
00001c  bd70              POP      {r4-r6,pc}
                  |L80.30|
00001e  2002              MOVS     r0,#2                 ;1274
000020  f8840039          STRB     r0,[r4,#0x39]         ;1274
                  |L80.36|
000024  482e              LDR      r0,|L80.224|
000026  492f              LDR      r1,|L80.228|
000028  b135              CBZ      r5,|L80.56|
00002a  2d04              CMP      r5,#4                 ;1277
00002c  d013              BEQ      |L80.86|
00002e  2d08              CMP      r5,#8                 ;1277
000030  d037              BEQ      |L80.162|
000032  2d0c              CMP      r5,#0xc               ;1277
000034  d11e              BNE      |L80.116|
000036  e043              B        |L80.192|
                  |L80.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;1282
00003a  63d0              STR      r0,[r2,#0x3c]         ;1285
00003c  6a20              LDR      r0,[r4,#0x20]         ;1285
00003e  6481              STR      r1,[r0,#0x48]         ;1288
000040  6822              LDR      r2,[r4,#0]            ;1288
000042  4631              MOV      r1,r6                 ;1288
000044  3234              ADDS     r2,r2,#0x34           ;1288
000046  6a20              LDR      r0,[r4,#0x20]         ;1288
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1291
00004e  68c1              LDR      r1,[r0,#0xc]          ;1291
000050  f4417100          ORR      r1,r1,#0x200          ;1291
000054  e00d              B        |L80.114|
                  |L80.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;1298
000058  63d0              STR      r0,[r2,#0x3c]         ;1301
00005a  6a60              LDR      r0,[r4,#0x24]         ;1301
00005c  6481              STR      r1,[r0,#0x48]         ;1304
00005e  6822              LDR      r2,[r4,#0]            ;1304
000060  4631              MOV      r1,r6                 ;1304
000062  3238              ADDS     r2,r2,#0x38           ;1304
000064  6a60              LDR      r0,[r4,#0x24]         ;1304
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;1307
00006c  68c1              LDR      r1,[r0,#0xc]          ;1307
00006e  f4416180          ORR      r1,r1,#0x400          ;1307
                  |L80.114|
000072  60c1              STR      r1,[r0,#0xc]          ;1291
                  |L80.116|
000074  2201              MOVS     r2,#1                 ;1348
000076  4629              MOV      r1,r5                 ;1348
000078  6820              LDR      r0,[r4,#0]            ;1348
00007a  f7fffffe          BL       TIM_CCxChannelCmd
00007e  491a              LDR      r1,|L80.232|
000080  6820              LDR      r0,[r4,#0]            ;1350
000082  4288              CMP      r0,r1                 ;1350
000084  d002              BEQ      |L80.140|
000086  4919              LDR      r1,|L80.236|
000088  4288              CMP      r0,r1                 ;1350
00008a  d103              BNE      |L80.148|
                  |L80.140|
00008c  6c41              LDR      r1,[r0,#0x44]         ;1353
00008e  f4414100          ORR      r1,r1,#0x8000         ;1353
000092  6441              STR      r1,[r0,#0x44]         ;1353
                  |L80.148|
000094  6820              LDR      r0,[r4,#0]            ;1357
000096  6801              LDR      r1,[r0,#0]            ;1357
000098  f0410101          ORR      r1,r1,#1              ;1357
00009c  6001              STR      r1,[r0,#0]            ;1357
00009e  2000              MOVS     r0,#0                 ;1360
0000a0  bd70              POP      {r4-r6,pc}
                  |L80.162|
0000a2  6aa2              LDR      r2,[r4,#0x28]         ;1314
0000a4  63d0              STR      r0,[r2,#0x3c]         ;1317
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;1317
0000a8  6481              STR      r1,[r0,#0x48]         ;1320
0000aa  6822              LDR      r2,[r4,#0]            ;1320
0000ac  4631              MOV      r1,r6                 ;1320
0000ae  323c              ADDS     r2,r2,#0x3c           ;1320
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;1320
0000b2  f7fffffe          BL       HAL_DMA_Start_IT
0000b6  6820              LDR      r0,[r4,#0]            ;1323
0000b8  68c1              LDR      r1,[r0,#0xc]          ;1323
0000ba  f4416100          ORR      r1,r1,#0x800          ;1323
0000be  e7d8              B        |L80.114|
                  |L80.192|
0000c0  6ae2              LDR      r2,[r4,#0x2c]         ;1330
0000c2  63d0              STR      r0,[r2,#0x3c]         ;1333
0000c4  6ae0              LDR      r0,[r4,#0x2c]         ;1333
0000c6  6481              STR      r1,[r0,#0x48]         ;1336
0000c8  6822              LDR      r2,[r4,#0]            ;1336
0000ca  4631              MOV      r1,r6                 ;1336
0000cc  3240              ADDS     r2,r2,#0x40           ;1336
0000ce  6ae0              LDR      r0,[r4,#0x2c]         ;1336
0000d0  f7fffffe          BL       HAL_DMA_Start_IT
0000d4  6820              LDR      r0,[r4,#0]            ;1339
0000d6  68c1              LDR      r1,[r0,#0xc]          ;1339
0000d8  f4415180          ORR      r1,r1,#0x1000         ;1339
0000dc  e7c9              B        |L80.114|
;;;1362   
                          ENDP

0000de  0000              DCW      0x0000
                  |L80.224|
                          DCD      HAL_TIM_DMADelayPulseCplt
                  |L80.228|
                          DCD      HAL_TIM_DMAError
                  |L80.232|
                          DCD      0x40010000
                  |L80.236|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1122     */
;;;1123   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1124   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L81.22|
;;;1125     /* Check the parameters */
;;;1126     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1127     
;;;1128     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L81.30|
00000c  2908              CMP      r1,#8
00000e  d020              BEQ      |L81.82|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L81.38|
000014  e021              B        |L81.90|
                  |L81.22|
;;;1129     {
;;;1130       case TIM_CHANNEL_1:
;;;1131       {       
;;;1132         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1133         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1134       }
;;;1135       break;
00001c  e002              B        |L81.36|
                  |L81.30|
;;;1136       
;;;1137       case TIM_CHANNEL_2:
;;;1138       {
;;;1139         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1140         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L81.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1133
                  |L81.38|
;;;1141       }
;;;1142       break;
;;;1143       
;;;1144       case TIM_CHANNEL_3:
;;;1145       {
;;;1146         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1147         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1148       }
;;;1149       break;
;;;1150       
;;;1151       case TIM_CHANNEL_4:
;;;1152       {
;;;1153         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1154         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1155       }
;;;1156       break;
;;;1157       
;;;1158       default:
;;;1159       break;
;;;1160     } 
;;;1161     
;;;1162     /* Enable the Capture compare channel */
;;;1163     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1164     
;;;1165     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  490d              LDR      r1,|L81.100|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d002              BEQ      |L81.60|
000036  490c              LDR      r1,|L81.104|
000038  4288              CMP      r0,r1
00003a  d103              BNE      |L81.68|
                  |L81.60|
;;;1166     {
;;;1167       /* Enable the main output */
;;;1168       __HAL_TIM_MOE_ENABLE(htim);
00003c  6c41              LDR      r1,[r0,#0x44]
00003e  f4414100          ORR      r1,r1,#0x8000
000042  6441              STR      r1,[r0,#0x44]
                  |L81.68|
;;;1169     }
;;;1170   
;;;1171     /* Enable the Peripheral */
;;;1172     __HAL_TIM_ENABLE(htim);
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  f0410101          ORR      r1,r1,#1
00004c  6001              STR      r1,[r0,#0]
;;;1173     
;;;1174     /* Return function status */
;;;1175     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1176   } 
000050  bd10              POP      {r4,pc}
                  |L81.82|
000052  68d0              LDR      r0,[r2,#0xc]          ;1147
000054  f0400008          ORR      r0,r0,#8              ;1147
000058  e7e4              B        |L81.36|
                  |L81.90|
00005a  68d0              LDR      r0,[r2,#0xc]          ;1154
00005c  f0400010          ORR      r0,r0,#0x10           ;1154
000060  e7e0              B        |L81.36|
;;;1177   
                          ENDP

000062  0000              DCW      0x0000
                  |L81.100|
                          DCD      0x40010000
                  |L81.104|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1087     */
;;;1088   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1089   { 
000002  4604              MOV      r4,r0
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1092       
;;;1093     /* Disable the Capture compare channel */
;;;1094     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1095     
;;;1096     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4811              LDR      r0,|L82.84|
;;;1097     {
;;;1098       /* Disable the Main Ouput */
;;;1099       __HAL_TIM_MOE_DISABLE(htim);
00000e  f2411211          MOV      r2,#0x1111
000012  6821              LDR      r1,[r4,#0]            ;1096
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;1096
000018  d002              BEQ      |L82.32|
00001a  480f              LDR      r0,|L82.88|
00001c  4281              CMP      r1,r0                 ;1096
00001e  d109              BNE      |L82.52|
                  |L82.32|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4210              TST      r0,r2
000024  d106              BNE      |L82.52|
000026  6a08              LDR      r0,[r1,#0x20]
000028  4218              TST      r0,r3
00002a  d103              BNE      |L82.52|
00002c  6c48              LDR      r0,[r1,#0x44]
00002e  f4204000          BIC      r0,r0,#0x8000
000032  6448              STR      r0,[r1,#0x44]
                  |L82.52|
;;;1100     }
;;;1101     
;;;1102     /* Disable the Peripheral */
;;;1103     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L82.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L82.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L82.74|
;;;1104     
;;;1105     /* Change the htim state */
;;;1106     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  f8840039          STRB     r0,[r4,#0x39]
;;;1107     
;;;1108     /* Return function status */
;;;1109     return HAL_OK;
000050  2000              MOVS     r0,#0
;;;1110   } 
000052  bd10              POP      {r4,pc}
;;;1111   
                          ENDP

                  |L82.84|
                          DCD      0x40010000
                  |L82.88|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1373     */
;;;1374   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1375   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L83.22|
;;;1376     /* Check the parameters */
;;;1377     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1378     
;;;1379     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L83.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L83.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L83.38|
000014  e033              B        |L83.126|
                  |L83.22|
;;;1380     {
;;;1381       case TIM_CHANNEL_1:
;;;1382       {       
;;;1383         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1384         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1385       }
;;;1386       break;
00001c  e002              B        |L83.36|
                  |L83.30|
;;;1387       
;;;1388       case TIM_CHANNEL_2:
;;;1389       {
;;;1390         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1391         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L83.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1384
                  |L83.38|
;;;1392       }
;;;1393       break;
;;;1394       
;;;1395       case TIM_CHANNEL_3:
;;;1396       {
;;;1397         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1398         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1399       }
;;;1400       break;
;;;1401       
;;;1402       case TIM_CHANNEL_4:
;;;1403       {
;;;1404         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1405         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1406       }
;;;1407       break;
;;;1408       
;;;1409       default:
;;;1410       break;
;;;1411     } 
;;;1412     
;;;1413     /* Disable the Capture compare channel */
;;;1414     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1415     
;;;1416     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  4b16              LDR      r3,|L83.136|
;;;1417     {
;;;1418       /* Disable the Main Ouput */
;;;1419       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411211          MOV      r2,#0x1111
000034  6820              LDR      r0,[r4,#0]            ;1416
000036  1091              ASRS     r1,r2,#2
000038  4298              CMP      r0,r3                 ;1416
00003a  d002              BEQ      |L83.66|
00003c  4b13              LDR      r3,|L83.140|
00003e  4298              CMP      r0,r3                 ;1416
000040  d109              BNE      |L83.86|
                  |L83.66|
000042  6a03              LDR      r3,[r0,#0x20]
000044  4213              TST      r3,r2
000046  d106              BNE      |L83.86|
000048  6a03              LDR      r3,[r0,#0x20]
00004a  420b              TST      r3,r1
00004c  d103              BNE      |L83.86|
00004e  6c43              LDR      r3,[r0,#0x44]
000050  f4234300          BIC      r3,r3,#0x8000
000054  6443              STR      r3,[r0,#0x44]
                  |L83.86|
;;;1420     }
;;;1421     
;;;1422     /* Disable the Peripheral */
;;;1423     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a03              LDR      r3,[r0,#0x20]
00005a  4213              TST      r3,r2
00005c  d106              BNE      |L83.108|
00005e  6a02              LDR      r2,[r0,#0x20]
000060  420a              TST      r2,r1
000062  d103              BNE      |L83.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L83.108|
;;;1424     
;;;1425     /* Change the htim state */
;;;1426     htim->State = HAL_TIM_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  f8840039          STRB     r0,[r4,#0x39]
;;;1427     
;;;1428     /* Return function status */
;;;1429     return HAL_OK;
000072  2000              MOVS     r0,#0
;;;1430   }
000074  bd10              POP      {r4,pc}
                  |L83.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;1398
000078  f4206000          BIC      r0,r0,#0x800          ;1398
00007c  e7d2              B        |L83.36|
                  |L83.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;1405
000080  f4205080          BIC      r0,r0,#0x1000         ;1405
000084  e7ce              B        |L83.36|
;;;1431   
                          ENDP

000086  0000              DCW      0x0000
                  |L83.136|
                          DCD      0x40010000
                  |L83.140|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1188     */
;;;1189   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1190   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L84.22|
;;;1191     /* Check the parameters */
;;;1192     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1193     
;;;1194     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L84.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L84.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L84.38|
000014  e030              B        |L84.120|
                  |L84.22|
;;;1195     {
;;;1196       case TIM_CHANNEL_1:
;;;1197       {       
;;;1198         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1199         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1200       }
;;;1201       break;
00001c  e002              B        |L84.36|
                  |L84.30|
;;;1202       
;;;1203       case TIM_CHANNEL_2:
;;;1204       {
;;;1205         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1206         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L84.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1199
                  |L84.38|
;;;1207       }
;;;1208       break;
;;;1209       
;;;1210       case TIM_CHANNEL_3:
;;;1211       {
;;;1212         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1213         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1214       }
;;;1215       break;
;;;1216       
;;;1217       case TIM_CHANNEL_4:
;;;1218       {
;;;1219         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1220         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1221       }
;;;1222       break;
;;;1223       
;;;1224       default:
;;;1225       break; 
;;;1226     }
;;;1227     
;;;1228     /* Disable the Capture compare channel */
;;;1229     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1230     
;;;1231     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  4814              LDR      r0,|L84.128|
;;;1232     {
;;;1233       /* Disable the Main Ouput */
;;;1234       __HAL_TIM_MOE_DISABLE(htim);
000030  f2411311          MOV      r3,#0x1111
000034  6821              LDR      r1,[r4,#0]            ;1231
000036  109a              ASRS     r2,r3,#2
000038  4281              CMP      r1,r0                 ;1231
00003a  d002              BEQ      |L84.66|
00003c  4811              LDR      r0,|L84.132|
00003e  4281              CMP      r1,r0                 ;1231
000040  d109              BNE      |L84.86|
                  |L84.66|
000042  6a08              LDR      r0,[r1,#0x20]
000044  4218              TST      r0,r3
000046  d106              BNE      |L84.86|
000048  6a08              LDR      r0,[r1,#0x20]
00004a  4210              TST      r0,r2
00004c  d103              BNE      |L84.86|
00004e  6c48              LDR      r0,[r1,#0x44]
000050  f4204000          BIC      r0,r0,#0x8000
000054  6448              STR      r0,[r1,#0x44]
                  |L84.86|
;;;1235     }
;;;1236     
;;;1237     /* Disable the Peripheral */
;;;1238     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4219              TST      r1,r3
00005c  d106              BNE      |L84.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L84.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L84.108|
;;;1239     
;;;1240     /* Return function status */
;;;1241     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1242   } 
00006e  bd10              POP      {r4,pc}
                  |L84.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1213
000072  f0200008          BIC      r0,r0,#8              ;1213
000076  e7d5              B        |L84.36|
                  |L84.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;1220
00007a  f0200010          BIC      r0,r0,#0x10           ;1220
00007e  e7d1              B        |L84.36|
;;;1243   
                          ENDP

                  |L84.128|
                          DCD      0x40010000
                  |L84.132|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4150     */
;;;4151   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4152   {
;;;4153     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4154               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4155      */
;;;4156     
;;;4157   }
;;;4158   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4063     */
;;;4064   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  f8903038          LDRB     r3,[r0,#0x38]
;;;4065   {
;;;4066     uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;4067     
;;;4068     __HAL_LOCK(htim);
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L86.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L86.36|
;;;4069     
;;;4070     switch (Channel)
000012  2904              CMP      r1,#4
000014  d009              BEQ      |L86.42|
000016  2908              CMP      r1,#8
000018  d00a              BEQ      |L86.48|
00001a  290c              CMP      r1,#0xc
00001c  d10d              BNE      |L86.58|
00001e  e00a              B        |L86.54|
                  |L86.32|
000020  2002              MOVS     r0,#2                 ;4068
;;;4071     {
;;;4072       case TIM_CHANNEL_1:
;;;4073       {
;;;4074         /* Check the parameters */
;;;4075         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4076         
;;;4077         /* Return the capture 1 value */
;;;4078         tmpreg = htim->Instance->CCR1;
;;;4079         
;;;4080         break;
;;;4081       }
;;;4082       case TIM_CHANNEL_2:
;;;4083       {
;;;4084         /* Check the parameters */
;;;4085         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4086         
;;;4087         /* Return the capture 2 value */
;;;4088         tmpreg = htim->Instance->CCR2;
;;;4089         
;;;4090         break;
;;;4091       }
;;;4092       
;;;4093       case TIM_CHANNEL_3:
;;;4094       {
;;;4095         /* Check the parameters */
;;;4096         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4097         
;;;4098         /* Return the capture 3 value */
;;;4099         tmpreg = htim->Instance->CCR3;
;;;4100         
;;;4101         break;
;;;4102       }
;;;4103       
;;;4104       case TIM_CHANNEL_4:
;;;4105       {
;;;4106         /* Check the parameters */
;;;4107         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4108         
;;;4109         /* Return the capture 4 value */
;;;4110         tmpreg = htim->Instance->CCR4;
;;;4111         
;;;4112         break;
;;;4113       }
;;;4114       
;;;4115       default:
;;;4116       break;  
;;;4117     }
;;;4118        
;;;4119     __HAL_UNLOCK(htim);  
;;;4120     return tmpreg;
;;;4121   }
000022  4770              BX       lr
                  |L86.36|
000024  6801              LDR      r1,[r0,#0]            ;4078
000026  6b4a              LDR      r2,[r1,#0x34]         ;4078
000028  e007              B        |L86.58|
                  |L86.42|
00002a  6801              LDR      r1,[r0,#0]            ;4088
00002c  6b8a              LDR      r2,[r1,#0x38]         ;4088
00002e  e004              B        |L86.58|
                  |L86.48|
000030  6801              LDR      r1,[r0,#0]            ;4099
000032  6bca              LDR      r2,[r1,#0x3c]         ;4099
000034  e001              B        |L86.58|
                  |L86.54|
000036  6801              LDR      r1,[r0,#0]            ;4110
000038  6c0a              LDR      r2,[r1,#0x40]         ;4110
                  |L86.58|
00003a  2100              MOVS     r1,#0                 ;4119
00003c  f8801038          STRB     r1,[r0,#0x38]         ;4119
000040  4610              MOV      r0,r2                 ;4120
000042  4770              BX       lr
;;;4122   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;3914     */
;;;3915   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;3916   {
000002  4604              MOV      r4,r0
;;;3917     uint32_t tmpsmcr  = 0;
;;;3918     uint32_t tmpccmr1 = 0;
;;;3919     uint32_t tmpccer = 0;
;;;3920   
;;;3921     /* Check the parameters */
;;;3922     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;3923     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;3924     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;3925      
;;;3926     __HAL_LOCK(htim);
000004  f8900038          LDRB     r0,[r0,#0x38]
000008  2801              CMP      r0,#1
00000a  d015              BEQ      |L87.56|
00000c  2501              MOVS     r5,#1
00000e  f8845038          STRB     r5,[r4,#0x38]
;;;3927     
;;;3928     htim->State = HAL_TIM_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840039          STRB     r0,[r4,#0x39]
;;;3929   
;;;3930     /* Get the TIMx SMCR register value */
;;;3931     tmpsmcr = htim->Instance->SMCR;
000018  6822              LDR      r2,[r4,#0]
00001a  6890              LDR      r0,[r2,#8]
;;;3932   
;;;3933     /* Reset the Trigger Selection Bits */
;;;3934     tmpsmcr &= ~TIM_SMCR_TS;
00001c  f0200370          BIC      r3,r0,#0x70
;;;3935     /* Set the Input Trigger source */
;;;3936     tmpsmcr |= sSlaveConfig->InputTrigger;
000020  6848              LDR      r0,[r1,#4]
000022  4318              ORRS     r0,r0,r3
;;;3937   
;;;3938     /* Reset the slave mode Bits */
;;;3939     tmpsmcr &= ~TIM_SMCR_SMS;
000024  f0200307          BIC      r3,r0,#7
;;;3940     /* Set the slave mode */
;;;3941     tmpsmcr |= sSlaveConfig->SlaveMode;
000028  6808              LDR      r0,[r1,#0]
00002a  4318              ORRS     r0,r0,r3
;;;3942   
;;;3943     /* Write to TIMx SMCR */
;;;3944     htim->Instance->SMCR = tmpsmcr;
00002c  6090              STR      r0,[r2,#8]
;;;3945     
;;;3946     /* Configure the trigger prescaler, filter, and polarity */
;;;3947     switch (sSlaveConfig->InputTrigger)
00002e  6848              LDR      r0,[r1,#4]
000030  f0100f0f          TST      r0,#0xf
000034  d002              BEQ      |L87.60|
000036  e02d              B        |L87.148|
                  |L87.56|
000038  2002              MOVS     r0,#2                 ;3926
;;;3948     {
;;;3949     case TIM_TS_ETRF:
;;;3950       {
;;;3951         /* Check the parameters */
;;;3952         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3953         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;3954         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;3955         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;3956         /* Configure the ETR Trigger source */
;;;3957         TIM_ETR_SetConfig(htim->Instance, 
;;;3958                           sSlaveConfig->TriggerPrescaler, 
;;;3959                           sSlaveConfig->TriggerPolarity, 
;;;3960                           sSlaveConfig->TriggerFilter);
;;;3961       }
;;;3962       break;
;;;3963       
;;;3964     case TIM_TS_TI1F_ED:
;;;3965       {
;;;3966         /* Check the parameters */
;;;3967         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3968         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;3969         
;;;3970         /* Disable the Channel 1: Reset the CC1E Bit */
;;;3971         tmpccer = htim->Instance->CCER;
;;;3972         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;3973         tmpccmr1 = htim->Instance->CCMR1;    
;;;3974         
;;;3975         /* Set the filter */
;;;3976         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;3977         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
;;;3978         
;;;3979         /* Write to TIMx CCMR1 and CCER registers */
;;;3980         htim->Instance->CCMR1 = tmpccmr1;
;;;3981         htim->Instance->CCER = tmpccer;                               
;;;3982                                  
;;;3983       }
;;;3984       break;
;;;3985       
;;;3986     case TIM_TS_TI1FP1:
;;;3987       {
;;;3988         /* Check the parameters */
;;;3989         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3990         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;3991         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;3992   
;;;3993         /* Configure TI1 Filter and Polarity */
;;;3994         TIM_TI1_ConfigInputStage(htim->Instance,
;;;3995                                  sSlaveConfig->TriggerPolarity,
;;;3996                                  sSlaveConfig->TriggerFilter);
;;;3997       }
;;;3998       break;
;;;3999       
;;;4000     case TIM_TS_TI2FP2:
;;;4001       {
;;;4002         /* Check the parameters */
;;;4003         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4004         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4005         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4006         
;;;4007         /* Configure TI2 Filter and Polarity */
;;;4008         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4009                                   sSlaveConfig->TriggerPolarity,
;;;4010                                   sSlaveConfig->TriggerFilter);
;;;4011       }
;;;4012       break;
;;;4013       
;;;4014     case TIM_TS_ITR0:
;;;4015       {
;;;4016         /* Check the parameter */
;;;4017         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4018       }
;;;4019       break;
;;;4020       
;;;4021     case TIM_TS_ITR1:
;;;4022       {
;;;4023         /* Check the parameter */
;;;4024         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4025       }
;;;4026       break;
;;;4027       
;;;4028     case TIM_TS_ITR2:
;;;4029       {
;;;4030         /* Check the parameter */
;;;4031         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4032       }
;;;4033       break;
;;;4034       
;;;4035     case TIM_TS_ITR3:
;;;4036       {
;;;4037         /* Check the parameter */
;;;4038         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4039       }
;;;4040       break;
;;;4041          
;;;4042     default:
;;;4043       break;
;;;4044     }
;;;4045     
;;;4046     htim->State = HAL_TIM_STATE_READY;
;;;4047        
;;;4048     __HAL_UNLOCK(htim);  
;;;4049     
;;;4050     return HAL_OK;
;;;4051   } 
00003a  bd70              POP      {r4-r6,pc}
                  |L87.60|
00003c  1100              ASRS     r0,r0,#4              ;3947
00003e  2808              CMP      r0,#8                 ;3947
000040  d228              BCS      |L87.148|
000042  e8dff000          TBB      [pc,r0]               ;3947
000046  2727              DCB      0x27,0x27
000048  27270b1c          DCB      0x27,0x27,0x0b,0x1c
00004c  2204              DCB      0x22,0x04
00004e  690b              LDR      r3,[r1,#0x10]         ;3957
000050  e9d12102          LDRD     r2,r1,[r1,#8]         ;3957
000054  6820              LDR      r0,[r4,#0]            ;3957
000056  f7fffffe          BL       TIM_ETR_SetConfig
00005a  e01b              B        |L87.148|
00005c  6820              LDR      r0,[r4,#0]            ;3971
00005e  6a02              LDR      r2,[r0,#0x20]         ;3971
000060  6a03              LDR      r3,[r0,#0x20]         ;3972
000062  f0230301          BIC      r3,r3,#1              ;3972
000066  6203              STR      r3,[r0,#0x20]         ;3972
000068  6820              LDR      r0,[r4,#0]            ;3973
00006a  6983              LDR      r3,[r0,#0x18]         ;3973
00006c  6909              LDR      r1,[r1,#0x10]         ;3977
00006e  f02303f0          BIC      r3,r3,#0xf0           ;3976
000072  ea431101          ORR      r1,r3,r1,LSL #4       ;3977
000076  6181              STR      r1,[r0,#0x18]         ;3980
000078  6820              LDR      r0,[r4,#0]            ;3981
00007a  6202              STR      r2,[r0,#0x20]         ;3981
00007c  e00a              B        |L87.148|
00007e  690a              LDR      r2,[r1,#0x10]         ;3994
000080  6889              LDR      r1,[r1,#8]            ;3994
000082  6820              LDR      r0,[r4,#0]            ;3994
000084  f7fffffe          BL       TIM_TI1_ConfigInputStage
000088  e004              B        |L87.148|
00008a  690a              LDR      r2,[r1,#0x10]         ;4008
00008c  6889              LDR      r1,[r1,#8]            ;4008
00008e  6820              LDR      r0,[r4,#0]            ;4008
000090  f7fffffe          BL       TIM_TI2_ConfigInputStage
                  |L87.148|
000094  f8845039          STRB     r5,[r4,#0x39]         ;4046
000098  2000              MOVS     r0,#0                 ;4048
00009a  f8840038          STRB     r0,[r4,#0x38]         ;4048
00009e  bd70              POP      {r4-r6,pc}
;;;4052   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4197     */
;;;4198   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4199   {
;;;4200     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4201               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4202      */
;;;4203   }
;;;4204   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4374     */
;;;4375   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4376   {
;;;4377     uint32_t tmpcr1 = 0;
;;;4378     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4379     
;;;4380     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4381     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000004  4b23              LDR      r3,|L89.148|
000006  4d24              LDR      r5,|L89.152|
000008  4e24              LDR      r6,|L89.156|
00000a  4f25              LDR      r7,|L89.160|
00000c  4c25              LDR      r4,|L89.164|
00000e  f04f4c80          MOV      r12,#0x40000000
000012  4298              CMP      r0,r3
000014  d009              BEQ      |L89.42|
000016  4560              CMP      r0,r12
000018  d007              BEQ      |L89.42|
00001a  42a8              CMP      r0,r5
00001c  d005              BEQ      |L89.42|
00001e  42b0              CMP      r0,r6
000020  d003              BEQ      |L89.42|
000022  42b8              CMP      r0,r7
000024  d001              BEQ      |L89.42|
000026  42a0              CMP      r0,r4
000028  d104              BNE      |L89.52|
                  |L89.42|
;;;4382     {
;;;4383       /* Select the Counter Mode */
;;;4384       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
00002a  f0220e70          BIC      lr,r2,#0x70
;;;4385       tmpcr1 |= Structure->CounterMode;
00002e  684a              LDR      r2,[r1,#4]
000030  ea42020e          ORR      r2,r2,lr
                  |L89.52|
;;;4386     }
;;;4387    
;;;4388     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000034  4298              CMP      r0,r3
000036  d01b              BEQ      |L89.112|
000038  4560              CMP      r0,r12
00003a  d019              BEQ      |L89.112|
00003c  42a8              CMP      r0,r5
00003e  d017              BEQ      |L89.112|
000040  42b0              CMP      r0,r6
000042  d015              BEQ      |L89.112|
000044  42b8              CMP      r0,r7
000046  d013              BEQ      |L89.112|
000048  42a0              CMP      r0,r4
00004a  d011              BEQ      |L89.112|
00004c  4d16              LDR      r5,|L89.168|
00004e  42a8              CMP      r0,r5
000050  d00e              BEQ      |L89.112|
000052  4d16              LDR      r5,|L89.172|
000054  42a8              CMP      r0,r5
000056  d00b              BEQ      |L89.112|
000058  4d15              LDR      r5,|L89.176|
00005a  42a8              CMP      r0,r5
00005c  d008              BEQ      |L89.112|
00005e  4d15              LDR      r5,|L89.180|
000060  42a8              CMP      r0,r5
000062  d005              BEQ      |L89.112|
000064  4d14              LDR      r5,|L89.184|
000066  42a8              CMP      r0,r5
000068  d002              BEQ      |L89.112|
00006a  4d14              LDR      r5,|L89.188|
00006c  42a8              CMP      r0,r5
00006e  d103              BNE      |L89.120|
                  |L89.112|
;;;4389     {
;;;4390       /* Set the clock division */
;;;4391       tmpcr1 &= ~TIM_CR1_CKD;
000070  f4227540          BIC      r5,r2,#0x300
;;;4392       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000074  68ca              LDR      r2,[r1,#0xc]
000076  432a              ORRS     r2,r2,r5
                  |L89.120|
;;;4393     }
;;;4394   
;;;4395     TIMx->CR1 = tmpcr1;
000078  6002              STR      r2,[r0,#0]
;;;4396   
;;;4397     /* Set the Autoreload value */
;;;4398     TIMx->ARR = (uint32_t)Structure->Period ;
00007a  688a              LDR      r2,[r1,#8]
00007c  62c2              STR      r2,[r0,#0x2c]
;;;4399    
;;;4400     /* Set the Prescaler value */
;;;4401     TIMx->PSC = (uint32_t)Structure->Prescaler;
00007e  680a              LDR      r2,[r1,#0]
000080  6282              STR      r2,[r0,#0x28]
;;;4402       
;;;4403     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
000082  4298              CMP      r0,r3
000084  d001              BEQ      |L89.138|
000086  42a0              CMP      r0,r4
000088  d101              BNE      |L89.142|
                  |L89.138|
;;;4404     {
;;;4405       /* Set the Repetition Counter value */
;;;4406       TIMx->RCR = Structure->RepetitionCounter;
00008a  6909              LDR      r1,[r1,#0x10]
00008c  6301              STR      r1,[r0,#0x30]
                  |L89.142|
;;;4407     }
;;;4408   
;;;4409     /* Generate an update event to reload the Prescaler 
;;;4410        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4411     TIMx->EGR = TIM_EGR_UG;
00008e  2101              MOVS     r1,#1
000090  6141              STR      r1,[r0,#0x14]
;;;4412   }
000092  bdf0              POP      {r4-r7,pc}
;;;4413   
                          ENDP

                  |L89.148|
                          DCD      0x40010000
                  |L89.152|
                          DCD      0x40000400
                  |L89.156|
                          DCD      0x40000800
                  |L89.160|
                          DCD      0x40000c00
                  |L89.164|
                          DCD      0x40010400
                  |L89.168|
                          DCD      0x40014000
                  |L89.172|
                          DCD      0x40014400
                  |L89.176|
                          DCD      0x40014800
                  |L89.180|
                          DCD      0x40001800
                  |L89.184|
                          DCD      0x40001c00
                  |L89.188|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5005     */
;;;5006   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;5007   {
;;;5008     uint32_t tmp = 0;
;;;5009   
;;;5010     /* Check the parameters */
;;;5011     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;5012     assert_param(IS_TIM_CHANNELS(Channel));
;;;5013   
;;;5014     tmp = TIM_CCER_CC1E << Channel;
000002  2301              MOVS     r3,#1
;;;5015   
;;;5016     /* Reset the CCxE Bit */
;;;5017     TIMx->CCER &= ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;5014
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;5018   
;;;5019     /* Set or reset the CCxE Bit */ 
;;;5020     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;5021   }
000014  bd10              POP      {r4,pc}
;;;5022   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4346     */
;;;4347   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4348   {
;;;4349     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;4350     
;;;4351     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4352     
;;;4353     HAL_TIM_PeriodElapsedCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4354   }
00000e  bd10              POP      {r4,pc}
;;;4355   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4360     */
;;;4361   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4362   {
;;;4363     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000002  6b80              LDR      r0,[r0,#0x38]
;;;4364     
;;;4365     htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;4366     
;;;4367     HAL_TIM_TriggerCallback(htim);
00000a  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4368   }
00000e  bd10              POP      {r4,pc}
;;;4369   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;4975     */
;;;4976   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;4977                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;4978   {
;;;4979     uint32_t tmpsmcr = 0;
;;;4980   
;;;4981     tmpsmcr = TIMx->SMCR;
000002  6884              LDR      r4,[r0,#8]
;;;4982   
;;;4983     /* Reset the ETR Bits */
;;;4984     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4985   
;;;4986     /* Set the Prescaler, the Filter value and the Polarity */
;;;4987     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
000004  ea422203          ORR      r2,r2,r3,LSL #8
000008  f424447f          BIC      r4,r4,#0xff00         ;4984
00000c  430a              ORRS     r2,r2,r1
00000e  4322              ORRS     r2,r2,r4
;;;4988   
;;;4989     /* Write to TIMx SMCR */
;;;4990     TIMx->SMCR = tmpsmcr;
000010  6082              STR      r2,[r0,#8]
;;;4991   } 
000012  bd10              POP      {r4,pc}
;;;4992   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;4945     */
;;;4946   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
000000  6882              LDR      r2,[r0,#8]
;;;4947   {
;;;4948     uint32_t tmpsmcr = 0;
;;;4949     
;;;4950      /* Get the TIMx SMCR register value */
;;;4951      tmpsmcr = TIMx->SMCR;
;;;4952      /* Reset the TS Bits */
;;;4953      tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;4954      /* Set the Input Trigger source and the slave mode*/
;;;4955      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;4956      /* Write to TIMx SMCR */
;;;4957      TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;4958   }
00000e  4770              BX       lr
;;;4959   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4419     */
;;;4420   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4421   {
;;;4422     uint32_t tmpccmrx = 0;
;;;4423     uint32_t tmpccer = 0;
;;;4424     uint32_t tmpcr2 = 0;  
;;;4425   
;;;4426     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4427     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  6202              STR      r2,[r0,#0x20]
;;;4428     
;;;4429     /* Get the TIMx CCER register value */
;;;4430     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4431     /* Get the TIMx CR2 register value */
;;;4432     tmpcr2 = TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4433     
;;;4434     /* Get the TIMx CCMR1 register value */
;;;4435     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4436       
;;;4437     /* Reset the Output Compare Mode Bits */
;;;4438     tmpccmrx &= ~TIM_CCMR1_OC1M;
;;;4439     tmpccmrx &= ~TIM_CCMR1_CC1S;
;;;4440     /* Select the Output Compare Mode */
;;;4441     tmpccmrx |= OC_Config->OCMode;
000010  680d              LDR      r5,[r1,#0]
000012  f0240473          BIC      r4,r4,#0x73           ;4439
000016  4325              ORRS     r5,r5,r4
;;;4442     
;;;4443     /* Reset the Output Polarity level */
;;;4444     tmpccer &= ~TIM_CCER_CC1P;
000018  f0220402          BIC      r4,r2,#2
;;;4445     /* Set the Output Compare Polarity */
;;;4446     tmpccer |= OC_Config->OCPolarity;
00001c  688a              LDR      r2,[r1,#8]
00001e  4322              ORRS     r2,r2,r4
;;;4447   
;;;4448       
;;;4449     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000020  4c0b              LDR      r4,|L95.80|
000022  42a0              CMP      r0,r4
000024  d002              BEQ      |L95.44|
000026  4c0b              LDR      r4,|L95.84|
000028  42a0              CMP      r0,r4
00002a  d10b              BNE      |L95.68|
                  |L95.44|
;;;4450     {   
;;;4451       /* Reset the Output N Polarity level */
;;;4452       tmpccer &= ~TIM_CCER_CC1NP;
00002c  f0220408          BIC      r4,r2,#8
;;;4453       /* Set the Output N Polarity */
;;;4454       tmpccer |= OC_Config->OCNPolarity;
000030  68ca              LDR      r2,[r1,#0xc]
;;;4455       /* Reset the Output N State */
;;;4456       tmpccer &= ~TIM_CCER_CC1NE;
;;;4457       
;;;4458       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4459       tmpcr2 &= ~TIM_CR2_OIS1;
;;;4460       tmpcr2 &= ~TIM_CR2_OIS1N;
000032  f4237340          BIC      r3,r3,#0x300
000036  4322              ORRS     r2,r2,r4              ;4454
;;;4461       /* Set the Output Idle state */
;;;4462       tmpcr2 |= OC_Config->OCIdleState;
000038  694c              LDR      r4,[r1,#0x14]
00003a  f0220204          BIC      r2,r2,#4              ;4456
00003e  431c              ORRS     r4,r4,r3
;;;4463       /* Set the Output N Idle state */
;;;4464       tmpcr2 |= OC_Config->OCNIdleState;
000040  698b              LDR      r3,[r1,#0x18]
000042  4323              ORRS     r3,r3,r4
                  |L95.68|
;;;4465     }
;;;4466     /* Write to TIMx CR2 */
;;;4467     TIMx->CR2 = tmpcr2;
000044  6043              STR      r3,[r0,#4]
;;;4468     
;;;4469     /* Write to TIMx CCMR1 */
;;;4470     TIMx->CCMR1 = tmpccmrx;
000046  6185              STR      r5,[r0,#0x18]
;;;4471     
;;;4472     /* Set the Capture Compare Register value */
;;;4473     TIMx->CCR1 = OC_Config->Pulse;
000048  6849              LDR      r1,[r1,#4]
00004a  6341              STR      r1,[r0,#0x34]
;;;4474     
;;;4475     /* Write to TIMx CCER */
;;;4476     TIMx->CCER = tmpccer;  
00004c  6202              STR      r2,[r0,#0x20]
;;;4477   } 
00004e  bd30              POP      {r4,r5,pc}
;;;4478   
                          ENDP

                  |L95.80|
                          DCD      0x40010000
                  |L95.84|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4484     */
;;;4485   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4486   {
;;;4487     uint32_t tmpccmrx = 0;
;;;4488     uint32_t tmpccer = 0;
;;;4489     uint32_t tmpcr2 = 0;
;;;4490      
;;;4491     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4492     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4493     
;;;4494     /* Get the TIMx CCER register value */  
;;;4495     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4496     /* Get the TIMx CR2 register value */
;;;4497     tmpcr2 = TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4498     
;;;4499     /* Get the TIMx CCMR1 register value */
;;;4500     tmpccmrx = TIMx->CCMR1;
00000e  6984              LDR      r4,[r0,#0x18]
;;;4501       
;;;4502     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4503     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;4504     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4505     
;;;4506     /* Select the Output Compare Mode */
;;;4507     tmpccmrx |= (OC_Config->OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42444e6          BIC      r4,r4,#0x7300         ;4504
000016  ea442405          ORR      r4,r4,r5,LSL #8
;;;4508     
;;;4509     /* Reset the Output Polarity level */
;;;4510     tmpccer &= ~TIM_CCER_CC2P;
;;;4511     /* Set the Output Compare Polarity */
;;;4512     tmpccer |= (OC_Config->OCPolarity << 4);
00001a  688d              LDR      r5,[r1,#8]
00001c  f0220220          BIC      r2,r2,#0x20           ;4510
000020  ea421205          ORR      r2,r2,r5,LSL #4
;;;4513       
;;;4514     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000024  4d0d              LDR      r5,|L96.92|
000026  42a8              CMP      r0,r5
000028  d002              BEQ      |L96.48|
00002a  4d0d              LDR      r5,|L96.96|
00002c  42a8              CMP      r0,r5
00002e  d10e              BNE      |L96.78|
                  |L96.48|
;;;4515     {
;;;4516       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4517       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4518       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4519       
;;;4520       /* Reset the Output N Polarity level */
;;;4521       tmpccer &= ~TIM_CCER_CC2NP;
;;;4522       /* Set the Output N Polarity */
;;;4523       tmpccer |= (OC_Config->OCNPolarity << 4);
000030  68cd              LDR      r5,[r1,#0xc]
000032  f0220280          BIC      r2,r2,#0x80           ;4521
000036  ea421205          ORR      r2,r2,r5,LSL #4
;;;4524       /* Reset the Output N State */
;;;4525       tmpccer &= ~TIM_CCER_CC2NE;
;;;4526       
;;;4527       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4528       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4529       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4530       /* Set the Output Idle state */
;;;4531       tmpcr2 |= (OC_Config->OCIdleState << 2);
00003a  694d              LDR      r5,[r1,#0x14]
00003c  f4236340          BIC      r3,r3,#0xc00          ;4529
000040  ea430385          ORR      r3,r3,r5,LSL #2
;;;4532       /* Set the Output N Idle state */
;;;4533       tmpcr2 |= (OC_Config->OCNIdleState << 2);
000044  698d              LDR      r5,[r1,#0x18]
000046  f0220240          BIC      r2,r2,#0x40           ;4525
00004a  ea430385          ORR      r3,r3,r5,LSL #2
                  |L96.78|
;;;4534     }
;;;4535     /* Write to TIMx CR2 */
;;;4536     TIMx->CR2 = tmpcr2;
00004e  6043              STR      r3,[r0,#4]
;;;4537     
;;;4538     /* Write to TIMx CCMR1 */
;;;4539     TIMx->CCMR1 = tmpccmrx;
000050  6184              STR      r4,[r0,#0x18]
;;;4540     
;;;4541     /* Set the Capture Compare Register value */
;;;4542     TIMx->CCR2 = OC_Config->Pulse;
000052  6849              LDR      r1,[r1,#4]
000054  6381              STR      r1,[r0,#0x38]
;;;4543     
;;;4544     /* Write to TIMx CCER */
;;;4545     TIMx->CCER = tmpccer;
000056  6202              STR      r2,[r0,#0x20]
;;;4546   }
000058  bd30              POP      {r4,r5,pc}
;;;4547   
                          ENDP

00005a  0000              DCW      0x0000
                  |L96.92|
                          DCD      0x40010000
                  |L96.96|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4553     */
;;;4554   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4555   {
;;;4556     uint32_t tmpccmrx = 0;
;;;4557     uint32_t tmpccer = 0;
;;;4558     uint32_t tmpcr2 = 0;   
;;;4559   
;;;4560     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4561     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  6202              STR      r2,[r0,#0x20]
;;;4562     
;;;4563     /* Get the TIMx CCER register value */
;;;4564     tmpccer = TIMx->CCER;
00000a  6a03              LDR      r3,[r0,#0x20]
;;;4565     /* Get the TIMx CR2 register value */
;;;4566     tmpcr2 = TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4567     
;;;4568     /* Get the TIMx CCMR2 register value */
;;;4569     tmpccmrx = TIMx->CCMR2;
00000e  69c4              LDR      r4,[r0,#0x1c]
;;;4570       
;;;4571     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4572     tmpccmrx &= ~TIM_CCMR2_OC3M;
;;;4573     tmpccmrx &= ~TIM_CCMR2_CC3S;  
;;;4574     /* Select the Output Compare Mode */
;;;4575     tmpccmrx |= OC_Config->OCMode;
;;;4576     
;;;4577     /* Reset the Output Polarity level */
;;;4578     tmpccer &= ~TIM_CCER_CC3P;
000010  f4237300          BIC      r3,r3,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;4573
000018  680c              LDR      r4,[r1,#0]            ;4575
00001a  432c              ORRS     r4,r4,r5              ;4575
;;;4579     /* Set the Output Compare Polarity */
;;;4580     tmpccer |= (OC_Config->OCPolarity << 8);
00001c  688d              LDR      r5,[r1,#8]
00001e  ea432305          ORR      r3,r3,r5,LSL #8
;;;4581       
;;;4582     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000022  4d0d              LDR      r5,|L97.88|
000024  42a8              CMP      r0,r5
000026  d002              BEQ      |L97.46|
000028  4d0c              LDR      r5,|L97.92|
00002a  42a8              CMP      r0,r5
00002c  d10e              BNE      |L97.76|
                  |L97.46|
;;;4583     {
;;;4584       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4585       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4586       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4587       
;;;4588       /* Reset the Output N Polarity level */
;;;4589       tmpccer &= ~TIM_CCER_CC3NP;
;;;4590       /* Set the Output N Polarity */
;;;4591       tmpccer |= (OC_Config->OCNPolarity << 8);
00002e  68cd              LDR      r5,[r1,#0xc]
000030  f4236300          BIC      r3,r3,#0x800          ;4589
000034  ea432305          ORR      r3,r3,r5,LSL #8
;;;4592       /* Reset the Output N State */
;;;4593       tmpccer &= ~TIM_CCER_CC3NE;
;;;4594       
;;;4595       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4596       tmpcr2 &= ~TIM_CR2_OIS3;
;;;4597       tmpcr2 &= ~TIM_CR2_OIS3N;
;;;4598       /* Set the Output Idle state */
;;;4599       tmpcr2 |= (OC_Config->OCIdleState << 4);
000038  694d              LDR      r5,[r1,#0x14]
00003a  f4225240          BIC      r2,r2,#0x3000         ;4597
00003e  ea421205          ORR      r2,r2,r5,LSL #4
;;;4600       /* Set the Output N Idle state */
;;;4601       tmpcr2 |= (OC_Config->OCNIdleState << 4);
000042  698d              LDR      r5,[r1,#0x18]
000044  f4236380          BIC      r3,r3,#0x400          ;4593
000048  ea421205          ORR      r2,r2,r5,LSL #4
                  |L97.76|
;;;4602     }
;;;4603     /* Write to TIMx CR2 */
;;;4604     TIMx->CR2 = tmpcr2;
00004c  6042              STR      r2,[r0,#4]
;;;4605     
;;;4606     /* Write to TIMx CCMR2 */
;;;4607     TIMx->CCMR2 = tmpccmrx;
00004e  61c4              STR      r4,[r0,#0x1c]
;;;4608     
;;;4609     /* Set the Capture Compare Register value */
;;;4610     TIMx->CCR3 = OC_Config->Pulse;
000050  6849              LDR      r1,[r1,#4]
000052  63c1              STR      r1,[r0,#0x3c]
;;;4611     
;;;4612     /* Write to TIMx CCER */
;;;4613     TIMx->CCER = tmpccer;
000054  6203              STR      r3,[r0,#0x20]
;;;4614   }
000056  bd30              POP      {r4,r5,pc}
;;;4615   
                          ENDP

                  |L97.88|
                          DCD      0x40010000
                  |L97.92|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4621     */
;;;4622   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;4623   {
;;;4624     uint32_t tmpccmrx = 0;
;;;4625     uint32_t tmpccer = 0;
;;;4626     uint32_t tmpcr2 = 0;
;;;4627   
;;;4628     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4629     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  6202              STR      r2,[r0,#0x20]
;;;4630     
;;;4631     /* Get the TIMx CCER register value */
;;;4632     tmpccer = TIMx->CCER;
00000a  6a04              LDR      r4,[r0,#0x20]
;;;4633     /* Get the TIMx CR2 register value */
;;;4634     tmpcr2 = TIMx->CR2;
00000c  6842              LDR      r2,[r0,#4]
;;;4635     
;;;4636     /* Get the TIMx CCMR2 register value */
;;;4637     tmpccmrx = TIMx->CCMR2;
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;4638       
;;;4639     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4640     tmpccmrx &= ~TIM_CCMR2_OC4M;
;;;4641     tmpccmrx &= ~TIM_CCMR2_CC4S;
;;;4642     
;;;4643     /* Select the Output Compare Mode */
;;;4644     tmpccmrx |= (OC_Config->OCMode << 8);
000010  680d              LDR      r5,[r1,#0]
000012  f42343e6          BIC      r3,r3,#0x7300         ;4641
000016  ea432305          ORR      r3,r3,r5,LSL #8
;;;4645     
;;;4646     /* Reset the Output Polarity level */
;;;4647     tmpccer &= ~TIM_CCER_CC4P;
;;;4648     /* Set the Output Compare Polarity */
;;;4649     tmpccer |= (OC_Config->OCPolarity << 12);
00001a  688d              LDR      r5,[r1,#8]
00001c  f4245400          BIC      r4,r4,#0x2000         ;4647
000020  ea443405          ORR      r4,r4,r5,LSL #12
;;;4650      
;;;4651     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;4652     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000024  4d08              LDR      r5,|L98.72|
000026  42a8              CMP      r0,r5
000028  d002              BEQ      |L98.48|
00002a  4d08              LDR      r5,|L98.76|
00002c  42a8              CMP      r0,r5
00002e  d104              BNE      |L98.58|
                  |L98.48|
;;;4653     {
;;;4654       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4655       /* Reset the Output Compare IDLE State */
;;;4656       tmpcr2 &= ~TIM_CR2_OIS4;
;;;4657       /* Set the Output Idle state */
;;;4658       tmpcr2 |= (OC_Config->OCIdleState << 6);
000030  694d              LDR      r5,[r1,#0x14]
000032  f4224280          BIC      r2,r2,#0x4000         ;4656
000036  ea421285          ORR      r2,r2,r5,LSL #6
                  |L98.58|
;;;4659     }
;;;4660     /* Write to TIMx CR2 */
;;;4661     TIMx->CR2 = tmpcr2;
00003a  6042              STR      r2,[r0,#4]
;;;4662     
;;;4663     /* Write to TIMx CCMR2 */  
;;;4664     TIMx->CCMR2 = tmpccmrx;
00003c  61c3              STR      r3,[r0,#0x1c]
;;;4665       
;;;4666     /* Set the Capture Compare Register value */
;;;4667     TIMx->CCR4 = OC_Config->Pulse;
00003e  6849              LDR      r1,[r1,#4]
000040  6401              STR      r1,[r0,#0x40]
;;;4668     
;;;4669     /* Write to TIMx CCER */
;;;4670     TIMx->CCER = tmpccer;
000042  6204              STR      r4,[r0,#0x20]
;;;4671   }
000044  bd30              POP      {r4,r5,pc}
;;;4672   
                          ENDP

000046  0000              DCW      0x0000
                  |L98.72|
                          DCD      0x40010000
                  |L98.76|
                          DCD      0x40010400

                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;4737     */
;;;4738   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;4739   {
;;;4740     uint32_t tmpccmr1 = 0;
;;;4741     uint32_t tmpccer = 0;
;;;4742     
;;;4743     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4744     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;4745     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
000006  f0240401          BIC      r4,r4,#1
00000a  6204              STR      r4,[r0,#0x20]
;;;4746     tmpccmr1 = TIMx->CCMR1;    
00000c  6984              LDR      r4,[r0,#0x18]
;;;4747     
;;;4748     /* Set the filter */
;;;4749     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00000e  f02404f0          BIC      r4,r4,#0xf0
;;;4750     tmpccmr1 |= (TIM_ICFilter << 4);
000012  ea441402          ORR      r4,r4,r2,LSL #4
;;;4751     
;;;4752     /* Select the Polarity and set the CC1E Bit */
;;;4753     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000016  f023020a          BIC      r2,r3,#0xa
;;;4754     tmpccer |= TIM_ICPolarity;
00001a  430a              ORRS     r2,r2,r1
;;;4755     
;;;4756     /* Write to TIMx CCMR1 and CCER registers */
;;;4757     TIMx->CCMR1 = tmpccmr1;
00001c  6184              STR      r4,[r0,#0x18]
;;;4758     TIMx->CCER = tmpccer;
00001e  6202              STR      r2,[r0,#0x20]
;;;4759   }
000020  bd10              POP      {r4,pc}
;;;4760   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;4689     */
;;;4690   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;4691                          uint32_t TIM_ICFilter)
;;;4692   {
;;;4693     uint32_t tmpccmr1 = 0;
;;;4694     uint32_t tmpccer = 0;
;;;4695     
;;;4696     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4697     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  6204              STR      r4,[r0,#0x20]
;;;4698     tmpccmr1 = TIMx->CCMR1;
00000a  6984              LDR      r4,[r0,#0x18]
;;;4699     tmpccer = TIMx->CCER;
00000c  6a05              LDR      r5,[r0,#0x20]
;;;4700   
;;;4701     /* Select the Input */
;;;4702     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
00000e  4e15              LDR      r6,|L100.100|
000010  42b0              CMP      r0,r6
000012  d014              BEQ      |L100.62|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d011              BEQ      |L100.62|
00001a  4e13              LDR      r6,|L100.104|
00001c  42b0              CMP      r0,r6
00001e  d00e              BEQ      |L100.62|
000020  4e12              LDR      r6,|L100.108|
000022  42b0              CMP      r0,r6
000024  d00b              BEQ      |L100.62|
000026  4e12              LDR      r6,|L100.112|
000028  42b0              CMP      r0,r6
00002a  d008              BEQ      |L100.62|
00002c  4e11              LDR      r6,|L100.116|
00002e  42b0              CMP      r0,r6
000030  d005              BEQ      |L100.62|
000032  4e11              LDR      r6,|L100.120|
000034  42b0              CMP      r0,r6
000036  d002              BEQ      |L100.62|
000038  4e10              LDR      r6,|L100.124|
00003a  42b0              CMP      r0,r6
00003c  d103              BNE      |L100.70|
                  |L100.62|
;;;4703     {
;;;4704       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00003e  f0240403          BIC      r4,r4,#3
;;;4705       tmpccmr1 |= TIM_ICSelection;
000042  4314              ORRS     r4,r4,r2
000044  e003              B        |L100.78|
                  |L100.70|
;;;4706     } 
;;;4707     else
;;;4708     {
;;;4709       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000046  f0240203          BIC      r2,r4,#3
;;;4710       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00004a  f0420401          ORR      r4,r2,#1
                  |L100.78|
;;;4711     }
;;;4712    
;;;4713     /* Set the filter */
;;;4714     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00004e  f02402f0          BIC      r2,r4,#0xf0
;;;4715     tmpccmr1 |= (TIM_ICFilter << 4);
000052  ea421303          ORR      r3,r2,r3,LSL #4
;;;4716   
;;;4717     /* Select the Polarity and set the CC1E Bit */
;;;4718     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000056  f025020a          BIC      r2,r5,#0xa
;;;4719     tmpccer |= TIM_ICPolarity;
00005a  430a              ORRS     r2,r2,r1
;;;4720   
;;;4721     /* Write to TIMx CCMR1 and CCER registers */
;;;4722     TIMx->CCMR1 = tmpccmr1;
00005c  6183              STR      r3,[r0,#0x18]
;;;4723     TIMx->CCER = tmpccer;
00005e  6202              STR      r2,[r0,#0x20]
;;;4724   }
000060  bd70              POP      {r4-r6,pc}
;;;4725   
                          ENDP

000062  0000              DCW      0x0000
                  |L100.100|
                          DCD      0x40010000
                  |L100.104|
                          DCD      0x40000400
                  |L100.108|
                          DCD      0x40000800
                  |L100.112|
                          DCD      0x40000c00
                  |L100.116|
                          DCD      0x40010400
                  |L100.120|
                          DCD      0x40014000
                  |L100.124|
                          DCD      0x40001800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;4817     */
;;;4818   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;4819   {
;;;4820     uint32_t tmpccmr1 = 0;
;;;4821     uint32_t tmpccer = 0;
;;;4822     
;;;4823     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4824     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;4825     tmpccmr1 = TIMx->CCMR1;
00000a  6983              LDR      r3,[r0,#0x18]
;;;4826     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;4827     
;;;4828     /* Set the filter */
;;;4829     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4234370          BIC      r3,r3,#0xf000
;;;4830     tmpccmr1 |= (TIM_ICFilter << 12);
000012  ea433202          ORR      r2,r3,r2,LSL #12
;;;4831   
;;;4832     /* Select the Polarity and set the CC2E Bit */
;;;4833     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000016  f02403a0          BIC      r3,r4,#0xa0
;;;4834     tmpccer |= (TIM_ICPolarity << 4);
00001a  ea431101          ORR      r1,r3,r1,LSL #4
;;;4835   
;;;4836     /* Write to TIMx CCMR1 and CCER registers */
;;;4837     TIMx->CCMR1 = tmpccmr1 ;
00001e  6182              STR      r2,[r0,#0x18]
;;;4838     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;4839   }
000022  bd10              POP      {r4,pc}
;;;4840   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;4777     */
;;;4778   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;4779                          uint32_t TIM_ICFilter)
;;;4780   {
;;;4781     uint32_t tmpccmr1 = 0;
;;;4782     uint32_t tmpccer = 0;
;;;4783   
;;;4784     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4785     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a04              LDR      r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  6204              STR      r4,[r0,#0x20]
;;;4786     tmpccmr1 = TIMx->CCMR1;
00000a  6985              LDR      r5,[r0,#0x18]
;;;4787     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;4788     
;;;4789     /* Select the Input */
;;;4790     tmpccmr1 &= ~TIM_CCMR1_CC2S;
00000e  f4257540          BIC      r5,r5,#0x300
;;;4791     tmpccmr1 |= (TIM_ICSelection << 8);
000012  ea452202          ORR      r2,r5,r2,LSL #8
;;;4792     
;;;4793     /* Set the filter */
;;;4794     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4224270          BIC      r2,r2,#0xf000
;;;4795     tmpccmr1 |= (TIM_ICFilter << 12);
00001a  ea423203          ORR      r2,r2,r3,LSL #12
;;;4796   
;;;4797     /* Select the Polarity and set the CC2E Bit */
;;;4798     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001e  f02403a0          BIC      r3,r4,#0xa0
;;;4799     tmpccer |= (TIM_ICPolarity << 4);
000022  ea431101          ORR      r1,r3,r1,LSL #4
;;;4800   
;;;4801     /* Write to TIMx CCMR1 and CCER registers */
;;;4802     TIMx->CCMR1 = tmpccmr1 ;
000026  6182              STR      r2,[r0,#0x18]
;;;4803     TIMx->CCER = tmpccer;
000028  6201              STR      r1,[r0,#0x20]
;;;4804   }
00002a  bd30              POP      {r4,r5,pc}
;;;4805   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_tim_c_a9d95b52____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_tim_c_a9d95b52____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_tim_c_a9d95b52____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
