; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_adc.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_adc.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_adc.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=2

                  ADC_DMAConvCplt PROC
;;;1226     */
;;;1227   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;1228   {
;;;1229     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;1230       
;;;1231     /* Check if an injected conversion is ready */
;;;1232     if(hadc->State == HAL_ADC_STATE_EOC_INJ)
000004  f890103d          LDRB     r1,[r0,#0x3d]
000008  2925              CMP      r1,#0x25
00000a  d006              BEQ      |L1.26|
;;;1233     {
;;;1234       /* Change ADC state */
;;;1235       hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;1236     }
;;;1237     else
;;;1238     {
;;;1239       /* Change ADC state */
;;;1240       hadc->State = HAL_ADC_STATE_EOC_REG;
00000c  f05f0115          MOVS.W   r1,#0x15
                  |L1.16|
000010  f880103d          STRB     r1,[r0,#0x3d]
;;;1241     }
;;;1242       
;;;1243       HAL_ADC_ConvCpltCallback(hadc); 
000014  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1244   }
000018  bd10              POP      {r4,pc}
                  |L1.26|
00001a  2135              MOVS     r1,#0x35              ;1235
00001c  e7f8              B        |L1.16|
;;;1245   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;1262     */
;;;1263   static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;1264   {
;;;1265       ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;1266       hadc->State= HAL_ADC_STATE_ERROR;
000004  2104              MOVS     r1,#4
000006  f880103d          STRB     r1,[r0,#0x3d]
;;;1267       /* Set ADC error code to DMA error */
;;;1268       hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
00000a  6c01              LDR      r1,[r0,#0x40]
00000c  f0410102          ORR      r1,r1,#2
000010  6401              STR      r1,[r0,#0x40]
;;;1269       HAL_ADC_ErrorCallback(hadc); 
000012  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;1270   }
000016  bd10              POP      {r4,pc}
;;;1271   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;1250     */
;;;1251   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;1252   {
;;;1253       ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;1254       /* Conversion complete callback */
;;;1255       HAL_ADC_ConvHalfCpltCallback(hadc); 
000004  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;1256   }
000008  bd10              POP      {r4,pc}
;;;1257   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;1159     */
;;;1160   static void ADC_Init(ADC_HandleTypeDef* hadc)
000000  4943              LDR      r1,|L4.272|
;;;1161   {
000002  b510              PUSH     {r4,lr}
;;;1162     
;;;1163     /* Set ADC parameters */
;;;1164     /* Set the ADC clock prescaler */
;;;1165     ADC->CCR &= ~(ADC_CCR_ADCPRE);
000004  f8d12304          LDR      r2,[r1,#0x304]
000008  f4223240          BIC      r2,r2,#0x30000
00000c  f8c12304          STR      r2,[r1,#0x304]
;;;1166     ADC->CCR |=  hadc->Init.ClockPrescaler;
000010  f8d12304          LDR      r2,[r1,#0x304]
000014  6843              LDR      r3,[r0,#4]
000016  431a              ORRS     r2,r2,r3
000018  f8c12304          STR      r2,[r1,#0x304]
;;;1167     
;;;1168     /* Set ADC scan mode */
;;;1169     hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
00001c  6801              LDR      r1,[r0,#0]
00001e  684a              LDR      r2,[r1,#4]
000020  f4227280          BIC      r2,r2,#0x100
000024  604a              STR      r2,[r1,#4]
;;;1170     hadc->Instance->CR1 |=  __HAL_ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  6903              LDR      r3,[r0,#0x10]
00002c  ea422203          ORR      r2,r2,r3,LSL #8
000030  604a              STR      r2,[r1,#4]
;;;1171     
;;;1172     /* Set ADC resolution */
;;;1173     hadc->Instance->CR1 &= ~(ADC_CR1_RES);
000032  6801              LDR      r1,[r0,#0]
000034  684a              LDR      r2,[r1,#4]
000036  f0227240          BIC      r2,r2,#0x3000000
00003a  604a              STR      r2,[r1,#4]
;;;1174     hadc->Instance->CR1 |=  hadc->Init.Resolution;
00003c  6801              LDR      r1,[r0,#0]
00003e  684a              LDR      r2,[r1,#4]
000040  6883              LDR      r3,[r0,#8]
000042  431a              ORRS     r2,r2,r3
000044  604a              STR      r2,[r1,#4]
;;;1175     
;;;1176     /* Set ADC data alignment */
;;;1177     hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
000046  6801              LDR      r1,[r0,#0]
000048  688a              LDR      r2,[r1,#8]
00004a  f4226200          BIC      r2,r2,#0x800
00004e  608a              STR      r2,[r1,#8]
;;;1178     hadc->Instance->CR2 |= hadc->Init.DataAlign;
000050  6801              LDR      r1,[r0,#0]
000052  688a              LDR      r2,[r1,#8]
000054  68c3              LDR      r3,[r0,#0xc]
000056  431a              ORRS     r2,r2,r3
000058  608a              STR      r2,[r1,#8]
;;;1179     
;;;1180     /* Select external trigger to start conversion */
;;;1181     hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
00005a  6801              LDR      r1,[r0,#0]
00005c  688a              LDR      r2,[r1,#8]
00005e  f0226270          BIC      r2,r2,#0xf000000
000062  608a              STR      r2,[r1,#8]
;;;1182     hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
000064  6801              LDR      r1,[r0,#0]
000066  688a              LDR      r2,[r1,#8]
000068  6b03              LDR      r3,[r0,#0x30]
00006a  431a              ORRS     r2,r2,r3
00006c  608a              STR      r2,[r1,#8]
;;;1183   
;;;1184     /* Select external trigger polarity */
;;;1185     hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
00006e  6801              LDR      r1,[r0,#0]
000070  688a              LDR      r2,[r1,#8]
000072  f0225240          BIC      r2,r2,#0x30000000
000076  608a              STR      r2,[r1,#8]
;;;1186     hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
000078  6801              LDR      r1,[r0,#0]
00007a  688a              LDR      r2,[r1,#8]
00007c  6ac3              LDR      r3,[r0,#0x2c]
00007e  431a              ORRS     r2,r2,r3
000080  608a              STR      r2,[r1,#8]
;;;1187     
;;;1188     /* Enable or disable ADC continuous conversion mode */
;;;1189     hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
000082  6801              LDR      r1,[r0,#0]
000084  688a              LDR      r2,[r1,#8]
000086  f0220202          BIC      r2,r2,#2
00008a  608a              STR      r2,[r1,#8]
;;;1190     hadc->Instance->CR2 |= __HAL_ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
00008c  6801              LDR      r1,[r0,#0]
00008e  688a              LDR      r2,[r1,#8]
000090  6983              LDR      r3,[r0,#0x18]
000092  ea420243          ORR      r2,r2,r3,LSL #1
000096  608a              STR      r2,[r1,#8]
;;;1191     
;;;1192     if (hadc->Init.DiscontinuousConvMode != DISABLE)
000098  6a41              LDR      r1,[r0,#0x24]
00009a  2900              CMP      r1,#0
;;;1193     {
;;;1194       assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;1195     
;;;1196       /* Enable the selected ADC regular discontinuous mode */
;;;1197       hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
;;;1198       
;;;1199       /* Set the number of channels to be converted in discontinuous mode */
;;;1200       hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
;;;1201       hadc->Instance->CR1 |=  __HAL_ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
;;;1202     }
;;;1203     else
;;;1204     {
;;;1205       /* Disable the selected ADC regular discontinuous mode */
;;;1206       hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
00009c  6801              LDR      r1,[r0,#0]
00009e  684a              LDR      r2,[r1,#4]
0000a0  d00f              BEQ      |L4.194|
0000a2  f4426200          ORR      r2,r2,#0x800          ;1197
0000a6  604a              STR      r2,[r1,#4]            ;1197
0000a8  6801              LDR      r1,[r0,#0]            ;1200
0000aa  684a              LDR      r2,[r1,#4]            ;1200
0000ac  f4224260          BIC      r2,r2,#0xe000         ;1200
0000b0  604a              STR      r2,[r1,#4]            ;1200
0000b2  6801              LDR      r1,[r0,#0]            ;1201
0000b4  684a              LDR      r2,[r1,#4]            ;1201
0000b6  4c17              LDR      r4,|L4.276|
0000b8  6a83              LDR      r3,[r0,#0x28]         ;1201
0000ba  eb043343          ADD      r3,r4,r3,LSL #13      ;1201
0000be  431a              ORRS     r2,r2,r3              ;1201
0000c0  e001              B        |L4.198|
                  |L4.194|
0000c2  f4226200          BIC      r2,r2,#0x800
                  |L4.198|
0000c6  604a              STR      r2,[r1,#4]
;;;1207     }
;;;1208     
;;;1209     /* Set ADC number of conversion */
;;;1210     hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
0000c8  6801              LDR      r1,[r0,#0]
0000ca  6aca              LDR      r2,[r1,#0x2c]
0000cc  f4220270          BIC      r2,r2,#0xf00000
0000d0  62ca              STR      r2,[r1,#0x2c]
;;;1211     hadc->Instance->SQR1 |=  __HAL_ADC_SQR1(hadc->Init.NbrOfConversion);
0000d2  6801              LDR      r1,[r0,#0]
0000d4  6aca              LDR      r2,[r1,#0x2c]
0000d6  8c03              LDRH     r3,[r0,#0x20]
0000d8  4c0f              LDR      r4,|L4.280|
0000da  eb045303          ADD      r3,r4,r3,LSL #20
0000de  431a              ORRS     r2,r2,r3
0000e0  62ca              STR      r2,[r1,#0x2c]
;;;1212     
;;;1213     /* Enable or disable ADC DMA continuous request */
;;;1214     hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
0000e2  6801              LDR      r1,[r0,#0]
0000e4  688a              LDR      r2,[r1,#8]
0000e6  f4227200          BIC      r2,r2,#0x200
0000ea  608a              STR      r2,[r1,#8]
;;;1215     hadc->Instance->CR2 |= __HAL_ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
0000ec  6801              LDR      r1,[r0,#0]
0000ee  688a              LDR      r2,[r1,#8]
0000f0  69c3              LDR      r3,[r0,#0x1c]
0000f2  ea422243          ORR      r2,r2,r3,LSL #9
0000f6  608a              STR      r2,[r1,#8]
;;;1216     
;;;1217     /* Enable or disable ADC end of conversion selection */
;;;1218     hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
0000f8  6801              LDR      r1,[r0,#0]
0000fa  688a              LDR      r2,[r1,#8]
0000fc  f4226280          BIC      r2,r2,#0x400
000100  608a              STR      r2,[r1,#8]
;;;1219     hadc->Instance->CR2 |= __HAL_ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
000102  6801              LDR      r1,[r0,#0]
000104  688a              LDR      r2,[r1,#8]
000106  6940              LDR      r0,[r0,#0x14]
000108  ea422080          ORR      r0,r2,r0,LSL #10
00010c  6088              STR      r0,[r1,#8]
;;;1220   }
00010e  bd10              POP      {r4,pc}
;;;1221   
                          ENDP

                  |L4.272|
                          DCD      0x40012000
                  |L4.276|
                          DCD      0xffffe000
                  |L4.280|
                          DCD      0xfff00000

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1049     */
;;;1050   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  b510              PUSH     {r4,lr}
;;;1051   {
;;;1052   #ifdef USE_FULL_ASSERT  
;;;1053     uint32_t tmp = 0;
;;;1054   #endif /* USE_FULL_ASSERT  */  
;;;1055     
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode));
;;;1058     assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
;;;1059     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1060   
;;;1061   #ifdef USE_FULL_ASSERT  
;;;1062     tmp = __HAL_ADC_GET_RESOLUTION(hadc);
;;;1063     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
;;;1064     assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
;;;1065   #endif /* USE_FULL_ASSERT  */
;;;1066     
;;;1067     /* Process locked */
;;;1068     __HAL_LOCK(hadc);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d029              BEQ      |L5.94|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;1069     
;;;1070     if(AnalogWDGConfig->ITMode == ENABLE)
000010  690a              LDR      r2,[r1,#0x10]
000012  2a01              CMP      r2,#1
;;;1071     {
;;;1072       /* Enable the ADC Analog watchdog interrupt */
;;;1073       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1074     }
;;;1075     else
;;;1076     {
;;;1077       /* Disable the ADC Analog watchdog interrupt */
;;;1078       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
000014  6802              LDR      r2,[r0,#0]
000016  6853              LDR      r3,[r2,#4]
000018  d023              BEQ      |L5.98|
00001a  f0230340          BIC      r3,r3,#0x40
                  |L5.30|
00001e  6053              STR      r3,[r2,#4]
;;;1079     }
;;;1080     
;;;1081     /* Clear AWDEN, JAWDEN and AWDSGL bits */
;;;1082     hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
000020  6802              LDR      r2,[r0,#0]
000022  6853              LDR      r3,[r2,#4]
000024  4c10              LDR      r4,|L5.104|
000026  4023              ANDS     r3,r3,r4
000028  6053              STR      r3,[r2,#4]
;;;1083     
;;;1084     /* Set the analog watchdog enable mode */
;;;1085     hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
00002a  6802              LDR      r2,[r0,#0]
00002c  6853              LDR      r3,[r2,#4]
00002e  680c              LDR      r4,[r1,#0]
000030  4323              ORRS     r3,r3,r4
000032  6053              STR      r3,[r2,#4]
;;;1086     
;;;1087     /* Set the high threshold */
;;;1088     hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
000034  6803              LDR      r3,[r0,#0]
000036  684a              LDR      r2,[r1,#4]
000038  625a              STR      r2,[r3,#0x24]
;;;1089     
;;;1090     /* Set the low threshold */
;;;1091     hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
00003a  6803              LDR      r3,[r0,#0]
00003c  688a              LDR      r2,[r1,#8]
00003e  629a              STR      r2,[r3,#0x28]
;;;1092     
;;;1093     /* Clear the Analog watchdog channel select bits */
;;;1094     hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
000040  6802              LDR      r2,[r0,#0]
000042  6853              LDR      r3,[r2,#4]
000044  f023031f          BIC      r3,r3,#0x1f
000048  6053              STR      r3,[r2,#4]
;;;1095     
;;;1096     /* Set the Analog watchdog channel */
;;;1097     hadc->Instance->CR1 |= AnalogWDGConfig->Channel;
00004a  6802              LDR      r2,[r0,#0]
00004c  6853              LDR      r3,[r2,#4]
00004e  68c9              LDR      r1,[r1,#0xc]
000050  430b              ORRS     r3,r3,r1
000052  6053              STR      r3,[r2,#4]
;;;1098     
;;;1099     /* Process unlocked */
;;;1100     __HAL_UNLOCK(hadc);
000054  2100              MOVS     r1,#0
000056  f880103c          STRB     r1,[r0,#0x3c]
;;;1101     
;;;1102     /* Return function status */
;;;1103     return HAL_OK;
00005a  4608              MOV      r0,r1
;;;1104   }
00005c  bd10              POP      {r4,pc}
                  |L5.94|
00005e  2002              MOVS     r0,#2                 ;1068
000060  bd10              POP      {r4,pc}
                  |L5.98|
000062  f0430340          ORR      r3,r3,#0x40           ;1073
000066  e7da              B        |L5.30|
;;;1105   
                          ENDP

                  |L5.104|
                          DCD      0xff3ffdff

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;964      */
;;;965    HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;966    {
;;;967      /* Check the parameters */
;;;968      assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;969      assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;970      assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;971      
;;;972      /* Process locked */
;;;973      __HAL_LOCK(hadc);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d019              BEQ      |L6.62|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;974        
;;;975      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;976      if (sConfig->Channel > ADC_CHANNEL_9)
000010  680a              LDR      r2,[r1,#0]
;;;977      {
;;;978        /* Clear the old sample time */
;;;979        hadc->Instance->SMPR1 &= ~__HAL_ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
000012  2307              MOVS     r3,#7
000014  6804              LDR      r4,[r0,#0]            ;973
000016  2a09              CMP      r2,#9                 ;976
000018  d913              BLS      |L6.66|
00001a  68e5              LDR      r5,[r4,#0xc]
00001c  3a0a              SUBS     r2,r2,#0xa
00001e  eb020242          ADD      r2,r2,r2,LSL #1
000022  4093              LSLS     r3,r3,r2
000024  439d              BICS     r5,r5,r3
000026  60e5              STR      r5,[r4,#0xc]
;;;980        
;;;981        /* Set the new sample time */
;;;982        hadc->Instance->SMPR1 |= __HAL_ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
000028  780a              LDRB     r2,[r1,#0]
00002a  688b              LDR      r3,[r1,#8]
00002c  3a0a              SUBS     r2,r2,#0xa
00002e  eb020242          ADD      r2,r2,r2,LSL #1
000032  4093              LSLS     r3,r3,r2
000034  6802              LDR      r2,[r0,#0]
000036  68d4              LDR      r4,[r2,#0xc]
000038  4323              ORRS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
00003c  e010              B        |L6.96|
                  |L6.62|
00003e  2002              MOVS     r0,#2                 ;973
;;;983      }
;;;984      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;985      {
;;;986        /* Clear the old sample time */
;;;987        hadc->Instance->SMPR2 &= ~__HAL_ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
;;;988        
;;;989        /* Set the new sample time */
;;;990        hadc->Instance->SMPR2 |= __HAL_ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
;;;991      }
;;;992      
;;;993      /* For Rank 1 to 6 */
;;;994      if (sConfig->Rank < 7)
;;;995      {
;;;996        /* Clear the old SQx bits for the selected rank */
;;;997        hadc->Instance->SQR3 &= ~__HAL_ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
;;;998        
;;;999        /* Set the SQx bits for the selected rank */
;;;1000       hadc->Instance->SQR3 |= __HAL_ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
;;;1001     }
;;;1002     /* For Rank 7 to 12 */
;;;1003     else if (sConfig->Rank < 13)
;;;1004     {
;;;1005       /* Clear the old SQx bits for the selected rank */
;;;1006       hadc->Instance->SQR2 &= ~__HAL_ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
;;;1007       
;;;1008       /* Set the SQx bits for the selected rank */
;;;1009       hadc->Instance->SQR2 |= __HAL_ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
;;;1010     }
;;;1011     /* For Rank 13 to 16 */
;;;1012     else
;;;1013     {
;;;1014       /* Clear the old SQx bits for the selected rank */
;;;1015       hadc->Instance->SQR1 &= ~__HAL_ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
;;;1016       
;;;1017       /* Set the SQx bits for the selected rank */
;;;1018       hadc->Instance->SQR1 |= __HAL_ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
;;;1019     }
;;;1020     
;;;1021     /* if ADC1 Channel_18 is selected enable VBAT Channel */
;;;1022     if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
;;;1023     {
;;;1024       /* Enable the VBAT channel*/
;;;1025       ADC->CCR |= ADC_CCR_VBATE;
;;;1026     }
;;;1027     
;;;1028     /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
;;;1029     if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
;;;1030     {
;;;1031       /* Enable the TSVREFE channel*/
;;;1032       ADC->CCR |= ADC_CCR_TSVREFE;
;;;1033     }
;;;1034     
;;;1035     /* Process unlocked */
;;;1036     __HAL_UNLOCK(hadc);
;;;1037     
;;;1038     /* Return function status */
;;;1039     return HAL_OK;
;;;1040   }
000040  bd30              POP      {r4,r5,pc}
                  |L6.66|
000042  6925              LDR      r5,[r4,#0x10]         ;987
000044  eb020242          ADD      r2,r2,r2,LSL #1       ;987
000048  4093              LSLS     r3,r3,r2              ;987
00004a  439d              BICS     r5,r5,r3              ;987
00004c  6125              STR      r5,[r4,#0x10]         ;987
00004e  780a              LDRB     r2,[r1,#0]            ;990
000050  688b              LDR      r3,[r1,#8]            ;990
000052  eb020242          ADD      r2,r2,r2,LSL #1       ;990
000056  4093              LSLS     r3,r3,r2              ;990
000058  6802              LDR      r2,[r0,#0]            ;990
00005a  6914              LDR      r4,[r2,#0x10]         ;990
00005c  4323              ORRS     r3,r3,r4              ;990
00005e  6113              STR      r3,[r2,#0x10]         ;990
                  |L6.96|
000060  684a              LDR      r2,[r1,#4]            ;994
000062  231f              MOVS     r3,#0x1f              ;997
000064  2a07              CMP      r2,#7                 ;994
000066  d212              BCS      |L6.142|
000068  6804              LDR      r4,[r0,#0]            ;997
00006a  6b65              LDR      r5,[r4,#0x34]         ;997
00006c  1e52              SUBS     r2,r2,#1              ;997
00006e  eb020282          ADD      r2,r2,r2,LSL #2       ;997
000072  4093              LSLS     r3,r3,r2              ;997
000074  439d              BICS     r5,r5,r3              ;997
000076  6365              STR      r5,[r4,#0x34]         ;997
000078  790a              LDRB     r2,[r1,#4]            ;1000
00007a  680b              LDR      r3,[r1,#0]            ;1000
00007c  1e52              SUBS     r2,r2,#1              ;1000
00007e  eb020282          ADD      r2,r2,r2,LSL #2       ;1000
000082  4093              LSLS     r3,r3,r2              ;1000
000084  6802              LDR      r2,[r0,#0]            ;1000
000086  6b54              LDR      r4,[r2,#0x34]         ;1000
000088  4323              ORRS     r3,r3,r4              ;1000
00008a  6353              STR      r3,[r2,#0x34]         ;1000
00008c  e025              B        |L6.218|
                  |L6.142|
00008e  6804              LDR      r4,[r0,#0]            ;1003
000090  2a0d              CMP      r2,#0xd               ;1003
000092  d211              BCS      |L6.184|
000094  6b25              LDR      r5,[r4,#0x30]         ;1006
000096  1fd2              SUBS     r2,r2,#7              ;1006
000098  eb020282          ADD      r2,r2,r2,LSL #2       ;1006
00009c  4093              LSLS     r3,r3,r2              ;1006
00009e  439d              BICS     r5,r5,r3              ;1006
0000a0  6325              STR      r5,[r4,#0x30]         ;1006
0000a2  790b              LDRB     r3,[r1,#4]            ;1009
0000a4  680a              LDR      r2,[r1,#0]            ;1009
0000a6  1fdb              SUBS     r3,r3,#7              ;1009
0000a8  eb030383          ADD      r3,r3,r3,LSL #2       ;1009
0000ac  409a              LSLS     r2,r2,r3              ;1009
0000ae  6803              LDR      r3,[r0,#0]            ;1009
0000b0  6b1c              LDR      r4,[r3,#0x30]         ;1009
0000b2  4322              ORRS     r2,r2,r4              ;1009
0000b4  631a              STR      r2,[r3,#0x30]         ;1009
0000b6  e010              B        |L6.218|
                  |L6.184|
0000b8  6ae5              LDR      r5,[r4,#0x2c]         ;1015
0000ba  3a0d              SUBS     r2,r2,#0xd            ;1015
0000bc  eb020282          ADD      r2,r2,r2,LSL #2       ;1015
0000c0  4093              LSLS     r3,r3,r2              ;1015
0000c2  439d              BICS     r5,r5,r3              ;1015
0000c4  62e5              STR      r5,[r4,#0x2c]         ;1015
0000c6  790b              LDRB     r3,[r1,#4]            ;1018
0000c8  680a              LDR      r2,[r1,#0]            ;1018
0000ca  3b0d              SUBS     r3,r3,#0xd            ;1018
0000cc  eb030383          ADD      r3,r3,r3,LSL #2       ;1018
0000d0  409a              LSLS     r2,r2,r3              ;1018
0000d2  6803              LDR      r3,[r0,#0]            ;1018
0000d4  6adc              LDR      r4,[r3,#0x2c]         ;1018
0000d6  4322              ORRS     r2,r2,r4              ;1018
0000d8  62da              STR      r2,[r3,#0x2c]         ;1018
                  |L6.218|
0000da  4a10              LDR      r2,|L6.284|
0000dc  6803              LDR      r3,[r0,#0]            ;1022
0000de  4293              CMP      r3,r2                 ;1022
0000e0  d108              BNE      |L6.244|
0000e2  680b              LDR      r3,[r1,#0]            ;1022
0000e4  2b12              CMP      r3,#0x12              ;1022
0000e6  d105              BNE      |L6.244|
0000e8  f8d23304          LDR      r3,[r2,#0x304]        ;1025
0000ec  f4430380          ORR      r3,r3,#0x400000       ;1025
0000f0  f8c23304          STR      r3,[r2,#0x304]        ;1025
                  |L6.244|
0000f4  6803              LDR      r3,[r0,#0]            ;1029
0000f6  4293              CMP      r3,r2                 ;1029
0000f8  d10a              BNE      |L6.272|
0000fa  6809              LDR      r1,[r1,#0]            ;1029
0000fc  2910              CMP      r1,#0x10              ;1029
0000fe  d001              BEQ      |L6.260|
000100  2911              CMP      r1,#0x11              ;1029
000102  d105              BNE      |L6.272|
                  |L6.260|
000104  f8d21304          LDR      r1,[r2,#0x304]        ;1032
000108  f4410100          ORR      r1,r1,#0x800000       ;1032
00010c  f8c21304          STR      r1,[r2,#0x304]        ;1032
                  |L6.272|
000110  2100              MOVS     r1,#0                 ;1036
000112  f880103c          STRB     r1,[r0,#0x3c]         ;1036
000116  4608              MOV      r0,r1                 ;1039
000118  bd30              POP      {r4,r5,pc}
;;;1041   
                          ENDP

00011a  0000              DCW      0x0000
                  |L6.284|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;889      */
;;;890    __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;891    {
;;;892      /* NOTE : This function Should not be modified, when the callback is needed,
;;;893                the HAL_ADC_ConvCpltCallback could be implemented in the user file
;;;894       */
;;;895    }
;;;896    
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;902      */
;;;903    __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;904    {
;;;905      /* NOTE : This function Should not be modified, when the callback is needed,
;;;906                the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
;;;907       */
;;;908    }
;;;909    
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_DeInit PROC
;;;258      */
;;;259    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;260    {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L9.28|
;;;261      /* Check ADC handle */
;;;262      if(hadc == NULL)
;;;263      {
;;;264         return HAL_ERROR;
;;;265      } 
;;;266      
;;;267      /* Check the parameters */
;;;268      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;269      
;;;270      /* Change ADC state */
;;;271      hadc->State = HAL_ADC_STATE_BUSY;
000006  2002              MOVS     r0,#2
000008  f884003d          STRB     r0,[r4,#0x3d]
;;;272      
;;;273      /* DeInit the low level hardware */
;;;274      HAL_ADC_MspDeInit(hadc);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_ADC_MspDeInit
;;;275      
;;;276      /* Set ADC error code to none */
;;;277      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
000012  2000              MOVS     r0,#0
000014  6420              STR      r0,[r4,#0x40]
;;;278      
;;;279      /* Change ADC state */
;;;280      hadc->State = HAL_ADC_STATE_RESET;
000016  f884003d          STRB     r0,[r4,#0x3d]
;;;281      
;;;282      /* Return function status */
;;;283      return HAL_OK;
;;;284    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  2001              MOVS     r0,#1                 ;264
00001e  bd10              POP      {r4,pc}
;;;285    
                          ENDP


                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;928      */
;;;929    __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;930    {
;;;931      /* NOTE : This function Should not be modified, when the callback is needed,
;;;932                the HAL_ADC_ErrorCallback could be implemented in the user file
;;;933       */
;;;934    }
;;;935    
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1143     */
;;;1144   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  6c00              LDR      r0,[r0,#0x40]
;;;1145   {
;;;1146     return hadc->ErrorCode;
;;;1147   }
000002  4770              BX       lr
;;;1148   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1131     */
;;;1132   HAL_ADC_StateTypeDef HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  f890003d          LDRB     r0,[r0,#0x3d]
;;;1133   {
;;;1134     /* Return ADC state */
;;;1135     return hadc->State;
;;;1136   }
000004  4770              BX       lr
;;;1137   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;877      */
;;;878    uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  6800              LDR      r0,[r0,#0]
;;;879    {       
;;;880      /* Return the selected ADC converted value */ 
;;;881      return hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;882    }
000004  4770              BX       lr
;;;883    
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;645      */
;;;646    void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;647    {
000002  4604              MOV      r4,r0
;;;648      uint32_t tmp1 = 0, tmp2 = 0;
;;;649      
;;;650      /* Check the parameters */
;;;651      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;652      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;653      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;654      
;;;655      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
000004  6800              LDR      r0,[r0,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f3c10240          UBFX     r2,r1,#1,#1
;;;656      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
00000c  6841              LDR      r1,[r0,#4]
;;;657      /* Check End of conversion flag for regular channels */
;;;658      if(tmp1 && tmp2)
;;;659      {
;;;660        /* Check if an injected conversion is ready */
;;;661        if(hadc->State == HAL_ADC_STATE_EOC_INJ)
;;;662        {
;;;663          /* Change ADC state */
;;;664          hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
00000e  2535              MOVS     r5,#0x35
000010  f3c11140          UBFX     r1,r1,#5,#1           ;656
000014  b35a              CBZ      r2,|L14.110|
000016  b351              CBZ      r1,|L14.110|
000018  f894103d          LDRB     r1,[r4,#0x3d]         ;661
00001c  2925              CMP      r1,#0x25              ;661
00001e  d005              BEQ      |L14.44|
;;;665        }
;;;666        else
;;;667        {
;;;668          /* Change ADC state */
;;;669          hadc->State = HAL_ADC_STATE_EOC_REG;
000020  2115              MOVS     r1,#0x15
000022  f884103d          STRB     r1,[r4,#0x3d]
                  |L14.38|
;;;670        }
;;;671      
;;;672        if((hadc->Init.ContinuousConvMode == DISABLE) && (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
000026  69a1              LDR      r1,[r4,#0x18]
000028  b119              CBZ      r1,|L14.50|
00002a  e018              B        |L14.94|
                  |L14.44|
00002c  f884503d          STRB     r5,[r4,#0x3d]         ;664
000030  e7f9              B        |L14.38|
                  |L14.50|
000032  6ae1              LDR      r1,[r4,#0x2c]
000034  b999              CBNZ     r1,|L14.94|
;;;673        {
;;;674          if(hadc->Init.EOCSelection == EOC_SEQ_CONV)
000036  6961              LDR      r1,[r4,#0x14]
000038  b141              CBZ      r1,|L14.76|
;;;675          {   
;;;676            /* DISABLE the ADC end of conversion interrupt for regular group */
;;;677            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
;;;678            
;;;679            /* DISABLE the ADC overrun interrupt */
;;;680            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;681          }
;;;682          else
;;;683          {
;;;684            if (hadc->NbrOfCurrentConversionRank == 0)
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  b909              CBNZ     r1,|L14.66|
;;;685            {
;;;686              hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
00003e  6a21              LDR      r1,[r4,#0x20]
000040  6361              STR      r1,[r4,#0x34]
                  |L14.66|
;;;687            }
;;;688            
;;;689            /* Decrement the number of conversion when an interrupt occurs */
;;;690            hadc->NbrOfCurrentConversionRank--;
000042  6b61              LDR      r1,[r4,#0x34]
000044  1e49              SUBS     r1,r1,#1
000046  6361              STR      r1,[r4,#0x34]
;;;691            
;;;692            /* Check if all conversions are finished */
;;;693            if(hadc->NbrOfCurrentConversionRank == 0)
000048  6b61              LDR      r1,[r4,#0x34]
00004a  b941              CBNZ     r1,|L14.94|
                  |L14.76|
;;;694            {
;;;695              /* DISABLE the ADC end of conversion interrupt for regular group */
;;;696              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
00004c  6841              LDR      r1,[r0,#4]
00004e  f0210120          BIC      r1,r1,#0x20
000052  6041              STR      r1,[r0,#4]
;;;697              
;;;698              /* DISABLE the ADC overrun interrupt */
;;;699              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
000054  6820              LDR      r0,[r4,#0]
000056  6841              LDR      r1,[r0,#4]
000058  f0216180          BIC      r1,r1,#0x4000000
00005c  6041              STR      r1,[r0,#4]
                  |L14.94|
;;;700            }
;;;701          }
;;;702        }
;;;703        
;;;704        /* Conversion complete callback */ 
;;;705        HAL_ADC_ConvCpltCallback(hadc);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;706        
;;;707       /* Clear the ADCx flag for regular end of conversion */
;;;708        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
000064  6820              LDR      r0,[r4,#0]
000066  6801              LDR      r1,[r0,#0]
000068  f0210102          BIC      r1,r1,#2
00006c  6001              STR      r1,[r0,#0]
                  |L14.110|
;;;709      }
;;;710      
;;;711      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
00006e  6820              LDR      r0,[r4,#0]
000070  6801              LDR      r1,[r0,#0]
;;;712      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
000072  6842              LDR      r2,[r0,#4]
000074  f3c10180          UBFX     r1,r1,#2,#1           ;711
000078  f3c212c0          UBFX     r2,r2,#7,#1
;;;713      /* Check End of conversion flag for injected channels */
;;;714      if(tmp1 && tmp2)
00007c  b301              CBZ      r1,|L14.192|
00007e  b1fa              CBZ      r2,|L14.192|
;;;715      {
;;;716        /* Check if a regular conversion is ready */
;;;717        if(hadc->State == HAL_ADC_STATE_EOC_REG)
000080  f894103d          LDRB     r1,[r4,#0x3d]
000084  2915              CMP      r1,#0x15
000086  d048              BEQ      |L14.282|
;;;718        {
;;;719          /* Change ADC state */
;;;720          hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;721        }
;;;722        else
;;;723        {
;;;724          /* Change ADC state */
;;;725          hadc->State = HAL_ADC_STATE_EOC_INJ;
000088  2125              MOVS     r1,#0x25
00008a  f884103d          STRB     r1,[r4,#0x3d]
                  |L14.142|
;;;726        }
;;;727        
;;;728        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
00008e  6841              LDR      r1,[r0,#4]
;;;729        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
000090  6882              LDR      r2,[r0,#8]
000092  f3412180          SBFX     r1,r1,#10,#1          ;728
000096  1c49              ADDS     r1,r1,#1
000098  f4121f40          TST      r2,#0x300000
00009c  d040              BEQ      |L14.288|
00009e  2200              MOVS     r2,#0
                  |L14.160|
;;;730        if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
0000a0  69a3              LDR      r3,[r4,#0x18]
0000a2  b103              CBZ      r3,|L14.166|
0000a4  b121              CBZ      r1,|L14.176|
                  |L14.166|
0000a6  b11a              CBZ      r2,|L14.176|
;;;731        {
;;;732          /* DISABLE the ADC end of conversion interrupt for injected group */
;;;733          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
0000a8  6841              LDR      r1,[r0,#4]
0000aa  f0210180          BIC      r1,r1,#0x80
0000ae  6041              STR      r1,[r0,#4]
                  |L14.176|
;;;734        }
;;;735        
;;;736        /* Conversion complete callback */ 
;;;737        HAL_ADCEx_InjectedConvCpltCallback(hadc);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;738        
;;;739       /* Clear the ADCx flag for injected end of conversion */
;;;740        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6801              LDR      r1,[r0,#0]
0000ba  f0210104          BIC      r1,r1,#4
0000be  6001              STR      r1,[r0,#0]
                  |L14.192|
;;;741      }
;;;742      
;;;743      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6801              LDR      r1,[r0,#0]
;;;744      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
0000c4  6842              LDR      r2,[r0,#4]
0000c6  f0110f01          TST      r1,#1                 ;743
0000ca  f3c21280          UBFX     r2,r2,#6,#1
;;;745      /* Check Analog watchdog flag */
;;;746      if(tmp1 && tmp2)
0000ce  d00a              BEQ      |L14.230|
0000d0  b14a              CBZ      r2,|L14.230|
;;;747      {
;;;748        /* Change ADC state */
;;;749        hadc->State = HAL_ADC_STATE_AWD;
0000d2  2106              MOVS     r1,#6
0000d4  f884103d          STRB     r1,[r4,#0x3d]
;;;750          
;;;751        /* Clear the ADCx's Analog watchdog flag */
;;;752        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
0000d8  6801              LDR      r1,[r0,#0]
0000da  f0210101          BIC      r1,r1,#1
0000de  6001              STR      r1,[r0,#0]
;;;753        
;;;754        /* Level out of window callback */ 
;;;755        HAL_ADC_LevelOutOfWindowCallback(hadc);
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
                  |L14.230|
;;;756      }
;;;757      
;;;758      tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
0000e6  6820              LDR      r0,[r4,#0]
0000e8  6801              LDR      r1,[r0,#0]
;;;759      tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
0000ea  6842              LDR      r2,[r0,#4]
0000ec  f3c11140          UBFX     r1,r1,#5,#1           ;758
0000f0  f3c26280          UBFX     r2,r2,#26,#1
;;;760      /* Check Overrun flag */
;;;761      if(tmp1 && tmp2)
0000f4  2900              CMP      r1,#0
0000f6  d00f              BEQ      |L14.280|
0000f8  2a00              CMP      r2,#0
0000fa  d00d              BEQ      |L14.280|
;;;762      {
;;;763        /* Change ADC state to overrun state */
;;;764        hadc->State = HAL_ADC_STATE_ERROR;
0000fc  2104              MOVS     r1,#4
0000fe  f884103d          STRB     r1,[r4,#0x3d]
;;;765        
;;;766        /* Set ADC error code to overrun */
;;;767        hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
000102  6c21              LDR      r1,[r4,#0x40]
000104  f0410101          ORR      r1,r1,#1
000108  6421              STR      r1,[r4,#0x40]
;;;768        
;;;769        /* Clear the Overrun flag */
;;;770        __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
00010a  6801              LDR      r1,[r0,#0]
00010c  f0210120          BIC      r1,r1,#0x20
000110  6001              STR      r1,[r0,#0]
;;;771        
;;;772        /* Error callback */ 
;;;773        HAL_ADC_ErrorCallback(hadc);
000112  4620              MOV      r0,r4
000114  f7fffffe          BL       HAL_ADC_ErrorCallback
                  |L14.280|
;;;774      }
;;;775    }
000118  bd70              POP      {r4-r6,pc}
                  |L14.282|
00011a  f884503d          STRB     r5,[r4,#0x3d]         ;720
00011e  e7b6              B        |L14.142|
                  |L14.288|
000120  2201              MOVS     r2,#1                 ;729
000122  e7bd              B        |L14.160|
;;;776    
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L15.14|
;;;208      /* Check ADC handle */
;;;209      if(hadc == NULL)
;;;210      {
;;;211         return HAL_ERROR;
;;;212      }
;;;213      
;;;214      /* Check the parameters */
;;;215      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;216      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;217      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;218      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ScanConvMode));
;;;219      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;220      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;221      assert_param(IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv));
;;;222      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;223      assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
;;;224      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;225      assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
;;;226      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;227      
;;;228      if(hadc->State == HAL_ADC_STATE_RESET)
000006  f894003d          LDRB     r0,[r4,#0x3d]
00000a  b110              CBZ      r0,|L15.18|
00000c  e004              B        |L15.24|
                  |L15.14|
00000e  2001              MOVS     r0,#1                 ;211
;;;229      {
;;;230        /* Init the low level hardware */
;;;231        HAL_ADC_MspInit(hadc);
;;;232      }
;;;233      
;;;234      /* Initialize the ADC state */
;;;235      hadc->State = HAL_ADC_STATE_BUSY;
;;;236      
;;;237      /* Set ADC parameters */
;;;238      ADC_Init(hadc);
;;;239      
;;;240      /* Set ADC error code to none */
;;;241      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
;;;242      
;;;243      /* Initialize the ADC state */
;;;244      hadc->State = HAL_ADC_STATE_READY;
;;;245    
;;;246      /* Release Lock */
;;;247      __HAL_UNLOCK(hadc);
;;;248    
;;;249      /* Return function status */
;;;250      return HAL_OK;
;;;251    }
000010  bd10              POP      {r4,pc}
                  |L15.18|
000012  4620              MOV      r0,r4                 ;231
000014  f7fffffe          BL       HAL_ADC_MspInit
                  |L15.24|
000018  2002              MOVS     r0,#2                 ;235
00001a  f884003d          STRB     r0,[r4,#0x3d]         ;235
00001e  4620              MOV      r0,r4                 ;238
000020  f7fffffe          BL       ADC_Init
000024  2000              MOVS     r0,#0                 ;241
000026  6420              STR      r0,[r4,#0x40]         ;241
000028  2101              MOVS     r1,#1                 ;244
00002a  f884103d          STRB     r1,[r4,#0x3d]         ;244
00002e  f884003c          STRB     r0,[r4,#0x3c]         ;247
000032  bd10              POP      {r4,pc}
;;;252    
                          ENDP


                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;915      */
;;;916    __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;917    {
;;;918      /* NOTE : This function Should not be modified, when the callback is needed,
;;;919                the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
;;;920       */
;;;921    }
;;;922    
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;304      */
;;;305    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;306    {
;;;307      /* NOTE : This function Should not be modified, when the callback is needed,
;;;308                the HAL_ADC_MspDeInit could be implemented in the user file
;;;309       */ 
;;;310    }
;;;311    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;291      */
;;;292    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;293    {
;;;294      /* NOTE : This function Should not be modified, when the callback is needed,
;;;295                the HAL_ADC_MspInit could be implemented in the user file
;;;296       */ 
;;;297    }
;;;298    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForConversion PROC
;;;434      */
;;;435    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;437      uint32_t timeout;
;;;438     
;;;439      /* Get timeout */
;;;440      timeout = HAL_GetTick() + Timeout;  
000006  f7fffffe          BL       HAL_GetTick
00000a  1946              ADDS     r6,r0,r5
;;;441    
;;;442      /* Check End of conversion flag */
;;;443      while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
00000c  e00d              B        |L19.42|
                  |L19.14|
;;;444      {
;;;445        /* Check for the Timeout */
;;;446        if(Timeout != HAL_MAX_DELAY)
00000e  1c68              ADDS     r0,r5,#1
000010  d00b              BEQ      |L19.42|
;;;447        {
;;;448          if(HAL_GetTick() >= timeout)
000012  f7fffffe          BL       HAL_GetTick
000016  42b0              CMP      r0,r6
000018  d307              BCC      |L19.42|
;;;449          {
;;;450            hadc->State= HAL_ADC_STATE_TIMEOUT;
00001a  2003              MOVS     r0,#3
00001c  f884003d          STRB     r0,[r4,#0x3d]
;;;451            /* Process unlocked */
;;;452            __HAL_UNLOCK(hadc);
000020  2000              MOVS     r0,#0
000022  f884003c          STRB     r0,[r4,#0x3c]
;;;453            return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
;;;454          }
;;;455        }
;;;456      }
;;;457      
;;;458      /* Check if an injected conversion is ready */
;;;459      if(hadc->State == HAL_ADC_STATE_EOC_INJ)
;;;460      {
;;;461        /* Change ADC state */
;;;462        hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;463      }
;;;464      else
;;;465      {
;;;466        /* Change ADC state */
;;;467        hadc->State = HAL_ADC_STATE_EOC_REG;
;;;468      }
;;;469      
;;;470      /* Return ADC state */
;;;471      return HAL_OK;
;;;472    }
000028  bd70              POP      {r4-r6,pc}
                  |L19.42|
00002a  6820              LDR      r0,[r4,#0]            ;443
00002c  6800              LDR      r0,[r0,#0]            ;443
00002e  0780              LSLS     r0,r0,#30             ;443
000030  d5ed              BPL      |L19.14|
000032  f894003d          LDRB     r0,[r4,#0x3d]         ;459
000036  2825              CMP      r0,#0x25              ;459
000038  d004              BEQ      |L19.68|
00003a  2015              MOVS     r0,#0x15              ;467
                  |L19.60|
00003c  f884003d          STRB     r0,[r4,#0x3d]         ;467
000040  2000              MOVS     r0,#0                 ;471
000042  bd70              POP      {r4-r6,pc}
                  |L19.68|
000044  2035              MOVS     r0,#0x35              ;462
000046  e7f9              B        |L19.60|
;;;473    
                          ENDP


                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;484      */
;;;485    HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;486    {
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;487      /* Check the parameters */
;;;488      assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;489      
;;;490      uint32_t timeout; 
;;;491    
;;;492      /* Get timeout */
;;;493      timeout = HAL_GetTick() + Timeout;   
00000a  f7fffffe          BL       HAL_GetTick
00000e  1987              ADDS     r7,r0,r6
;;;494    
;;;495      /* Check selected event flag */
;;;496      while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
000010  e00e              B        |L20.48|
                  |L20.18|
;;;497      {
;;;498        /* Check for the Timeout */
;;;499        if(Timeout != HAL_MAX_DELAY)
000012  1c70              ADDS     r0,r6,#1
000014  d00c              BEQ      |L20.48|
;;;500        {
;;;501          if(HAL_GetTick() >= timeout)
000016  f7fffffe          BL       HAL_GetTick
00001a  42b8              CMP      r0,r7
00001c  d308              BCC      |L20.48|
;;;502          {
;;;503            hadc->State= HAL_ADC_STATE_TIMEOUT;
00001e  2003              MOVS     r0,#3
000020  f884003d          STRB     r0,[r4,#0x3d]
;;;504            /* Process unlocked */
;;;505            __HAL_UNLOCK(hadc);
000024  2000              MOVS     r0,#0
000026  f884003c          STRB     r0,[r4,#0x3c]
;;;506            return HAL_TIMEOUT;
00002a  2003              MOVS     r0,#3
                  |L20.44|
;;;507          }
;;;508        }
;;;509      }
;;;510      
;;;511      /* Check analog watchdog flag */
;;;512      if(EventType == AWD_EVENT)
;;;513      {
;;;514         /* Change ADC state */
;;;515         hadc->State = HAL_ADC_STATE_AWD;
;;;516          
;;;517         /* Clear the ADCx's analog watchdog flag */
;;;518         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;519      }
;;;520      else
;;;521      {
;;;522         /* Change ADC state */
;;;523         hadc->State = HAL_ADC_STATE_ERROR;
;;;524         
;;;525         /* Clear the ADCx's Overrun flag */
;;;526         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;527      }
;;;528      
;;;529      /* Return ADC state */
;;;530      return HAL_OK;
;;;531    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L20.48|
000030  6820              LDR      r0,[r4,#0]            ;496
000032  6800              LDR      r0,[r0,#0]            ;496
000034  ea350000          BICS     r0,r5,r0              ;496
000038  d1eb              BNE      |L20.18|
00003a  2d01              CMP      r5,#1                 ;512
00003c  d009              BEQ      |L20.82|
00003e  2004              MOVS     r0,#4                 ;523
000040  f884003d          STRB     r0,[r4,#0x3d]         ;523
000044  6820              LDR      r0,[r4,#0]            ;526
000046  6801              LDR      r1,[r0,#0]            ;526
000048  f0210120          BIC      r1,r1,#0x20           ;526
                  |L20.76|
00004c  6001              STR      r1,[r0,#0]            ;526
00004e  2000              MOVS     r0,#0                 ;530
000050  e7ec              B        |L20.44|
                  |L20.82|
000052  2006              MOVS     r0,#6                 ;515
000054  f884003d          STRB     r0,[r4,#0x3d]         ;515
000058  6820              LDR      r0,[r4,#0]            ;518
00005a  6801              LDR      r1,[r0,#0]            ;518
00005c  f0210101          BIC      r1,r1,#1              ;518
000060  e7f4              B        |L20.76|
;;;532    
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;341      */
;;;342    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  f890203c          LDRB     r2,[r0,#0x3c]
;;;343    {
;;;344      uint16_t i = 0;
000004  2100              MOVS     r1,#0
;;;345      
;;;346      /* Check the parameters */
;;;347      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;348      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
;;;349      
;;;350      /* Process locked */
;;;351      __HAL_LOCK(hadc);
000006  2a01              CMP      r2,#1
000008  d00f              BEQ      |L21.42|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;352      
;;;353      /* Check if an injected conversion is ongoing */
;;;354      if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
000010  f890203d          LDRB     r2,[r0,#0x3d]
000014  2a22              CMP      r2,#0x22
000016  d00a              BEQ      |L21.46|
;;;355      {
;;;356        /* Change ADC state */
;;;357        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;358      }
;;;359      else
;;;360      {
;;;361        /* Change ADC state */
;;;362        hadc->State = HAL_ADC_STATE_BUSY_REG;
000018  f05f0212          MOVS.W   r2,#0x12
                  |L21.28|
00001c  f880203d          STRB     r2,[r0,#0x3d]
;;;363      } 
;;;364        
;;;365      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;366         Tstab time the ADC's stabilization */
;;;367      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
000020  6802              LDR      r2,[r0,#0]
000022  6893              LDR      r3,[r2,#8]
000024  07db              LSLS     r3,r3,#31
000026  d004              BEQ      |L21.50|
000028  e00e              B        |L21.72|
                  |L21.42|
00002a  2002              MOVS     r0,#2                 ;351
;;;368      {  
;;;369        /* Enable the Peripheral */
;;;370        __HAL_ADC_ENABLE(hadc);
;;;371        
;;;372        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;373        for(; i <= 540; i++)
;;;374        {
;;;375          __NOP();
;;;376        }
;;;377      }
;;;378    
;;;379      /* Check if Multimode enabled */
;;;380      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;381      {
;;;382        /* if no external trigger present enable software conversion of regular channels */
;;;383        if(hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE)
;;;384        {
;;;385          /* Enable the selected ADC software conversion for regular group */
;;;386          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;387        }
;;;388      }
;;;389      else
;;;390      {
;;;391        /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;392        if((hadc->Instance == ADC1) && (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
;;;393        {
;;;394          /* Enable the selected ADC software conversion for regular group */
;;;395            hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;396        }
;;;397      }
;;;398      
;;;399      /* Process unlocked */
;;;400      __HAL_UNLOCK(hadc);
;;;401      
;;;402      /* Return function status */
;;;403      return HAL_OK;
;;;404    }
00002c  4770              BX       lr
                  |L21.46|
00002e  2232              MOVS     r2,#0x32              ;357
000030  e7f4              B        |L21.28|
                  |L21.50|
000032  6893              LDR      r3,[r2,#8]            ;370
000034  f0430301          ORR      r3,r3,#1              ;370
000038  6093              STR      r3,[r2,#8]            ;370
00003a  f44f7207          MOV      r2,#0x21c             ;373
                  |L21.62|
00003e  bf00              NOP                            ;375
000040  1c49              ADDS     r1,r1,#1              ;375
000042  b289              UXTH     r1,r1                 ;373
000044  4291              CMP      r1,r2                 ;373
000046  d9fa              BLS      |L21.62|
                  |L21.72|
000048  4a0b              LDR      r2,|L21.120|
00004a  f8d21304          LDR      r1,[r2,#0x304]        ;380
00004e  06c9              LSLS     r1,r1,#27             ;380
000050  d005              BEQ      |L21.94|
000052  6801              LDR      r1,[r0,#0]            ;392
000054  4291              CMP      r1,r2                 ;392
000056  d109              BNE      |L21.108|
000058  6ac2              LDR      r2,[r0,#0x2c]         ;392
00005a  b11a              CBZ      r2,|L21.100|
00005c  e006              B        |L21.108|
                  |L21.94|
00005e  6ac1              LDR      r1,[r0,#0x2c]         ;383
000060  b921              CBNZ     r1,|L21.108|
000062  6801              LDR      r1,[r0,#0]            ;386
                  |L21.100|
000064  688a              LDR      r2,[r1,#8]            ;395
000066  f0424280          ORR      r2,r2,#0x40000000     ;395
00006a  608a              STR      r2,[r1,#8]            ;395
                  |L21.108|
00006c  2100              MOVS     r1,#0                 ;400
00006e  f880103c          STRB     r1,[r0,#0x3c]         ;400
000072  4608              MOV      r0,r1                 ;403
000074  4770              BX       lr
;;;405    
                          ENDP

000076  0000              DCW      0x0000
                  |L21.120|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;784      */
;;;785    HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;786    {
000002  4604              MOV      r4,r0
;;;787      uint16_t i = 0;
;;;788      
;;;789      /* Check the parameters */
;;;790      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;791      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;792      
;;;793      /* Process locked */
;;;794      __HAL_LOCK(hadc);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2500              MOVS     r5,#0                 ;787
00000a  460e              MOV      r6,r1                 ;786
00000c  2801              CMP      r0,#1
00000e  d024              BEQ      |L22.90|
000010  2001              MOVS     r0,#1
000012  f884003c          STRB     r0,[r4,#0x3c]
;;;795      
;;;796      /* Enable ADC overrun interrupt */
;;;797      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
000016  6820              LDR      r0,[r4,#0]
000018  6841              LDR      r1,[r0,#4]
00001a  f0416180          ORR      r1,r1,#0x4000000
00001e  6041              STR      r1,[r0,#4]
;;;798      
;;;799      /* Enable ADC DMA mode */
;;;800      hadc->Instance->CR2 |= ADC_CR2_DMA;
000020  6820              LDR      r0,[r4,#0]
000022  6881              LDR      r1,[r0,#8]
000024  f4417180          ORR      r1,r1,#0x100
000028  6081              STR      r1,[r0,#8]
;;;801      
;;;802      /* Set the DMA transfer complete callback */
;;;803      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
00002a  6ba1              LDR      r1,[r4,#0x38]
00002c  4817              LDR      r0,|L22.140|
;;;804      
;;;805      /* Set the DMA half transfer complete callback */
;;;806      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;807         
;;;808      /* Set the DMA error callback */
;;;809      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError ;
;;;810      
;;;811      /* Enable the DMA Stream */
;;;812      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
00002e  4613              MOV      r3,r2
000030  63c8              STR      r0,[r1,#0x3c]         ;806
000032  6ba1              LDR      r1,[r4,#0x38]         ;806
000034  4816              LDR      r0,|L22.144|
000036  4632              MOV      r2,r6
000038  6408              STR      r0,[r1,#0x40]         ;809
00003a  6ba1              LDR      r1,[r4,#0x38]         ;809
00003c  4815              LDR      r0,|L22.148|
00003e  6488              STR      r0,[r1,#0x48]
000040  6821              LDR      r1,[r4,#0]
000042  6ba0              LDR      r0,[r4,#0x38]
000044  314c              ADDS     r1,r1,#0x4c
000046  f7fffffe          BL       HAL_DMA_Start_IT
;;;813      
;;;814      /* Change ADC state */
;;;815      hadc->State = HAL_ADC_STATE_BUSY_REG;
00004a  2012              MOVS     r0,#0x12
00004c  f884003d          STRB     r0,[r4,#0x3d]
;;;816       
;;;817      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;818         Tstab time the ADC's stabilization */
;;;819      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
000050  6820              LDR      r0,[r4,#0]
000052  6881              LDR      r1,[r0,#8]
000054  07c9              LSLS     r1,r1,#31
000056  d002              BEQ      |L22.94|
000058  e00c              B        |L22.116|
                  |L22.90|
00005a  2002              MOVS     r0,#2                 ;794
;;;820      {  
;;;821        /* Enable the Peripheral */
;;;822        __HAL_ADC_ENABLE(hadc);
;;;823        
;;;824        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;825        for(; i <= 540; i++)
;;;826        {
;;;827          __NOP();
;;;828        }
;;;829      }
;;;830      
;;;831      /* if no external trigger present enable software conversion of regular channels */
;;;832      if (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE)
;;;833      {
;;;834        /* Enable the selected ADC software conversion for regular group */
;;;835        hadc->Instance->CR2 |= ADC_CR2_SWSTART;
;;;836      }
;;;837      
;;;838      /* Process unlocked */
;;;839      __HAL_UNLOCK(hadc);
;;;840      
;;;841      /* Return function status */
;;;842      return HAL_OK;
;;;843    }
00005c  bd70              POP      {r4-r6,pc}
                  |L22.94|
00005e  6881              LDR      r1,[r0,#8]            ;822
000060  f0410101          ORR      r1,r1,#1              ;822
000064  6081              STR      r1,[r0,#8]            ;822
000066  f44f7007          MOV      r0,#0x21c             ;825
                  |L22.106|
00006a  bf00              NOP                            ;827
00006c  1c6d              ADDS     r5,r5,#1              ;827
00006e  b2ad              UXTH     r5,r5                 ;825
000070  4285              CMP      r5,r0                 ;825
000072  d9fa              BLS      |L22.106|
                  |L22.116|
000074  6ae0              LDR      r0,[r4,#0x2c]         ;832
000076  b920              CBNZ     r0,|L22.130|
000078  6820              LDR      r0,[r4,#0]            ;835
00007a  6881              LDR      r1,[r0,#8]            ;835
00007c  f0414180          ORR      r1,r1,#0x40000000     ;835
000080  6081              STR      r1,[r0,#8]            ;835
                  |L22.130|
000082  2000              MOVS     r0,#0                 ;839
000084  f884003c          STRB     r0,[r4,#0x3c]         ;839
000088  bd70              POP      {r4-r6,pc}
;;;844    
                          ENDP

00008a  0000              DCW      0x0000
                  |L22.140|
                          DCD      ADC_DMAConvCplt
                  |L22.144|
                          DCD      ADC_DMAHalfConvCplt
                  |L22.148|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;539      */
;;;540    HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;541    {
;;;542      uint16_t i = 0;
;;;543      
;;;544      /* Check the parameters */
;;;545      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;546      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;547      
;;;548      /* Process locked */
;;;549      __HAL_LOCK(hadc);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2100              MOVS     r1,#0                 ;542
000008  2a01              CMP      r2,#1
00000a  d010              BEQ      |L23.46|
00000c  2201              MOVS     r2,#1
00000e  f880203c          STRB     r2,[r0,#0x3c]
;;;550      
;;;551      /* Check if an injected conversion is ongoing */
;;;552      if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
000012  f890203d          LDRB     r2,[r0,#0x3d]
000016  2a22              CMP      r2,#0x22
000018  d00b              BEQ      |L23.50|
;;;553      {
;;;554        /* Change ADC state */
;;;555        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Change ADC state */
;;;560        hadc->State = HAL_ADC_STATE_BUSY_REG;
00001a  2212              MOVS     r2,#0x12
                  |L23.28|
00001c  f880203d          STRB     r2,[r0,#0x3d]
;;;561      } 
;;;562      
;;;563      /* Set ADC error code to none */
;;;564      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
000020  2300              MOVS     r3,#0
000022  6403              STR      r3,[r0,#0x40]
;;;565      
;;;566      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;567         Tstab time the ADC's stabilization */
;;;568      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
000024  6802              LDR      r2,[r0,#0]
000026  6894              LDR      r4,[r2,#8]
000028  07e4              LSLS     r4,r4,#31
00002a  d004              BEQ      |L23.54|
00002c  e00e              B        |L23.76|
                  |L23.46|
00002e  2002              MOVS     r0,#2                 ;549
;;;569      {  
;;;570        /* Enable the Peripheral */
;;;571        __HAL_ADC_ENABLE(hadc);
;;;572        
;;;573        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;574        for(; i <= 540; i++)
;;;575        {
;;;576          __NOP();
;;;577        }
;;;578      }
;;;579      
;;;580      /* Enable the ADC overrun interrupt */
;;;581      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;582      
;;;583      /* Enable the ADC end of conversion interrupt for regular group */
;;;584      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;585      
;;;586      /* Check if Multimode enabled */
;;;587      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;588      {
;;;589        /* if no externel trigger present enable software conversion of regular channels */
;;;590        if (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE)
;;;591        {
;;;592          /* Enable the selected ADC software conversion for regular group */
;;;593          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;594        }
;;;595      }
;;;596      else
;;;597      {
;;;598        /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;599        if ((hadc->Instance == (ADC_TypeDef*)0x40012000) && (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
;;;600        {
;;;601          /* Enable the selected ADC software conversion for regular group */
;;;602            hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;603        }
;;;604      }
;;;605      
;;;606      /* Process unlocked */
;;;607      __HAL_UNLOCK(hadc);
;;;608      
;;;609      /* Return function status */
;;;610      return HAL_OK;
;;;611    }
000030  bd10              POP      {r4,pc}
                  |L23.50|
000032  2232              MOVS     r2,#0x32              ;555
000034  e7f2              B        |L23.28|
                  |L23.54|
000036  6894              LDR      r4,[r2,#8]            ;571
000038  f0440401          ORR      r4,r4,#1              ;571
00003c  6094              STR      r4,[r2,#8]            ;571
00003e  f44f7207          MOV      r2,#0x21c             ;574
                  |L23.66|
000042  bf00              NOP                            ;576
000044  1c49              ADDS     r1,r1,#1              ;576
000046  b289              UXTH     r1,r1                 ;574
000048  4291              CMP      r1,r2                 ;574
00004a  d9fa              BLS      |L23.66|
                  |L23.76|
00004c  6801              LDR      r1,[r0,#0]            ;581
00004e  684a              LDR      r2,[r1,#4]            ;581
000050  f0426280          ORR      r2,r2,#0x4000000      ;581
000054  604a              STR      r2,[r1,#4]            ;581
000056  6801              LDR      r1,[r0,#0]            ;584
000058  684a              LDR      r2,[r1,#4]            ;584
00005a  f0420220          ORR      r2,r2,#0x20           ;584
00005e  604a              STR      r2,[r1,#4]            ;584
000060  4a0a              LDR      r2,|L23.140|
000062  f8d21304          LDR      r1,[r2,#0x304]        ;587
000066  06c9              LSLS     r1,r1,#27             ;587
000068  d005              BEQ      |L23.118|
00006a  6801              LDR      r1,[r0,#0]            ;599
00006c  4291              CMP      r1,r2                 ;599
00006e  d109              BNE      |L23.132|
000070  6ac2              LDR      r2,[r0,#0x2c]         ;599
000072  b11a              CBZ      r2,|L23.124|
000074  e006              B        |L23.132|
                  |L23.118|
000076  6ac1              LDR      r1,[r0,#0x2c]         ;590
000078  b921              CBNZ     r1,|L23.132|
00007a  6801              LDR      r1,[r0,#0]            ;593
                  |L23.124|
00007c  688a              LDR      r2,[r1,#8]            ;602
00007e  f0424280          ORR      r2,r2,#0x40000000     ;602
000082  608a              STR      r2,[r1,#8]            ;602
                  |L23.132|
000084  f880303c          STRB     r3,[r0,#0x3c]         ;607
000088  2000              MOVS     r0,#0                 ;610
00008a  bd10              POP      {r4,pc}
;;;612    
                          ENDP

                  |L23.140|
                          DCD      0x40012000

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;415      */
;;;416    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  6801              LDR      r1,[r0,#0]
;;;417    {
;;;418      /* Disable the Peripheral */
;;;419      __HAL_ADC_DISABLE(hadc);
000002  688a              LDR      r2,[r1,#8]
000004  f0220201          BIC      r2,r2,#1
000008  608a              STR      r2,[r1,#8]
;;;420      
;;;421      /* Change ADC state */
;;;422      hadc->State = HAL_ADC_STATE_READY;
00000a  2101              MOVS     r1,#1
00000c  f880103d          STRB     r1,[r0,#0x3d]
;;;423      
;;;424      /* Return function status */
;;;425      return HAL_OK;
000010  2000              MOVS     r0,#0
;;;426    }
000012  4770              BX       lr
;;;427    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;850      */
;;;851    HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;852    {
000002  4604              MOV      r4,r0
;;;853      /* Disable the Periphral */
;;;854      __HAL_ADC_DISABLE(hadc);
000004  6800              LDR      r0,[r0,#0]
000006  6881              LDR      r1,[r0,#8]
000008  f0210101          BIC      r1,r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;855      
;;;856      /* Disable ADC overrun interrupt */
;;;857      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
00000e  6820              LDR      r0,[r4,#0]
000010  6841              LDR      r1,[r0,#4]
000012  f0216180          BIC      r1,r1,#0x4000000
000016  6041              STR      r1,[r0,#4]
;;;858      
;;;859      /* Disable the selected ADC DMA mode */
;;;860      hadc->Instance->CR2 &= ~ADC_CR2_DMA;
000018  6820              LDR      r0,[r4,#0]
00001a  6881              LDR      r1,[r0,#8]
00001c  f4217180          BIC      r1,r1,#0x100
000020  6081              STR      r1,[r0,#8]
;;;861      
;;;862      /* Disable the ADC DMA Stream */
;;;863      HAL_DMA_Abort(hadc->DMA_Handle);
000022  6ba0              LDR      r0,[r4,#0x38]
000024  f7fffffe          BL       HAL_DMA_Abort
;;;864      
;;;865      /* Change ADC state */
;;;866      hadc->State = HAL_ADC_STATE_READY;
000028  2001              MOVS     r0,#1
00002a  f884003d          STRB     r0,[r4,#0x3d]
;;;867      
;;;868      /* Return function status */
;;;869      return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;870    }
000030  bd10              POP      {r4,pc}
;;;871    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;621      */
;;;622    HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  6801              LDR      r1,[r0,#0]
;;;623    {
;;;624      /* Disable the ADC end of conversion interrupt for regular group */
;;;625      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000002  684a              LDR      r2,[r1,#4]
000004  f0220220          BIC      r2,r2,#0x20
000008  604a              STR      r2,[r1,#4]
;;;626      
;;;627      /* Disable the ADC end of conversion interrupt for injected group */
;;;628      __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  684a              LDR      r2,[r1,#4]
00000e  f0220280          BIC      r2,r2,#0x80
000012  604a              STR      r2,[r1,#4]
;;;629      
;;;630      /* Enable the Periphral */
;;;631      __HAL_ADC_DISABLE(hadc);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  f0220201          BIC      r2,r2,#1
00001c  608a              STR      r2,[r1,#8]
;;;632      
;;;633      /* Change ADC state */
;;;634      hadc->State = HAL_ADC_STATE_READY;
00001e  2101              MOVS     r1,#1
000020  f880103d          STRB     r1,[r0,#0x3d]
;;;635      
;;;636      /* Return function status */
;;;637      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;638    }
000026  4770              BX       lr
;;;639    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_adc_c_52ef8f50____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_adc_c_52ef8f50____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_adc_c_52ef8f50____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
