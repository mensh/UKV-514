; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_adc_ex.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_adc_ex.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_adc_ex.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_adc_ex.c]
                          THUMB

                          AREA ||i.ADC_MultiModeDMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_MultiModeDMAConvCplt PROC
;;;779      */
;;;780    static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma)   
000000  6b80              LDR      r0,[r0,#0x38]
;;;781    {
;;;782        ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;783        
;;;784      /* Check if an injected conversion is ready */
;;;785      if(hadc->State == HAL_ADC_STATE_EOC_INJ)
000002  f890103d          LDRB     r1,[r0,#0x3d]
000006  2925              CMP      r1,#0x25
000008  d004              BEQ      |L1.20|
;;;786      {
;;;787        /* Change ADC state */
;;;788        hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;789      }
;;;790      else
;;;791      {
;;;792        /* Change ADC state */
;;;793        hadc->State = HAL_ADC_STATE_EOC_REG;
00000a  2115              MOVS     r1,#0x15
                  |L1.12|
00000c  f880103d          STRB     r1,[r0,#0x3d]
;;;794      }
;;;795        
;;;796        HAL_ADC_ConvCpltCallback(hadc); 
000010  f7ffbffe          B.W      HAL_ADC_ConvCpltCallback
                  |L1.20|
000014  2135              MOVS     r1,#0x35              ;788
000016  e7f9              B        |L1.12|
;;;797    }
;;;798    
                          ENDP


                          AREA ||i.ADC_MultiModeDMAError||, CODE, READONLY, ALIGN=1

                  ADC_MultiModeDMAError PROC
;;;815      */
;;;816    static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma)   
000000  6b80              LDR      r0,[r0,#0x38]
;;;817    {
;;;818        ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;819        hadc->State= HAL_ADC_STATE_ERROR;
000002  2104              MOVS     r1,#4
000004  f880103d          STRB     r1,[r0,#0x3d]
;;;820        /* Set ADC error code to DMA error */
;;;821        hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
000008  6c01              LDR      r1,[r0,#0x40]
00000a  f0410102          ORR      r1,r1,#2
00000e  6401              STR      r1,[r0,#0x40]
;;;822        HAL_ADC_ErrorCallback(hadc); 
000010  f7ffbffe          B.W      HAL_ADC_ErrorCallback
;;;823    }
;;;824    
                          ENDP


                          AREA ||i.ADC_MultiModeDMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_MultiModeDMAHalfConvCplt PROC
;;;803      */
;;;804    static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  6b80              LDR      r0,[r0,#0x38]
;;;805    {
;;;806        ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;807        /* Conversion complete callback */
;;;808        HAL_ADC_ConvHalfCpltCallback(hadc); 
000002  f7ffbffe          B.W      HAL_ADC_ConvHalfCpltCallback
;;;809    }
;;;810    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedConfigChannel PROC
;;;603      */
;;;604    HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
000000  b530              PUSH     {r4,r5,lr}
;;;605    {
;;;606      
;;;607    #ifdef USE_FULL_ASSERT  
;;;608      uint32_t tmp = 0;
;;;609    #endif /* USE_FULL_ASSERT  */
;;;610      
;;;611      /* Check the parameters */
;;;612      assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
;;;613      assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
;;;614      assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
;;;615      assert_param(IS_ADC_EXT_INJEC_TRIG(sConfigInjected->ExternalTrigInjecConv));
;;;616      assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
;;;617      assert_param(IS_ADC_INJECTED_LENGTH(sConfigInjected->InjectedNbrOfConversion));
;;;618      assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
;;;619      assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
;;;620    
;;;621    #ifdef USE_FULL_ASSERT
;;;622      tmp = __HAL_ADC_GET_RESOLUTION(hadc);
;;;623      assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
;;;624    #endif /* USE_FULL_ASSERT  */
;;;625    
;;;626      /* Process locked */
;;;627      __HAL_LOCK(hadc);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d019              BEQ      |L4.62|
00000a  2201              MOVS     r2,#1
00000c  f880203c          STRB     r2,[r0,#0x3c]
;;;628      
;;;629      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;630      if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
000010  680a              LDR      r2,[r1,#0]
;;;631      {
;;;632        /* Clear the old sample time */
;;;633        hadc->Instance->SMPR1 &= ~__HAL_ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
000012  2307              MOVS     r3,#7
000014  6804              LDR      r4,[r0,#0]            ;627
000016  2a09              CMP      r2,#9                 ;630
000018  d913              BLS      |L4.66|
00001a  68e5              LDR      r5,[r4,#0xc]
00001c  3a0a              SUBS     r2,r2,#0xa
00001e  eb020242          ADD      r2,r2,r2,LSL #1
000022  4093              LSLS     r3,r3,r2
000024  439d              BICS     r5,r5,r3
000026  60e5              STR      r5,[r4,#0xc]
;;;634        
;;;635        /* Set the new sample time */
;;;636        hadc->Instance->SMPR1 |= __HAL_ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
000028  780a              LDRB     r2,[r1,#0]
00002a  688b              LDR      r3,[r1,#8]
00002c  3a0a              SUBS     r2,r2,#0xa
00002e  eb020242          ADD      r2,r2,r2,LSL #1
000032  4093              LSLS     r3,r3,r2
000034  6802              LDR      r2,[r0,#0]
000036  68d4              LDR      r4,[r2,#0xc]
000038  4323              ORRS     r3,r3,r4
00003a  60d3              STR      r3,[r2,#0xc]
00003c  e010              B        |L4.96|
                  |L4.62|
00003e  2002              MOVS     r0,#2                 ;627
;;;637      }
;;;638      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;639      {
;;;640        /* Clear the old sample time */
;;;641        hadc->Instance->SMPR2 &= ~__HAL_ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
;;;642        
;;;643        /* Set the new sample time */
;;;644        hadc->Instance->SMPR2 |= __HAL_ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
;;;645      }
;;;646      
;;;647      /*---------------------------- ADCx JSQR Configuration -----------------*/
;;;648      hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
;;;649      hadc->Instance->JSQR |=  __HAL_ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
;;;650      
;;;651      /* Rank configuration */
;;;652      
;;;653      /* Clear the old SQx bits for the selected rank */
;;;654      hadc->Instance->JSQR &= ~__HAL_ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
;;;655       
;;;656      /* Set the SQx bits for the selected rank */
;;;657      hadc->Instance->JSQR |= __HAL_ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
;;;658    
;;;659      /* Select external trigger to start conversion */
;;;660      hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
;;;661      hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
;;;662      
;;;663      /* Select external trigger polarity */
;;;664      hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
;;;665      hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
;;;666      
;;;667      if (sConfigInjected->AutoInjectedConv != DISABLE)
;;;668      {
;;;669        /* Enable the selected ADC automatic injected group conversion */
;;;670        hadc->Instance->CR1 |= ADC_CR1_JAUTO;
;;;671      }
;;;672      else
;;;673      {
;;;674        /* Disable the selected ADC automatic injected group conversion */
;;;675        hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
;;;676      }
;;;677      
;;;678      if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
;;;679      {
;;;680        /* Enable the selected ADC injected discontinuous mode */
;;;681        hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
;;;682      }
;;;683      else
;;;684      {
;;;685        /* Disable the selected ADC injected discontinuous mode */
;;;686        hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
;;;687      }
;;;688      
;;;689      switch(sConfigInjected->InjectedRank)
;;;690      {
;;;691        case 1:
;;;692          /* Set injected channel 1 offset */
;;;693          hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
;;;694          hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
;;;695          break;
;;;696        case 2:
;;;697          /* Set injected channel 2 offset */
;;;698          hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
;;;699          hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
;;;700          break;
;;;701        case 3:
;;;702          /* Set injected channel 3 offset */
;;;703          hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
;;;704          hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
;;;705          break;
;;;706        default:
;;;707          /* Set injected channel 4 offset */
;;;708          hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
;;;709          hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
;;;710          break;
;;;711      }
;;;712      
;;;713      /* if ADC1 Channel_18 is selected enable VBAT Channel */
;;;714      if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
;;;715      {
;;;716        /* Enable the VBAT channel*/
;;;717        ADC->CCR |= ADC_CCR_VBATE;
;;;718      }
;;;719      
;;;720      /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
;;;721      if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
;;;722      {
;;;723        /* Enable the TSVREFE channel*/
;;;724        ADC->CCR |= ADC_CCR_TSVREFE;
;;;725      }
;;;726      
;;;727      /* Process unlocked */
;;;728      __HAL_UNLOCK(hadc);
;;;729      
;;;730      /* Return function status */
;;;731      return HAL_OK;
;;;732    }
000040  bd30              POP      {r4,r5,pc}
                  |L4.66|
000042  6925              LDR      r5,[r4,#0x10]         ;641
000044  eb020242          ADD      r2,r2,r2,LSL #1       ;641
000048  4093              LSLS     r3,r3,r2              ;641
00004a  439d              BICS     r5,r5,r3              ;641
00004c  6125              STR      r5,[r4,#0x10]         ;641
00004e  780b              LDRB     r3,[r1,#0]            ;644
000050  688a              LDR      r2,[r1,#8]            ;644
000052  eb030343          ADD      r3,r3,r3,LSL #1       ;644
000056  409a              LSLS     r2,r2,r3              ;644
000058  6803              LDR      r3,[r0,#0]            ;644
00005a  691c              LDR      r4,[r3,#0x10]         ;644
00005c  4322              ORRS     r2,r2,r4              ;644
00005e  611a              STR      r2,[r3,#0x10]         ;644
                  |L4.96|
000060  6802              LDR      r2,[r0,#0]            ;648
000062  6b93              LDR      r3,[r2,#0x38]         ;648
000064  f4231340          BIC      r3,r3,#0x300000       ;648
000068  6393              STR      r3,[r2,#0x38]         ;648
00006a  6802              LDR      r2,[r0,#0]            ;649
00006c  6b93              LDR      r3,[r2,#0x38]         ;649
00006e  8a0c              LDRH     r4,[r1,#0x10]         ;649
000070  4d4c              LDR      r5,|L4.420|
000072  eb055404          ADD      r4,r5,r4,LSL #20      ;649
000076  4323              ORRS     r3,r3,r4              ;649
000078  6393              STR      r3,[r2,#0x38]         ;649
00007a  790a              LDRB     r2,[r1,#4]            ;654
00007c  7c0b              LDRB     r3,[r1,#0x10]         ;654
00007e  1ad2              SUBS     r2,r2,r3              ;654
000080  1cd2              ADDS     r2,r2,#3              ;654
000082  eb020282          ADD      r2,r2,r2,LSL #2       ;654
000086  231f              MOVS     r3,#0x1f              ;654
000088  4093              LSLS     r3,r3,r2              ;654
00008a  6802              LDR      r2,[r0,#0]            ;654
00008c  6b94              LDR      r4,[r2,#0x38]         ;654
00008e  439c              BICS     r4,r4,r3              ;654
000090  6394              STR      r4,[r2,#0x38]         ;654
000092  790a              LDRB     r2,[r1,#4]            ;657
000094  7c0b              LDRB     r3,[r1,#0x10]         ;657
000096  1ad2              SUBS     r2,r2,r3              ;657
000098  1cd2              ADDS     r2,r2,#3              ;657
00009a  eb020382          ADD      r3,r2,r2,LSL #2       ;657
00009e  680a              LDR      r2,[r1,#0]            ;657
0000a0  409a              LSLS     r2,r2,r3              ;657
0000a2  6803              LDR      r3,[r0,#0]            ;657
0000a4  6b9c              LDR      r4,[r3,#0x38]         ;657
0000a6  4322              ORRS     r2,r2,r4              ;657
0000a8  639a              STR      r2,[r3,#0x38]         ;657
0000aa  6802              LDR      r2,[r0,#0]            ;660
0000ac  6893              LDR      r3,[r2,#8]            ;660
0000ae  f4232370          BIC      r3,r3,#0xf0000        ;660
0000b2  6093              STR      r3,[r2,#8]            ;660
0000b4  6802              LDR      r2,[r0,#0]            ;661
0000b6  6893              LDR      r3,[r2,#8]            ;661
0000b8  6a0c              LDR      r4,[r1,#0x20]         ;661
0000ba  4323              ORRS     r3,r3,r4              ;661
0000bc  6093              STR      r3,[r2,#8]            ;661
0000be  6802              LDR      r2,[r0,#0]            ;664
0000c0  6893              LDR      r3,[r2,#8]            ;664
0000c2  f4231340          BIC      r3,r3,#0x300000       ;664
0000c6  6093              STR      r3,[r2,#8]            ;664
0000c8  6802              LDR      r2,[r0,#0]            ;665
0000ca  6893              LDR      r3,[r2,#8]            ;665
0000cc  69cc              LDR      r4,[r1,#0x1c]         ;665
0000ce  4323              ORRS     r3,r3,r4              ;665
0000d0  6093              STR      r3,[r2,#8]            ;665
0000d2  694a              LDR      r2,[r1,#0x14]         ;667
0000d4  2a00              CMP      r2,#0                 ;667
0000d6  6802              LDR      r2,[r0,#0]            ;675
0000d8  6853              LDR      r3,[r2,#4]            ;675
0000da  d002              BEQ      |L4.226|
0000dc  f4436380          ORR      r3,r3,#0x400          ;670
0000e0  e001              B        |L4.230|
                  |L4.226|
0000e2  f4236380          BIC      r3,r3,#0x400          ;675
                  |L4.230|
0000e6  6053              STR      r3,[r2,#4]            ;675
0000e8  698a              LDR      r2,[r1,#0x18]         ;678
0000ea  2a00              CMP      r2,#0                 ;678
0000ec  6802              LDR      r2,[r0,#0]            ;686
0000ee  6853              LDR      r3,[r2,#4]            ;686
0000f0  d002              BEQ      |L4.248|
0000f2  f4435380          ORR      r3,r3,#0x1000         ;681
0000f6  e001              B        |L4.252|
                  |L4.248|
0000f8  f4235380          BIC      r3,r3,#0x1000         ;686
                  |L4.252|
0000fc  6053              STR      r3,[r2,#4]            ;686
0000fe  684a              LDR      r2,[r1,#4]            ;689
000100  2a01              CMP      r2,#1                 ;689
000102  d015              BEQ      |L4.304|
000104  2a02              CMP      r2,#2                 ;689
000106  d01e              BEQ      |L4.326|
000108  2a03              CMP      r2,#3                 ;689
00010a  6802              LDR      r2,[r0,#0]            ;689
00010c  d026              BEQ      |L4.348|
00010e  6a13              LDR      r3,[r2,#0x20]         ;708
000110  f36f030b          BFC      r3,#0,#12             ;708
000114  6213              STR      r3,[r2,#0x20]         ;708
000116  6802              LDR      r2,[r0,#0]            ;709
000118  6a13              LDR      r3,[r2,#0x20]         ;709
00011a  68cc              LDR      r4,[r1,#0xc]          ;709
00011c  4323              ORRS     r3,r3,r4              ;709
00011e  6213              STR      r3,[r2,#0x20]         ;709
                  |L4.288|
000120  4a21              LDR      r2,|L4.424|
000122  6803              LDR      r3,[r0,#0]            ;714
000124  4293              CMP      r3,r2                 ;714
000126  d129              BNE      |L4.380|
000128  680b              LDR      r3,[r1,#0]            ;714
00012a  2b12              CMP      r3,#0x12              ;714
00012c  d020              BEQ      |L4.368|
00012e  e025              B        |L4.380|
                  |L4.304|
000130  6802              LDR      r2,[r0,#0]            ;693
000132  6953              LDR      r3,[r2,#0x14]         ;693
000134  f36f030b          BFC      r3,#0,#12             ;693
000138  6153              STR      r3,[r2,#0x14]         ;693
00013a  6802              LDR      r2,[r0,#0]            ;694
00013c  6953              LDR      r3,[r2,#0x14]         ;694
00013e  68cc              LDR      r4,[r1,#0xc]          ;694
000140  4323              ORRS     r3,r3,r4              ;694
000142  6153              STR      r3,[r2,#0x14]         ;694
000144  e7ec              B        |L4.288|
                  |L4.326|
000146  6802              LDR      r2,[r0,#0]            ;698
000148  6993              LDR      r3,[r2,#0x18]         ;698
00014a  f36f030b          BFC      r3,#0,#12             ;698
00014e  6193              STR      r3,[r2,#0x18]         ;698
000150  6802              LDR      r2,[r0,#0]            ;699
000152  6993              LDR      r3,[r2,#0x18]         ;699
000154  68cc              LDR      r4,[r1,#0xc]          ;699
000156  4323              ORRS     r3,r3,r4              ;699
000158  6193              STR      r3,[r2,#0x18]         ;699
00015a  e7e1              B        |L4.288|
                  |L4.348|
00015c  69d3              LDR      r3,[r2,#0x1c]         ;703
00015e  f36f030b          BFC      r3,#0,#12             ;703
000162  61d3              STR      r3,[r2,#0x1c]         ;703
000164  6802              LDR      r2,[r0,#0]            ;704
000166  69d3              LDR      r3,[r2,#0x1c]         ;704
000168  68cc              LDR      r4,[r1,#0xc]          ;704
00016a  4323              ORRS     r3,r3,r4              ;704
00016c  61d3              STR      r3,[r2,#0x1c]         ;704
00016e  e7d7              B        |L4.288|
                  |L4.368|
000170  f8d23304          LDR      r3,[r2,#0x304]        ;717
000174  f4430380          ORR      r3,r3,#0x400000       ;717
000178  f8c23304          STR      r3,[r2,#0x304]        ;717
                  |L4.380|
00017c  6803              LDR      r3,[r0,#0]            ;721
00017e  4293              CMP      r3,r2                 ;721
000180  d10a              BNE      |L4.408|
000182  6809              LDR      r1,[r1,#0]            ;721
000184  2910              CMP      r1,#0x10              ;721
000186  d001              BEQ      |L4.396|
000188  2911              CMP      r1,#0x11              ;721
00018a  d105              BNE      |L4.408|
                  |L4.396|
00018c  f8d21304          LDR      r1,[r2,#0x304]        ;724
000190  f4410100          ORR      r1,r1,#0x800000       ;724
000194  f8c21304          STR      r1,[r2,#0x304]        ;724
                  |L4.408|
000198  2100              MOVS     r1,#0                 ;728
00019a  f880103c          STRB     r1,[r0,#0x3c]         ;728
00019e  4608              MOV      r0,r1                 ;731
0001a0  bd30              POP      {r4,r5,pc}
;;;733    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L4.420|
                          DCD      0xfff00000
                  |L4.424|
                          DCD      0x40012000

                          AREA ||i.HAL_ADCEx_InjectedConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedConvCpltCallback PROC
;;;588      */
;;;589    __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;590    {
;;;591      /* NOTE : This function Should not be modified, when the callback is needed,
;;;592                the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
;;;593       */
;;;594    }
;;;595    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedGetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedGetValue PROC
;;;417      */
;;;418    uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
000000  b508              PUSH     {r3,lr}
;;;419    {
;;;420      __IO uint32_t tmp = 0;
000002  2200              MOVS     r2,#0
;;;421      
;;;422      /* Check the parameters */
;;;423      assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
;;;424      
;;;425       /* Clear the ADCx's flag for injected end of conversion */
;;;426       __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
000004  9200              STR      r2,[sp,#0]
000006  6802              LDR      r2,[r0,#0]
000008  6813              LDR      r3,[r2,#0]
00000a  f0230304          BIC      r3,r3,#4
00000e  6013              STR      r3,[r2,#0]
;;;427      
;;;428      /* Return the selected ADC converted value */ 
;;;429      switch(InjectedRank)
000010  2901              CMP      r1,#1
000012  d011              BEQ      |L6.56|
000014  2902              CMP      r1,#2
000016  d00c              BEQ      |L6.50|
000018  2903              CMP      r1,#3
00001a  d006              BEQ      |L6.42|
00001c  2904              CMP      r1,#4
00001e  d001              BEQ      |L6.36|
;;;430      {  
;;;431        case ADC_INJECTED_RANK_4:
;;;432        {
;;;433          tmp =  hadc->Instance->JDR4;
;;;434        }  
;;;435        break;
000020  9800              LDR      r0,[sp,#0]
;;;436        case ADC_INJECTED_RANK_3: 
;;;437        {  
;;;438          tmp =  hadc->Instance->JDR3;
;;;439        }  
;;;440        break;
;;;441        case ADC_INJECTED_RANK_2: 
;;;442        {  
;;;443          tmp =  hadc->Instance->JDR2;
;;;444        }
;;;445        break;
;;;446        case ADC_INJECTED_RANK_1:
;;;447        {
;;;448          tmp =  hadc->Instance->JDR1;
;;;449        }
;;;450        break;
;;;451        default:
;;;452        break;  
;;;453      }
;;;454      return tmp;
;;;455    }
000022  bd08              POP      {r3,pc}
                  |L6.36|
000024  6800              LDR      r0,[r0,#0]            ;433
000026  6c80              LDR      r0,[r0,#0x48]         ;433
000028  e001              B        |L6.46|
                  |L6.42|
00002a  6800              LDR      r0,[r0,#0]            ;438
00002c  6c40              LDR      r0,[r0,#0x44]         ;438
                  |L6.46|
00002e  9000              STR      r0,[sp,#0]            ;433
000030  bd08              POP      {r3,pc}
                  |L6.50|
000032  6800              LDR      r0,[r0,#0]            ;443
000034  6c00              LDR      r0,[r0,#0x40]         ;443
000036  e7fa              B        |L6.46|
                  |L6.56|
000038  6800              LDR      r0,[r0,#0]            ;448
00003a  6bc0              LDR      r0,[r0,#0x3c]         ;448
00003c  e7f7              B        |L6.46|
;;;456    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedPollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedPollForConversion PROC
;;;339      */
;;;340    HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;342      uint32_t timeout;
;;;343     
;;;344      /* Get timeout */
;;;345      timeout = HAL_GetTick() + Timeout;  
000006  f7fffffe          BL       HAL_GetTick
00000a  1946              ADDS     r6,r0,r5
;;;346    
;;;347      /* Check End of conversion flag */
;;;348      while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC)))
00000c  e00d              B        |L7.42|
                  |L7.14|
;;;349      {
;;;350        /* Check for the Timeout */
;;;351        if(Timeout != HAL_MAX_DELAY)
00000e  1c68              ADDS     r0,r5,#1
000010  d00b              BEQ      |L7.42|
;;;352        {
;;;353          if(HAL_GetTick() >= timeout)
000012  f7fffffe          BL       HAL_GetTick
000016  42b0              CMP      r0,r6
000018  d307              BCC      |L7.42|
;;;354          {
;;;355            hadc->State= HAL_ADC_STATE_TIMEOUT;
00001a  2003              MOVS     r0,#3
00001c  f884003d          STRB     r0,[r4,#0x3d]
;;;356            /* Process unlocked */
;;;357            __HAL_UNLOCK(hadc);
000020  2000              MOVS     r0,#0
000022  f884003c          STRB     r0,[r4,#0x3c]
;;;358            return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
;;;359          }
;;;360        }
;;;361      }
;;;362      
;;;363      /* Check if a regular conversion is ready */
;;;364      if(hadc->State == HAL_ADC_STATE_EOC_REG)
;;;365      {
;;;366        /* Change ADC state */
;;;367        hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;368      }
;;;369      else
;;;370      {
;;;371        /* Change ADC state */
;;;372        hadc->State = HAL_ADC_STATE_EOC_INJ;
;;;373      }
;;;374      
;;;375      /* Return ADC state */
;;;376      return HAL_OK;
;;;377    }      
000028  bd70              POP      {r4-r6,pc}
                  |L7.42|
00002a  6820              LDR      r0,[r4,#0]            ;348
00002c  6800              LDR      r0,[r0,#0]            ;348
00002e  0740              LSLS     r0,r0,#29             ;348
000030  d5ed              BPL      |L7.14|
000032  f894003d          LDRB     r0,[r4,#0x3d]         ;364
000036  2815              CMP      r0,#0x15              ;364
000038  d004              BEQ      |L7.68|
00003a  2025              MOVS     r0,#0x25              ;372
                  |L7.60|
00003c  f884003d          STRB     r0,[r4,#0x3d]         ;372
000040  2000              MOVS     r0,#0                 ;376
000042  bd70              POP      {r4-r6,pc}
                  |L7.68|
000044  2035              MOVS     r0,#0x35              ;367
000046  e7f9              B        |L7.60|
;;;378      
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStart||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart PROC
;;;171      */
;;;172    HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174      uint32_t i = 0, tmp1 = 0, tmp2 = 0;
;;;175      
;;;176      /* Process locked */
;;;177      __HAL_LOCK(hadc);
000002  f890103c          LDRB     r1,[r0,#0x3c]
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L8.42|
00000a  2101              MOVS     r1,#1
00000c  f880103c          STRB     r1,[r0,#0x3c]
;;;178      
;;;179      /* Check if a regular conversion is ongoing */
;;;180      if(hadc->State == HAL_ADC_STATE_BUSY_REG)
000010  f890103d          LDRB     r1,[r0,#0x3d]
000014  2912              CMP      r1,#0x12
000016  d00a              BEQ      |L8.46|
;;;181      {
;;;182        /* Change ADC state */
;;;183        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;184      }
;;;185      else
;;;186      {
;;;187        /* Change ADC state */
;;;188        hadc->State = HAL_ADC_STATE_BUSY_INJ;
000018  f05f0122          MOVS.W   r1,#0x22
                  |L8.28|
00001c  f880103d          STRB     r1,[r0,#0x3d]
;;;189      } 
;;;190      
;;;191      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;192         Tstab time the ADC's stabilization */
;;;193      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
000020  6801              LDR      r1,[r0,#0]
000022  688a              LDR      r2,[r1,#8]
000024  07d2              LSLS     r2,r2,#31
000026  d004              BEQ      |L8.50|
000028  e00f              B        |L8.74|
                  |L8.42|
00002a  2002              MOVS     r0,#2                 ;177
;;;194      {  
;;;195        /* Enable the Peripheral */
;;;196        __HAL_ADC_ENABLE(hadc);
;;;197        
;;;198        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;199        for(; i <= 540; i++)
;;;200        {
;;;201          __NOP();
;;;202        }
;;;203      }
;;;204      
;;;205      /* Check if Multimode enabled */
;;;206      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;207      {
;;;208        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
;;;209        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;210        if(tmp1 && tmp2)
;;;211        {
;;;212          /* Enable the selected ADC software conversion for injected group */
;;;213          hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
;;;214        }
;;;215      }
;;;216      else
;;;217      {
;;;218        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
;;;219        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;220        if((hadc->Instance == ADC1) && tmp1 && tmp2)  
;;;221        {
;;;222          /* Enable the selected ADC software conversion for injected group */
;;;223          hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
;;;224        }
;;;225      }
;;;226      
;;;227      /* Process unlocked */
;;;228      __HAL_UNLOCK(hadc);
;;;229      
;;;230      /* Return function status */
;;;231      return HAL_OK;
;;;232    }
00002c  bd10              POP      {r4,pc}
                  |L8.46|
00002e  2132              MOVS     r1,#0x32              ;183
000030  e7f4              B        |L8.28|
                  |L8.50|
000032  688a              LDR      r2,[r1,#8]            ;196
000034  f0420201          ORR      r2,r2,#1              ;196
000038  608a              STR      r2,[r1,#8]            ;196
00003a  bf00              NOP                            ;201
00003c  2101              MOVS     r1,#1                 ;199
00003e  f44f7207          MOV      r2,#0x21c             ;199
                  |L8.66|
000042  bf00              NOP                            ;201
000044  1c49              ADDS     r1,r1,#1              ;201
000046  4291              CMP      r1,r2                 ;199
000048  d9fb              BLS      |L8.66|
                  |L8.74|
00004a  4c15              LDR      r4,|L8.160|
00004c  f8d41304          LDR      r1,[r4,#0x304]        ;206
000050  06c9              LSLS     r1,r1,#27             ;206
000052  6801              LDR      r1,[r0,#0]            ;218
000054  688a              LDR      r2,[r1,#8]            ;218
000056  f4021240          AND      r2,r2,#0x300000       ;218
00005a  d012              BEQ      |L8.130|
00005c  b1f2              CBZ      r2,|L8.156|
00005e  2300              MOVS     r3,#0                 ;218
                  |L8.96|
000060  684a              LDR      r2,[r1,#4]            ;219
000062  f3422280          SBFX     r2,r2,#10,#1          ;219
000066  1c52              ADDS     r2,r2,#1              ;219
000068  42a1              CMP      r1,r4                 ;220
00006a  d105              BNE      |L8.120|
00006c  b123              CBZ      r3,|L8.120|
00006e  b11a              CBZ      r2,|L8.120|
                  |L8.112|
000070  688a              LDR      r2,[r1,#8]            ;223
000072  f4420280          ORR      r2,r2,#0x400000       ;223
000076  608a              STR      r2,[r1,#8]            ;223
                  |L8.120|
000078  2100              MOVS     r1,#0                 ;228
00007a  f880103c          STRB     r1,[r0,#0x3c]         ;228
00007e  4608              MOV      r0,r1                 ;231
000080  bd10              POP      {r4,pc}
                  |L8.130|
000082  b14a              CBZ      r2,|L8.152|
000084  2200              MOVS     r2,#0                 ;208
                  |L8.134|
000086  684b              LDR      r3,[r1,#4]            ;209
000088  f3432380          SBFX     r3,r3,#10,#1          ;209
00008c  1c5b              ADDS     r3,r3,#1              ;209
00008e  2a00              CMP      r2,#0                 ;210
000090  d0f2              BEQ      |L8.120|
000092  2b00              CMP      r3,#0                 ;210
000094  d1ec              BNE      |L8.112|
000096  e7ef              B        |L8.120|
                  |L8.152|
000098  2201              MOVS     r2,#1                 ;208
00009a  e7f4              B        |L8.134|
                  |L8.156|
00009c  2301              MOVS     r3,#1                 ;218
00009e  e7df              B        |L8.96|
;;;233    
                          ENDP

                  |L8.160|
                          DCD      0x40012000

                          AREA ||i.HAL_ADCEx_InjectedStart_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_InjectedStart_IT PROC
;;;240      */
;;;241    HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
000000  b530              PUSH     {r4,r5,lr}
;;;242    {
;;;243      uint32_t i = 0, tmp1 = 0, tmp2 =0;
;;;244      
;;;245      /* Process locked */
;;;246      __HAL_LOCK(hadc);
000002  f890103c          LDRB     r1,[r0,#0x3c]
000006  2901              CMP      r1,#1
000008  d011              BEQ      |L9.46|
00000a  2101              MOVS     r1,#1
00000c  f880103c          STRB     r1,[r0,#0x3c]
;;;247      
;;;248      /* Check if a regular conversion is ongoing */
;;;249      if(hadc->State == HAL_ADC_STATE_BUSY_REG)
000010  f890103d          LDRB     r1,[r0,#0x3d]
000014  2912              CMP      r1,#0x12
000016  d00c              BEQ      |L9.50|
;;;250      {
;;;251        /* Change ADC state */
;;;252        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;253      }
;;;254      else
;;;255      {
;;;256        /* Change ADC state */
;;;257        hadc->State = HAL_ADC_STATE_BUSY_INJ;
000018  f05f0122          MOVS.W   r1,#0x22
                  |L9.28|
00001c  f880103d          STRB     r1,[r0,#0x3d]
;;;258      }
;;;259      
;;;260      /* Set ADC error code to none */
;;;261      hadc->ErrorCode = HAL_ADC_ERROR_NONE;
000020  2400              MOVS     r4,#0
000022  6404              STR      r4,[r0,#0x40]
;;;262      
;;;263      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;264         Tstab time the ADC's stabilization */
;;;265      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
000024  6801              LDR      r1,[r0,#0]
000026  688a              LDR      r2,[r1,#8]
000028  07d2              LSLS     r2,r2,#31
00002a  d004              BEQ      |L9.54|
00002c  e00f              B        |L9.78|
                  |L9.46|
00002e  2002              MOVS     r0,#2                 ;246
;;;266      {  
;;;267        /* Enable the Peripheral */
;;;268        __HAL_ADC_ENABLE(hadc);
;;;269        
;;;270        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;271        for(; i <= 540; i++)
;;;272        {
;;;273          __NOP();
;;;274        }
;;;275      }
;;;276      
;;;277      /* Enable the ADC end of conversion interrupt for injected group */
;;;278      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
;;;279      
;;;280      /* Enable the ADC overrun interrupt */
;;;281      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;282      
;;;283      /* Check if Multimode enabled */
;;;284      if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
;;;285      {
;;;286        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
;;;287        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;288        if(tmp1 && tmp2)
;;;289        {
;;;290          /* Enable the selected ADC software conversion for injected group */
;;;291          hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
;;;292        }
;;;293      }
;;;294      else
;;;295      {
;;;296        tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
;;;297        tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
;;;298        if((hadc->Instance == ADC1) && tmp1 && tmp2)  
;;;299        {
;;;300          /* Enable the selected ADC software conversion for injected group */
;;;301          hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
;;;302        }
;;;303      }
;;;304      
;;;305      /* Process unlocked */
;;;306      __HAL_UNLOCK(hadc);
;;;307      
;;;308      /* Return function status */
;;;309      return HAL_OK;
;;;310    }
000030  bd30              POP      {r4,r5,pc}
                  |L9.50|
000032  2132              MOVS     r1,#0x32              ;252
000034  e7f2              B        |L9.28|
                  |L9.54|
000036  688a              LDR      r2,[r1,#8]            ;268
000038  f0420201          ORR      r2,r2,#1              ;268
00003c  608a              STR      r2,[r1,#8]            ;268
00003e  bf00              NOP                            ;273
000040  2101              MOVS     r1,#1                 ;271
000042  f44f7207          MOV      r2,#0x21c             ;271
                  |L9.70|
000046  bf00              NOP                            ;273
000048  1c49              ADDS     r1,r1,#1              ;273
00004a  4291              CMP      r1,r2                 ;271
00004c  d9fb              BLS      |L9.70|
                  |L9.78|
00004e  6801              LDR      r1,[r0,#0]            ;278
000050  684a              LDR      r2,[r1,#4]            ;278
000052  f0420280          ORR      r2,r2,#0x80           ;278
000056  604a              STR      r2,[r1,#4]            ;278
000058  6801              LDR      r1,[r0,#0]            ;281
00005a  684a              LDR      r2,[r1,#4]            ;281
00005c  f0426280          ORR      r2,r2,#0x4000000      ;281
000060  604a              STR      r2,[r1,#4]            ;281
000062  4b15              LDR      r3,|L9.184|
000064  f8d31304          LDR      r1,[r3,#0x304]        ;284
000068  06c9              LSLS     r1,r1,#27             ;284
00006a  6801              LDR      r1,[r0,#0]            ;296
00006c  688a              LDR      r2,[r1,#8]            ;296
00006e  f4021240          AND      r2,r2,#0x300000       ;296
000072  d011              BEQ      |L9.152|
000074  b1ea              CBZ      r2,|L9.178|
000076  2200              MOVS     r2,#0                 ;296
                  |L9.120|
000078  684d              LDR      r5,[r1,#4]            ;297
00007a  f3452580          SBFX     r5,r5,#10,#1          ;297
00007e  1c6d              ADDS     r5,r5,#1              ;297
000080  4299              CMP      r1,r3                 ;298
000082  d105              BNE      |L9.144|
000084  b122              CBZ      r2,|L9.144|
000086  b11d              CBZ      r5,|L9.144|
                  |L9.136|
000088  688a              LDR      r2,[r1,#8]            ;301
00008a  f4420280          ORR      r2,r2,#0x400000       ;301
00008e  608a              STR      r2,[r1,#8]            ;301
                  |L9.144|
000090  f880403c          STRB     r4,[r0,#0x3c]         ;306
000094  2000              MOVS     r0,#0                 ;309
000096  bd30              POP      {r4,r5,pc}
                  |L9.152|
000098  b14a              CBZ      r2,|L9.174|
00009a  2200              MOVS     r2,#0                 ;286
                  |L9.156|
00009c  684b              LDR      r3,[r1,#4]            ;287
00009e  f3432380          SBFX     r3,r3,#10,#1          ;287
0000a2  1c5b              ADDS     r3,r3,#1              ;287
0000a4  2a00              CMP      r2,#0                 ;288
0000a6  d0f3              BEQ      |L9.144|
0000a8  2b00              CMP      r3,#0                 ;288
0000aa  d1ed              BNE      |L9.136|
0000ac  e7f0              B        |L9.144|
                  |L9.174|
0000ae  2201              MOVS     r2,#1                 ;286
0000b0  e7f4              B        |L9.156|
                  |L9.178|
0000b2  2201              MOVS     r2,#1                 ;296
0000b4  e7e0              B        |L9.120|
;;;311    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L9.184|
                          DCD      0x40012000

                          AREA ||i.HAL_ADCEx_InjectedStop||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
000000  6801              LDR      r1,[r0,#0]
;;;322    {
;;;323      /* Disable the Peripheral */
;;;324      __HAL_ADC_DISABLE(hadc);
000002  688a              LDR      r2,[r1,#8]
000004  f0220201          BIC      r2,r2,#1
000008  608a              STR      r2,[r1,#8]
;;;325      
;;;326      /* Change ADC state */
;;;327      hadc->State = HAL_ADC_STATE_READY;
00000a  2101              MOVS     r1,#1
00000c  f880103d          STRB     r1,[r0,#0x3d]
;;;328      
;;;329      /* Return function status */
;;;330      return HAL_OK;
000010  2000              MOVS     r0,#0
;;;331    }
000012  4770              BX       lr
;;;332    
                          ENDP


                          AREA ||i.HAL_ADCEx_InjectedStop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADCEx_InjectedStop_IT PROC
;;;387      */
;;;388    HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
000000  6801              LDR      r1,[r0,#0]
;;;389    {
;;;390      /* Disable the ADC end of conversion interrupt for regular group */
;;;391      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000002  684a              LDR      r2,[r1,#4]
000004  f0220220          BIC      r2,r2,#0x20
000008  604a              STR      r2,[r1,#4]
;;;392      
;;;393      /* Disable the ADC end of conversion interrupt for injected group */
;;;394      __HAL_ADC_DISABLE_IT(hadc, ADC_CR1_JEOCIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  684a              LDR      r2,[r1,#4]
00000e  f0220280          BIC      r2,r2,#0x80
000012  604a              STR      r2,[r1,#4]
;;;395      
;;;396      /* Enable the Periphral */
;;;397      __HAL_ADC_DISABLE(hadc);
000014  6801              LDR      r1,[r0,#0]
000016  688a              LDR      r2,[r1,#8]
000018  f0220201          BIC      r2,r2,#1
00001c  608a              STR      r2,[r1,#8]
;;;398      
;;;399      /* Change ADC state */
;;;400      hadc->State = HAL_ADC_STATE_READY;
00001e  2101              MOVS     r1,#1
000020  f880103d          STRB     r1,[r0,#0x3d]
;;;401      
;;;402      /* Return function status */
;;;403      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;404    }
000026  4770              BX       lr
;;;405    
                          ENDP


                          AREA ||i.HAL_ADCEx_MultiModeConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeConfigChannel PROC
;;;741      */
;;;742    HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
000000  b510              PUSH     {r4,lr}
;;;743    {
;;;744      /* Check the parameters */
;;;745      assert_param(IS_ADC_MODE(multimode->Mode));
;;;746      assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
;;;747      assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
;;;748      
;;;749      /* Process locked */
;;;750      __HAL_LOCK(hadc);
000002  f890203c          LDRB     r2,[r0,#0x3c]
000006  2a01              CMP      r2,#1
000008  d02b              BEQ      |L12.98|
00000a  2201              MOVS     r2,#1
00000c  f8002f3c          STRB     r2,[r0,#0x3c]!
;;;751      
;;;752      /* Set ADC mode */
;;;753      ADC->CCR &= ~(ADC_CCR_MULTI);
000010  4a15              LDR      r2,|L12.104|
000012  f8d23304          LDR      r3,[r2,#0x304]
000016  f023031f          BIC      r3,r3,#0x1f
00001a  f8c23304          STR      r3,[r2,#0x304]
;;;754      ADC->CCR |= multimode->Mode;
00001e  f8d23304          LDR      r3,[r2,#0x304]
000022  680c              LDR      r4,[r1,#0]
000024  4323              ORRS     r3,r3,r4
000026  f8c23304          STR      r3,[r2,#0x304]
;;;755      
;;;756      /* Set the ADC DMA access mode */
;;;757      ADC->CCR &= ~(ADC_CCR_DMA);
00002a  f8d23304          LDR      r3,[r2,#0x304]
00002e  f4234340          BIC      r3,r3,#0xc000
000032  f8c23304          STR      r3,[r2,#0x304]
;;;758      ADC->CCR |= multimode->DMAAccessMode;
000036  f8d23304          LDR      r3,[r2,#0x304]
00003a  684c              LDR      r4,[r1,#4]
00003c  4323              ORRS     r3,r3,r4
00003e  f8c23304          STR      r3,[r2,#0x304]
;;;759      
;;;760      /* Set delay between two sampling phases */
;;;761      ADC->CCR &= ~(ADC_CCR_DELAY);
000042  f8d23304          LDR      r3,[r2,#0x304]
000046  f4236370          BIC      r3,r3,#0xf00
00004a  f8c23304          STR      r3,[r2,#0x304]
;;;762      ADC->CCR |= multimode->TwoSamplingDelay;
00004e  f8d23304          LDR      r3,[r2,#0x304]
000052  6889              LDR      r1,[r1,#8]
000054  430b              ORRS     r3,r3,r1
000056  f8c23304          STR      r3,[r2,#0x304]
;;;763      
;;;764      /* Process unlocked */
;;;765      __HAL_UNLOCK(hadc);
00005a  2100              MOVS     r1,#0
00005c  7001              STRB     r1,[r0,#0]
;;;766      
;;;767      /* Return function status */
;;;768      return HAL_OK;
00005e  4608              MOV      r0,r1
;;;769    }
000060  bd10              POP      {r4,pc}
                  |L12.98|
000062  2002              MOVS     r0,#2                 ;750
000064  bd10              POP      {r4,pc}
;;;770    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
                          DCD      0x40012000

                          AREA ||i.HAL_ADCEx_MultiModeGetValue||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeGetValue PROC
;;;576      */
;;;577    uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
000000  4801              LDR      r0,|L13.8|
;;;578    {
;;;579      /* Return the multi mode conversion value */
;;;580      return ADC->CDR;
000002  f8d00308          LDR      r0,[r0,#0x308]
;;;581    }
000006  4770              BX       lr
;;;582    
                          ENDP

                  |L13.8|
                          DCD      0x40012000

                          AREA ||i.HAL_ADCEx_MultiModeStart_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStart_DMA PROC
;;;467      */
;;;468    HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;469    {
000002  4604              MOV      r4,r0
;;;470      uint16_t counter = 0;
;;;471      
;;;472      /* Check the parameters */
;;;473      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;474      assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
;;;475      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;476      
;;;477      /* Process locked */
;;;478      __HAL_LOCK(hadc);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2500              MOVS     r5,#0                 ;470
00000a  2801              CMP      r0,#1
00000c  d010              BEQ      |L14.48|
00000e  2001              MOVS     r0,#1
000010  f884003c          STRB     r0,[r4,#0x3c]
;;;479      
;;;480      /* Enable ADC overrun interrupt */
;;;481      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
000014  6820              LDR      r0,[r4,#0]
000016  6843              LDR      r3,[r0,#4]
000018  f0436380          ORR      r3,r3,#0x4000000
00001c  6043              STR      r3,[r0,#4]
;;;482      
;;;483      if (hadc->Init.DMAContinuousRequests != DISABLE)
;;;484      {
;;;485        /* Enable the selected ADC DMA request after last transfer */
;;;486        ADC->CCR |= ADC_CCR_DDS;
00001e  481d              LDR      r0,|L14.148|
000020  69e3              LDR      r3,[r4,#0x1c]         ;483
000022  2b00              CMP      r3,#0                 ;483
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;491        ADC->CCR &= ~ADC_CCR_DDS;
000024  f8d03304          LDR      r3,[r0,#0x304]
000028  d004              BEQ      |L14.52|
00002a  f4435300          ORR      r3,r3,#0x2000         ;486
00002e  e003              B        |L14.56|
                  |L14.48|
000030  2002              MOVS     r0,#2                 ;478
;;;492      }
;;;493      
;;;494      /* Set the DMA transfer complete callback */
;;;495      hadc->DMA_Handle->XferCpltCallback = ADC_MultiModeDMAConvCplt;
;;;496      
;;;497      /* Set the DMA half transfer complete callback */
;;;498      hadc->DMA_Handle->XferHalfCpltCallback = ADC_MultiModeDMAHalfConvCplt;
;;;499         
;;;500      /* Set the DMA error callback */
;;;501      hadc->DMA_Handle->XferErrorCallback = ADC_MultiModeDMAError ;
;;;502      
;;;503      /* Enable the DMA Stream */
;;;504      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&ADC->CDR, (uint32_t)pData, Length);
;;;505      
;;;506      /* Change ADC state */
;;;507      hadc->State = HAL_ADC_STATE_BUSY_REG;
;;;508      
;;;509      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;510         Tstab time the ADC's stabilization */
;;;511      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
;;;512      {  
;;;513        /* Enable the Peripheral */
;;;514        __HAL_ADC_ENABLE(hadc);
;;;515        
;;;516        /* Delay inserted to wait during Tstab time the ADC's stabilazation */
;;;517        for(; counter <= 540; counter++)
;;;518        {
;;;519          __NOP();
;;;520        }
;;;521      }
;;;522      
;;;523      /* if no external trigger present enable software conversion of regular channels */
;;;524      if (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE)
;;;525      {
;;;526        /* Enable the selected ADC software conversion for regular group */
;;;527        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;528      }
;;;529      
;;;530      /* Process unlocked */
;;;531      __HAL_UNLOCK(hadc);
;;;532      
;;;533      /* Return function status */
;;;534      return HAL_OK;
;;;535    }
000032  bd70              POP      {r4-r6,pc}
                  |L14.52|
000034  f4235300          BIC      r3,r3,#0x2000         ;491
                  |L14.56|
000038  f8c03304          STR      r3,[r0,#0x304]        ;491
00003c  6ba3              LDR      r3,[r4,#0x38]         ;495
00003e  4816              LDR      r0,|L14.152|
000040  63d8              STR      r0,[r3,#0x3c]         ;498
000042  6ba3              LDR      r3,[r4,#0x38]         ;498
000044  4815              LDR      r0,|L14.156|
000046  6418              STR      r0,[r3,#0x40]         ;501
000048  6ba3              LDR      r3,[r4,#0x38]         ;501
00004a  4815              LDR      r0,|L14.160|
00004c  6498              STR      r0,[r3,#0x48]         ;504
00004e  4613              MOV      r3,r2                 ;504
000050  460a              MOV      r2,r1                 ;504
000052  4914              LDR      r1,|L14.164|
000054  6ba0              LDR      r0,[r4,#0x38]         ;504
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  2012              MOVS     r0,#0x12              ;507
00005c  f884003d          STRB     r0,[r4,#0x3d]         ;507
000060  6820              LDR      r0,[r4,#0]            ;511
000062  6881              LDR      r1,[r0,#8]            ;511
000064  07c9              LSLS     r1,r1,#31             ;511
000066  d10a              BNE      |L14.126|
000068  6881              LDR      r1,[r0,#8]            ;514
00006a  f0410101          ORR      r1,r1,#1              ;514
00006e  6081              STR      r1,[r0,#8]            ;514
000070  f44f7007          MOV      r0,#0x21c             ;517
                  |L14.116|
000074  bf00              NOP                            ;519
000076  1c6d              ADDS     r5,r5,#1              ;519
000078  b2ad              UXTH     r5,r5                 ;517
00007a  4285              CMP      r5,r0                 ;517
00007c  d9fa              BLS      |L14.116|
                  |L14.126|
00007e  6ae0              LDR      r0,[r4,#0x2c]         ;524
000080  b920              CBNZ     r0,|L14.140|
000082  6820              LDR      r0,[r4,#0]            ;527
000084  6881              LDR      r1,[r0,#8]            ;527
000086  f0414180          ORR      r1,r1,#0x40000000     ;527
00008a  6081              STR      r1,[r0,#8]            ;527
                  |L14.140|
00008c  2000              MOVS     r0,#0                 ;531
00008e  f884003c          STRB     r0,[r4,#0x3c]         ;531
000092  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP

                  |L14.148|
                          DCD      0x40012000
                  |L14.152|
                          DCD      ADC_MultiModeDMAConvCplt
                  |L14.156|
                          DCD      ADC_MultiModeDMAHalfConvCplt
                  |L14.160|
                          DCD      ADC_MultiModeDMAError
                  |L14.164|
                          DCD      0x40012308

                          AREA ||i.HAL_ADCEx_MultiModeStop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADCEx_MultiModeStop_DMA PROC
;;;542      */
;;;543    HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;544    {
000002  4604              MOV      r4,r0
;;;545      /* Process locked */
;;;546      __HAL_LOCK(hadc);
000004  f890003c          LDRB     r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d01b              BEQ      |L15.68|
00000c  2501              MOVS     r5,#1
00000e  f884503c          STRB     r5,[r4,#0x3c]
;;;547      
;;;548      /* Enable the Peripheral */
;;;549      __HAL_ADC_DISABLE(hadc);
000012  6820              LDR      r0,[r4,#0]
000014  6881              LDR      r1,[r0,#8]
000016  f0210101          BIC      r1,r1,#1
00001a  6081              STR      r1,[r0,#8]
;;;550      
;;;551      /* Disable ADC overrun interrupt */
;;;552      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
00001c  f8540b38          LDR      r0,[r4],#0x38
000020  6841              LDR      r1,[r0,#4]
000022  f0216180          BIC      r1,r1,#0x4000000
000026  6041              STR      r1,[r0,#4]
;;;553      
;;;554      /* Disable the selected ADC DMA request after last transfer */
;;;555      ADC->CCR &= ~ADC_CCR_DDS;
000028  4807              LDR      r0,|L15.72|
00002a  f8d01304          LDR      r1,[r0,#0x304]
00002e  f4215100          BIC      r1,r1,#0x2000
000032  f8c01304          STR      r1,[r0,#0x304]
;;;556      
;;;557      /* Disable the ADC DMA Stream */
;;;558      HAL_DMA_Abort(hadc->DMA_Handle);
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;559      
;;;560      /* Change ADC state */
;;;561      hadc->State = HAL_ADC_STATE_READY;
00003c  7165              STRB     r5,[r4,#5]
;;;562      
;;;563      /* Process unlocked */
;;;564      __HAL_UNLOCK(hadc);
00003e  2000              MOVS     r0,#0
000040  7120              STRB     r0,[r4,#4]
;;;565        
;;;566      /* Return function status */
;;;567      return HAL_OK;
;;;568    }
000042  bd70              POP      {r4-r6,pc}
                  |L15.68|
000044  2002              MOVS     r0,#2                 ;546
000046  bd70              POP      {r4-r6,pc}
;;;569    
                          ENDP

                  |L15.72|
                          DCD      0x40012000

;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_adc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f2xx_hal_adc_ex_c_e8cb11ff____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___22_stm32f2xx_hal_adc_ex_c_e8cb11ff____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f2xx_hal_adc_ex_c_e8cb11ff____REVSH|
#line 144
|__asm___22_stm32f2xx_hal_adc_ex_c_e8cb11ff____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
