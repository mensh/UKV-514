; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_tim_ex.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_tim_ex.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_tim_ex.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1714     */
;;;1715   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1716   {
;;;1717     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1718               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1719      */
;;;1720   }
;;;1721   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1702     */
;;;1703   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1704   {
;;;1705     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1706               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1707      */
;;;1708   }
;;;1709   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1606     */    
;;;1607   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
000000  b530              PUSH     {r4,r5,lr}
;;;1608                                                 TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
;;;1609   {
;;;1610     /* Check the parameters */
;;;1611     assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;1612     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1613     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1614     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1615     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1616     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1617     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1618     
;;;1619     /* Process Locked */
;;;1620     __HAL_LOCK(htim);
000002  f8902038          LDRB     r2,[r0,#0x38]
000006  2a01              CMP      r2,#1
000008  d019              BEQ      |L3.62|
00000a  2201              MOVS     r2,#1
00000c  f8002f38          STRB     r2,[r0,#0x38]!
;;;1621     
;;;1622     htim->State = HAL_TIM_STATE_BUSY;
000010  2302              MOVS     r3,#2
000012  7043              STRB     r3,[r0,#1]
000014  e9d13400          LDRD     r3,r4,[r1,#0]
;;;1623   
;;;1624     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1625        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1626     htim->Instance->BDTR = (uint32_t)sBreakDeadTimeConfig->OffStateRunMode  | 
000018  4323              ORRS     r3,r3,r4
00001a  e9d14502          LDRD     r4,r5,[r1,#8]
00001e  432c              ORRS     r4,r4,r5
000020  4323              ORRS     r3,r3,r4
000022  690c              LDR      r4,[r1,#0x10]
000024  4323              ORRS     r3,r3,r4
000026  694c              LDR      r4,[r1,#0x14]
000028  6989              LDR      r1,[r1,#0x18]
00002a  4323              ORRS     r3,r3,r4
00002c  430b              ORRS     r3,r3,r1
00002e  f8501c38          LDR      r1,[r0,#-0x38]
000032  644b              STR      r3,[r1,#0x44]
;;;1627                                      sBreakDeadTimeConfig->OffStateIDLEMode |
;;;1628                                      sBreakDeadTimeConfig->LockLevel        |
;;;1629                                      sBreakDeadTimeConfig->DeadTime         |
;;;1630                                      sBreakDeadTimeConfig->BreakState       |
;;;1631                                      sBreakDeadTimeConfig->BreakPolarity    |
;;;1632                                      sBreakDeadTimeConfig->AutomaticOutput;
;;;1633     
;;;1634                                      
;;;1635     htim->State = HAL_TIM_STATE_READY;                                 
000034  7042              STRB     r2,[r0,#1]
;;;1636     
;;;1637     __HAL_UNLOCK(htim);
000036  2100              MOVS     r1,#0
000038  7001              STRB     r1,[r0,#0]
;;;1638     
;;;1639     return HAL_OK;
00003a  4608              MOV      r0,r1
;;;1640   }
00003c  bd30              POP      {r4,r5,pc}
                  |L3.62|
00003e  2002              MOVS     r0,#2                 ;1620
000040  bd30              POP      {r4,r5,pc}
;;;1641   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1424     */
;;;1425   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1426   {
;;;1427     /* Check the parameters */
;;;1428     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1429     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1430     
;;;1431     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L4.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L4.36|
;;;1432     
;;;1433     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L4.36|
;;;1434         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L4.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L4.36|
00001e  e00a              B        |L4.54|
                  |L4.32|
000020  2002              MOVS     r0,#2                 ;1431
;;;1435     {    
;;;1436       /* Select the Input trigger */
;;;1437       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1438       htim->Instance->SMCR |= InputTrigger;
;;;1439     }
;;;1440       
;;;1441     /* Select the Capture Compare preload feature */
;;;1442     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1443     /* Select the Commutation event source */
;;;1444     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1445     htim->Instance->CR2 |= CommutationSource;
;;;1446       
;;;1447     __HAL_UNLOCK(htim);
;;;1448     
;;;1449     return HAL_OK;
;;;1450   }
000022  bd10              POP      {r4,pc}
                  |L4.36|
000024  6803              LDR      r3,[r0,#0]            ;1437
000026  689c              LDR      r4,[r3,#8]            ;1437
000028  f0240470          BIC      r4,r4,#0x70           ;1437
00002c  609c              STR      r4,[r3,#8]            ;1437
00002e  6803              LDR      r3,[r0,#0]            ;1438
000030  689c              LDR      r4,[r3,#8]            ;1438
000032  430c              ORRS     r4,r4,r1              ;1438
000034  609c              STR      r4,[r3,#8]            ;1438
                  |L4.54|
000036  6801              LDR      r1,[r0,#0]            ;1442
000038  684b              LDR      r3,[r1,#4]            ;1442
00003a  f0430301          ORR      r3,r3,#1              ;1442
00003e  604b              STR      r3,[r1,#4]            ;1442
000040  6801              LDR      r1,[r0,#0]            ;1444
000042  684b              LDR      r3,[r1,#4]            ;1444
000044  f0230304          BIC      r3,r3,#4              ;1444
000048  604b              STR      r3,[r1,#4]            ;1444
00004a  6801              LDR      r1,[r0,#0]            ;1445
00004c  684b              LDR      r3,[r1,#4]            ;1445
00004e  4313              ORRS     r3,r3,r2              ;1445
000050  604b              STR      r3,[r1,#4]            ;1445
000052  2100              MOVS     r1,#0                 ;1447
000054  f8801038          STRB     r1,[r0,#0x38]         ;1447
000058  4608              MOV      r0,r1                 ;1449
00005a  bd10              POP      {r4,pc}
;;;1451   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1526     */
;;;1527   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1528   {
;;;1529     /* Check the parameters */
;;;1530     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1531     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1532     
;;;1533     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L5.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L5.36|
;;;1534     
;;;1535     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L5.36|
;;;1536         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L5.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L5.36|
00001e  e00a              B        |L5.54|
                  |L5.32|
000020  2002              MOVS     r0,#2                 ;1533
;;;1537     {    
;;;1538       /* Select the Input trigger */
;;;1539       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1540       htim->Instance->SMCR |= InputTrigger;
;;;1541     }
;;;1542     
;;;1543     /* Select the Capture Compare preload feature */
;;;1544     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1545     /* Select the Commutation event source */
;;;1546     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1547     htim->Instance->CR2 |= CommutationSource;
;;;1548     
;;;1549     /* Enable the Commutation DMA Request */
;;;1550     /* Set the DMA Commutation Callback */
;;;1551     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;     
;;;1552     /* Set the DMA error callback */
;;;1553     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError;
;;;1554     
;;;1555     /* Enable the Commutation DMA Request */
;;;1556     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1557   
;;;1558     __HAL_UNLOCK(htim);
;;;1559     
;;;1560     return HAL_OK;
;;;1561   }
000022  bd10              POP      {r4,pc}
                  |L5.36|
000024  6803              LDR      r3,[r0,#0]            ;1539
000026  689c              LDR      r4,[r3,#8]            ;1539
000028  f0240470          BIC      r4,r4,#0x70           ;1539
00002c  609c              STR      r4,[r3,#8]            ;1539
00002e  6803              LDR      r3,[r0,#0]            ;1540
000030  689c              LDR      r4,[r3,#8]            ;1540
000032  430c              ORRS     r4,r4,r1              ;1540
000034  609c              STR      r4,[r3,#8]            ;1540
                  |L5.54|
000036  6801              LDR      r1,[r0,#0]            ;1544
000038  684b              LDR      r3,[r1,#4]            ;1544
00003a  f0430301          ORR      r3,r3,#1              ;1544
00003e  604b              STR      r3,[r1,#4]            ;1544
000040  6801              LDR      r1,[r0,#0]            ;1546
000042  684b              LDR      r3,[r1,#4]            ;1546
000044  f0230304          BIC      r3,r3,#4              ;1546
000048  604b              STR      r3,[r1,#4]            ;1546
00004a  6801              LDR      r1,[r0,#0]            ;1547
00004c  684b              LDR      r3,[r1,#4]            ;1547
00004e  4313              ORRS     r3,r3,r2              ;1547
000050  604b              STR      r3,[r1,#4]            ;1547
000052  6b02              LDR      r2,[r0,#0x30]         ;1551
000054  4907              LDR      r1,|L5.116|
000056  63d1              STR      r1,[r2,#0x3c]         ;1553
000058  6b02              LDR      r2,[r0,#0x30]         ;1553
00005a  4907              LDR      r1,|L5.120|
00005c  6491              STR      r1,[r2,#0x48]         ;1556
00005e  6801              LDR      r1,[r0,#0]            ;1556
000060  68ca              LDR      r2,[r1,#0xc]          ;1556
000062  f4425200          ORR      r2,r2,#0x2000         ;1556
000066  60ca              STR      r2,[r1,#0xc]          ;1556
000068  2100              MOVS     r1,#0                 ;1558
00006a  f8801038          STRB     r1,[r0,#0x38]         ;1558
00006e  4608              MOV      r0,r1                 ;1560
000070  bd10              POP      {r4,pc}
;;;1562   
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      HAL_TIMEx_DMACommutationCplt
                  |L5.120|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1473     */
;;;1474   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1475   {
;;;1476     /* Check the parameters */
;;;1477     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1478     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1479     
;;;1480     __HAL_LOCK(htim);
000002  f8903038          LDRB     r3,[r0,#0x38]
000006  2b01              CMP      r3,#1
000008  d00a              BEQ      |L6.32|
00000a  2301              MOVS     r3,#1
00000c  f8803038          STRB     r3,[r0,#0x38]
000010  b141              CBZ      r1,|L6.36|
;;;1481     
;;;1482     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
000012  2910              CMP      r1,#0x10
000014  d006              BEQ      |L6.36|
;;;1483         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000016  2920              CMP      r1,#0x20
000018  d004              BEQ      |L6.36|
00001a  2930              CMP      r1,#0x30
00001c  d002              BEQ      |L6.36|
00001e  e00a              B        |L6.54|
                  |L6.32|
000020  2002              MOVS     r0,#2                 ;1480
;;;1484     {    
;;;1485       /* Select the Input trigger */
;;;1486       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1487       htim->Instance->SMCR |= InputTrigger;
;;;1488     }
;;;1489     
;;;1490     /* Select the Capture Compare preload feature */
;;;1491     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1492     /* Select the Commutation event source */
;;;1493     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1494     htim->Instance->CR2 |= CommutationSource;
;;;1495       
;;;1496     /* Enable the Commutation Interrupt Request */
;;;1497     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1498   
;;;1499     __HAL_UNLOCK(htim);
;;;1500     
;;;1501     return HAL_OK;
;;;1502   }
000022  bd10              POP      {r4,pc}
                  |L6.36|
000024  6803              LDR      r3,[r0,#0]            ;1486
000026  689c              LDR      r4,[r3,#8]            ;1486
000028  f0240470          BIC      r4,r4,#0x70           ;1486
00002c  609c              STR      r4,[r3,#8]            ;1486
00002e  6803              LDR      r3,[r0,#0]            ;1487
000030  689c              LDR      r4,[r3,#8]            ;1487
000032  430c              ORRS     r4,r4,r1              ;1487
000034  609c              STR      r4,[r3,#8]            ;1487
                  |L6.54|
000036  6801              LDR      r1,[r0,#0]            ;1491
000038  684b              LDR      r3,[r1,#4]            ;1491
00003a  f0430301          ORR      r3,r3,#1              ;1491
00003e  604b              STR      r3,[r1,#4]            ;1491
000040  6801              LDR      r1,[r0,#0]            ;1493
000042  684b              LDR      r3,[r1,#4]            ;1493
000044  f0230304          BIC      r3,r3,#4              ;1493
000048  604b              STR      r3,[r1,#4]            ;1493
00004a  6801              LDR      r1,[r0,#0]            ;1494
00004c  684b              LDR      r3,[r1,#4]            ;1494
00004e  4313              ORRS     r3,r3,r2              ;1494
000050  604b              STR      r3,[r1,#4]            ;1494
000052  6801              LDR      r1,[r0,#0]            ;1497
000054  68ca              LDR      r2,[r1,#0xc]          ;1497
000056  f0420220          ORR      r2,r2,#0x20           ;1497
00005a  60ca              STR      r2,[r1,#0xc]          ;1497
00005c  2100              MOVS     r1,#0                 ;1499
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1499
000062  4608              MOV      r0,r1                 ;1501
000064  bd10              POP      {r4,pc}
;;;1503   
                          ENDP


                          AREA ||i.HAL_TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_DMACommutationCplt PROC
;;;1759     */
;;;1760   void HAL_TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1761   {
;;;1762     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b80              LDR      r0,[r0,#0x38]
;;;1763     
;;;1764     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  f8801039          STRB     r1,[r0,#0x39]
;;;1765       
;;;1766     HAL_TIMEx_CommutationCallback(htim); 
00000a  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;1767   }
00000e  bd10              POP      {r4,pc}
;;;1768   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;223      */
;;;224    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;225    {
000002  4604              MOV      r4,r0
;;;226      /* Check the parameters */
;;;227      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;228    
;;;229      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840039          STRB     r0,[r4,#0x39]
;;;230      
;;;231      /* Disable the TIM Peripheral Clock */
;;;232      __HAL_TIM_DISABLE(htim);
00000a  6820              LDR      r0,[r4,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L8.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L8.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L8.38|
;;;233        
;;;234      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;235      HAL_TIMEx_HallSensor_MspDeInit(htim);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;236        
;;;237      /* Change TIM state */  
;;;238      htim->State = HAL_TIM_STATE_RESET; 
00002c  2000              MOVS     r0,#0
00002e  f8840039          STRB     r0,[r4,#0x39]
;;;239    
;;;240      /* Release Lock */
;;;241      __HAL_UNLOCK(htim);
000032  f8840038          STRB     r0,[r4,#0x38]
;;;242    
;;;243      return HAL_OK;
;;;244    }
000036  bd10              POP      {r4,pc}
;;;245    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;1745     */
;;;1746   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  f8900039          LDRB     r0,[r0,#0x39]
;;;1747   {
;;;1748     return htim->State;
;;;1749   }
000004  4770              BX       lr
;;;1750   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Init PROC
;;;151      */
;;;152    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;153    {
000002  b087              SUB      sp,sp,#0x1c
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d050              BEQ      |L10.172|
;;;154      TIM_OC_InitTypeDef OC_Config;
;;;155        
;;;156      /* Check the TIM handle allocation */
;;;157      if(htim == NULL)
;;;158      {
;;;159        return HAL_ERROR;
;;;160      }
;;;161      
;;;162      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;163      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;164      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;165      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;166      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;167      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;168    
;;;169      /* Set the TIM state */
;;;170      htim->State= HAL_TIM_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  f8840039          STRB     r0,[r4,#0x39]
;;;171      
;;;172      /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;173      HAL_TIMEx_HallSensor_MspInit(htim);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
;;;174      
;;;175      /* Configure the Time base in the Encoder Mode */
;;;176      TIM_Base_SetConfig(htim->Instance, &htim->Init);
000016  1d21              ADDS     r1,r4,#4
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       TIM_Base_SetConfig
;;;177      
;;;178      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;179      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
00001e  68ab              LDR      r3,[r5,#8]
000020  6829              LDR      r1,[r5,#0]
000022  2203              MOVS     r2,#3
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       TIM_TI1_SetConfig
;;;180      
;;;181      /* Reset the IC1PSC Bits */
;;;182      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
00002a  6820              LDR      r0,[r4,#0]
00002c  6981              LDR      r1,[r0,#0x18]
00002e  f021010c          BIC      r1,r1,#0xc
000032  6181              STR      r1,[r0,#0x18]
;;;183      /* Set the IC1PSC value */
;;;184      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
000034  6820              LDR      r0,[r4,#0]
000036  6981              LDR      r1,[r0,#0x18]
000038  686a              LDR      r2,[r5,#4]
00003a  4311              ORRS     r1,r1,r2
00003c  6181              STR      r1,[r0,#0x18]
;;;185      
;;;186      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;187      htim->Instance->CR2 |= TIM_CR2_TI1S;
00003e  6820              LDR      r0,[r4,#0]
000040  6841              LDR      r1,[r0,#4]
000042  f0410180          ORR      r1,r1,#0x80
000046  6041              STR      r1,[r0,#4]
;;;188      
;;;189      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;190      htim->Instance->SMCR &= ~TIM_SMCR_TS;
000048  6820              LDR      r0,[r4,#0]
00004a  6881              LDR      r1,[r0,#8]
00004c  f0210170          BIC      r1,r1,#0x70
000050  6081              STR      r1,[r0,#8]
;;;191      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
000052  6820              LDR      r0,[r4,#0]
000054  6881              LDR      r1,[r0,#8]
000056  f0410140          ORR      r1,r1,#0x40
00005a  6081              STR      r1,[r0,#8]
;;;192      
;;;193      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */  
;;;194      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
00005c  6820              LDR      r0,[r4,#0]
00005e  6881              LDR      r1,[r0,#8]
000060  f0210107          BIC      r1,r1,#7
000064  6081              STR      r1,[r0,#8]
;;;195      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
000066  6820              LDR      r0,[r4,#0]
000068  6881              LDR      r1,[r0,#8]
00006a  f0410104          ORR      r1,r1,#4
00006e  6081              STR      r1,[r0,#8]
;;;196      
;;;197      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;198      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
000070  2000              MOVS     r0,#0
;;;199      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;200      OC_Config.OCMode = TIM_OCMODE_PWM2;
000072  2170              MOVS     r1,#0x70
;;;201      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
000074  9005              STR      r0,[sp,#0x14]
;;;202      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;203      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;204      OC_Config.Pulse = sConfig->Commutation_Delay; 
000076  9100              STR      r1,[sp,#0]
000078  9004              STR      r0,[sp,#0x10]         ;199
00007a  9006              STR      r0,[sp,#0x18]         ;202
00007c  9003              STR      r0,[sp,#0xc]          ;203
00007e  9002              STR      r0,[sp,#8]
000080  68e8              LDR      r0,[r5,#0xc]
;;;205        
;;;206      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
000082  9001              STR      r0,[sp,#4]
000084  4669              MOV      r1,sp
000086  6820              LDR      r0,[r4,#0]
000088  f7fffffe          BL       TIM_OC2_SetConfig
;;;207      
;;;208      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;209        register to 101 */
;;;210      htim->Instance->CR2 &= ~TIM_CR2_MMS;
00008c  6820              LDR      r0,[r4,#0]
00008e  6841              LDR      r1,[r0,#4]
000090  f0210170          BIC      r1,r1,#0x70
000094  6041              STR      r1,[r0,#4]
;;;211      htim->Instance->CR2 |= TIM_TRGO_OC2REF; 
000096  6820              LDR      r0,[r4,#0]
000098  6841              LDR      r1,[r0,#4]
00009a  f0410150          ORR      r1,r1,#0x50
00009e  6041              STR      r1,[r0,#4]
;;;212      
;;;213      /* Initialize the TIM state*/
;;;214      htim->State= HAL_TIM_STATE_READY;
0000a0  2001              MOVS     r0,#1
0000a2  f8840039          STRB     r0,[r4,#0x39]
;;;215    
;;;216      return HAL_OK;
0000a6  2000              MOVS     r0,#0
                  |L10.168|
;;;217    }
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  bd30              POP      {r4,r5,pc}
                  |L10.172|
0000ac  2001              MOVS     r0,#1                 ;159
0000ae  e7fb              B        |L10.168|
;;;218    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;262      */
;;;263    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;264    {
;;;265      /* NOTE : This function Should not be modified, when the callback is needed,
;;;266                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;267       */
;;;268    }
;;;269    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;250      */
;;;251    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;252    {
;;;253      /* NOTE : This function Should not be modified, when the callback is needed,
;;;254                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;255       */
;;;256    }
;;;257    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;274      */
;;;275    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277      /* Check the parameters */
;;;278      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;279      
;;;280      /* Enable the Input Capture channels 1
;;;281        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;282      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;283      
;;;284      /* Enable the Peripheral */
;;;285      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;286      
;;;287      /* Return function status */
;;;288      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;289    }
00001a  bd10              POP      {r4,pc}
;;;290    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;366      */
;;;367    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;368    {
000002  4604              MOV      r4,r0
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;371      
;;;372       if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4615              MOV      r5,r2                 ;368
00000a  460e              MOV      r6,r1                 ;368
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L14.28|
;;;373      {
;;;374         return HAL_BUSY;
;;;375      }
;;;376      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L14.36|
;;;377      {
;;;378        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000018  b90e              CBNZ     r6,|L14.30|
00001a  b105              CBZ      r5,|L14.30|
                  |L14.28|
;;;379        {
;;;380          return HAL_ERROR;                                    
;;;381        }
;;;382        else
;;;383        {
;;;384          htim->State = HAL_TIM_STATE_BUSY;
;;;385        }
;;;386      }
;;;387      /* Enable the Input Capture channels 1
;;;388        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;389      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;390      
;;;391      /* Set the DMA Input Capture 1 Callback */
;;;392      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;     
;;;393      /* Set the DMA error callback */
;;;394      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;395      
;;;396      /* Enable the DMA Stream for Capture 1*/
;;;397      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);    
;;;398      
;;;399      /* Enable the capture compare 1 Interrupt */
;;;400      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;401     
;;;402      /* Enable the Peripheral */
;;;403      __HAL_TIM_ENABLE(htim);
;;;404      
;;;405      /* Return function status */
;;;406      return HAL_OK;
;;;407    }
00001c  bd70              POP      {r4-r6,pc}
                  |L14.30|
00001e  2002              MOVS     r0,#2                 ;384
000020  f8840039          STRB     r0,[r4,#0x39]         ;384
                  |L14.36|
000024  2201              MOVS     r2,#1                 ;389
000026  2100              MOVS     r1,#0                 ;389
000028  6820              LDR      r0,[r4,#0]            ;389
00002a  f7fffffe          BL       TIM_CCxChannelCmd
00002e  6a21              LDR      r1,[r4,#0x20]         ;392
000030  480b              LDR      r0,|L14.96|
000032  462b              MOV      r3,r5                 ;397
000034  63c8              STR      r0,[r1,#0x3c]         ;394
000036  6a21              LDR      r1,[r4,#0x20]         ;394
000038  480a              LDR      r0,|L14.100|
00003a  4632              MOV      r2,r6                 ;397
00003c  6488              STR      r0,[r1,#0x48]         ;397
00003e  6821              LDR      r1,[r4,#0]            ;397
000040  6a20              LDR      r0,[r4,#0x20]         ;397
000042  3134              ADDS     r1,r1,#0x34           ;397
000044  f7fffffe          BL       HAL_DMA_Start_IT
000048  6820              LDR      r0,[r4,#0]            ;400
00004a  68c1              LDR      r1,[r0,#0xc]          ;400
00004c  f4417100          ORR      r1,r1,#0x200          ;400
000050  60c1              STR      r1,[r0,#0xc]          ;400
000052  6820              LDR      r0,[r4,#0]            ;403
000054  6801              LDR      r1,[r0,#0]            ;403
000056  f0410101          ORR      r1,r1,#1              ;403
00005a  6001              STR      r1,[r0,#0]            ;403
00005c  2000              MOVS     r0,#0                 ;406
00005e  bd70              POP      {r4-r6,pc}
;;;408    
                          ENDP

                  |L14.96|
                          DCD      HAL_TIM_DMACaptureCplt
                  |L14.100|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;316      */
;;;317    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;318    { 
000002  4604              MOV      r4,r0
;;;319      /* Check the parameters */
;;;320      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;321      
;;;322      /* Enable the capture compare Interrupts 1 event */
;;;323      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;324      
;;;325      /* Enable the Input Capture channels 1
;;;326        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;327      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);  
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;328      
;;;329      /* Enable the Peripheral */
;;;330      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;331      
;;;332      /* Return function status */
;;;333      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;334    }
000024  bd10              POP      {r4,pc}
;;;335    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;295      */
;;;296    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;297    {
000002  4604              MOV      r4,r0
;;;298      /* Check the parameters */
;;;299      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;300      
;;;301      /* Disable the Input Capture channels 1, 2 and 3
;;;302        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;303      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;304    
;;;305      /* Disable the Peripheral */
;;;306      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  f2411211          MOV      r2,#0x1111
000016  4211              TST      r1,r2
000018  d107              BNE      |L16.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L16.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L16.42|
;;;307      
;;;308      /* Return function status */
;;;309      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;310    }
00002c  bd10              POP      {r4,pc}
;;;311    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;413      */
;;;414    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;415    {
000002  4604              MOV      r4,r0
;;;416      /* Check the parameters */
;;;417      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;418      
;;;419      /* Disable the Input Capture channels 1
;;;420        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;421      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;422     
;;;423      
;;;424      /* Disable the capture compare Interrupts 1 event */
;;;425      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4217100          BIC      r1,r1,#0x200
000016  60c1              STR      r1,[r0,#0xc]
;;;426     
;;;427      /* Disable the Peripheral */
;;;428      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L17.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L17.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L17.52|
;;;429      
;;;430      /* Return function status */
;;;431      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;432    }
000036  bd10              POP      {r4,pc}
;;;433    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;340      */
;;;341    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;342    {
000002  4604              MOV      r4,r0
;;;343      /* Check the parameters */
;;;344      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;345      
;;;346      /* Disable the Input Capture channels 1
;;;347        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;348      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  2200              MOVS     r2,#0
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;349      
;;;350      /* Disable the capture compare Interrupts event */
;;;351      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210102          BIC      r1,r1,#2
000016  60c1              STR      r1,[r0,#0xc]
;;;352      
;;;353      /* Disable the Peripheral */
;;;354      __HAL_TIM_DISABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f2411211          MOV      r2,#0x1111
000020  4211              TST      r1,r2
000022  d107              BNE      |L18.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L18.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L18.52|
;;;355      
;;;356      /* Return function status */
;;;357      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;358    }
000036  bd10              POP      {r4,pc}
;;;359    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1570     */
;;;1571   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  b530              PUSH     {r4,r5,lr}
;;;1572   {
;;;1573     /* Check the parameters */
;;;1574     assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
;;;1575     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1576     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1577     
;;;1578     __HAL_LOCK(htim);
000002  f8902038          LDRB     r2,[r0,#0x38]
000006  2a01              CMP      r2,#1
000008  d020              BEQ      |L19.76|
00000a  2201              MOVS     r2,#1
00000c  f8802038          STRB     r2,[r0,#0x38]
;;;1579     
;;;1580     htim->State = HAL_TIM_STATE_BUSY;
000010  2302              MOVS     r3,#2
000012  f8803039          STRB     r3,[r0,#0x39]
;;;1581   
;;;1582     /* Reset the MMS Bits */
;;;1583     htim->Instance->CR2 &= ~TIM_CR2_MMS;
000016  6803              LDR      r3,[r0,#0]
000018  685c              LDR      r4,[r3,#4]
00001a  f0240470          BIC      r4,r4,#0x70
00001e  605c              STR      r4,[r3,#4]
;;;1584     /* Select the TRGO source */
;;;1585     htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
000020  6803              LDR      r3,[r0,#0]
000022  685c              LDR      r4,[r3,#4]
000024  680d              LDR      r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
000028  605c              STR      r4,[r3,#4]
;;;1586   
;;;1587     /* Reset the MSM Bit */
;;;1588     htim->Instance->SMCR &= ~TIM_SMCR_MSM;
00002a  6803              LDR      r3,[r0,#0]
00002c  689c              LDR      r4,[r3,#8]
00002e  f0240480          BIC      r4,r4,#0x80
000032  609c              STR      r4,[r3,#8]
;;;1589     /* Set or Reset the MSM Bit */
;;;1590     htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
000034  6803              LDR      r3,[r0,#0]
000036  689c              LDR      r4,[r3,#8]
000038  6849              LDR      r1,[r1,#4]
00003a  430c              ORRS     r4,r4,r1
00003c  609c              STR      r4,[r3,#8]
;;;1591     
;;;1592     htim->State = HAL_TIM_STATE_READY;
00003e  f8802039          STRB     r2,[r0,#0x39]
;;;1593     
;;;1594     __HAL_UNLOCK(htim);
000042  2100              MOVS     r1,#0
000044  f8801038          STRB     r1,[r0,#0x38]
;;;1595     
;;;1596     return HAL_OK;
000048  4608              MOV      r0,r1
;;;1597   } 
00004a  bd30              POP      {r4,r5,pc}
                  |L19.76|
00004c  2002              MOVS     r0,#2                 ;1578
00004e  bd30              POP      {r4,r5,pc}
;;;1598                                                        
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;469      */
;;;470    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;471    {
000002  4604              MOV      r4,r0
;;;472      /* Check the parameters */
;;;473      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;474      
;;;475         /* Enable the Capture compare channel N */
;;;476         TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;477        
;;;478      /* Enable the Main Ouput */
;;;479        __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;480    
;;;481      /* Enable the Peripheral */
;;;482      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;483      
;;;484      /* Return function status */
;;;485      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;486    } 
000022  bd10              POP      {r4,pc}
;;;487    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;659      */
;;;660    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;661    {
000002  4604              MOV      r4,r0
;;;662      /* Check the parameters */
;;;663      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;664      
;;;665      if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;661
00000a  460d              MOV      r5,r1                 ;661
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L21.28|
;;;666      {
;;;667         return HAL_BUSY;
;;;668      }
;;;669      else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L21.36|
;;;670      {
;;;671        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000018  b90e              CBNZ     r6,|L21.30|
00001a  b103              CBZ      r3,|L21.30|
                  |L21.28|
;;;672        {
;;;673          return HAL_ERROR;                                    
;;;674        }
;;;675        else
;;;676        {
;;;677          htim->State = HAL_TIM_STATE_BUSY;
;;;678        }
;;;679      }    
;;;680      switch (Channel)
;;;681      {
;;;682        case TIM_CHANNEL_1:
;;;683        {      
;;;684          /* Set the DMA Period elapsed callback */
;;;685          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;686         
;;;687          /* Set the DMA error callback */
;;;688          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;689          
;;;690          /* Enable the DMA Stream */
;;;691          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;692          
;;;693          /* Enable the TIM Output Compare DMA request */
;;;694          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;695        }
;;;696        break;
;;;697        
;;;698        case TIM_CHANNEL_2:
;;;699        {
;;;700          /* Set the DMA Period elapsed callback */
;;;701          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;702         
;;;703          /* Set the DMA error callback */
;;;704          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;705          
;;;706          /* Enable the DMA Stream */
;;;707          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;708          
;;;709          /* Enable the TIM Output Compare DMA request */
;;;710          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;711        }
;;;712        break;
;;;713        
;;;714        case TIM_CHANNEL_3:
;;;715    {
;;;716          /* Set the DMA Period elapsed callback */
;;;717          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;718         
;;;719          /* Set the DMA error callback */
;;;720          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;721          
;;;722          /* Enable the DMA Stream */
;;;723          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;724          
;;;725          /* Enable the TIM Output Compare DMA request */
;;;726          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;727        }
;;;728        break;
;;;729        
;;;730        case TIM_CHANNEL_4:
;;;731        {
;;;732         /* Set the DMA Period elapsed callback */
;;;733          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;734         
;;;735          /* Set the DMA error callback */
;;;736          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;737          
;;;738          /* Enable the DMA Stream */
;;;739          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;740          
;;;741          /* Enable the TIM Output Compare DMA request */
;;;742          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;743        }
;;;744        break;
;;;745        
;;;746        default:
;;;747        break;
;;;748      }
;;;749    
;;;750      /* Enable the Capture compare channel N */
;;;751      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;752      
;;;753      /* Enable the Main Ouput */
;;;754      __HAL_TIM_MOE_ENABLE(htim);
;;;755      
;;;756      /* Enable the Peripheral */
;;;757      __HAL_TIM_ENABLE(htim); 
;;;758      
;;;759      /* Return function status */
;;;760      return HAL_OK;
;;;761    }
00001c  bd70              POP      {r4-r6,pc}
                  |L21.30|
00001e  2002              MOVS     r0,#2                 ;677
000020  f8840039          STRB     r0,[r4,#0x39]         ;677
                  |L21.36|
000024  482b              LDR      r0,|L21.212|
000026  492c              LDR      r1,|L21.216|
000028  b135              CBZ      r5,|L21.56|
00002a  2d04              CMP      r5,#4                 ;680
00002c  d013              BEQ      |L21.86|
00002e  2d08              CMP      r5,#8                 ;680
000030  d031              BEQ      |L21.150|
000032  2d0c              CMP      r5,#0xc               ;680
000034  d11e              BNE      |L21.116|
000036  e03d              B        |L21.180|
                  |L21.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;685
00003a  63d0              STR      r0,[r2,#0x3c]         ;688
00003c  6a20              LDR      r0,[r4,#0x20]         ;688
00003e  6481              STR      r1,[r0,#0x48]         ;691
000040  6822              LDR      r2,[r4,#0]            ;691
000042  4631              MOV      r1,r6                 ;691
000044  3234              ADDS     r2,r2,#0x34           ;691
000046  6a20              LDR      r0,[r4,#0x20]         ;691
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;694
00004e  68c1              LDR      r1,[r0,#0xc]          ;694
000050  f4417100          ORR      r1,r1,#0x200          ;694
000054  e00d              B        |L21.114|
                  |L21.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;701
000058  63d0              STR      r0,[r2,#0x3c]         ;704
00005a  6a60              LDR      r0,[r4,#0x24]         ;704
00005c  6481              STR      r1,[r0,#0x48]         ;707
00005e  6822              LDR      r2,[r4,#0]            ;707
000060  4631              MOV      r1,r6                 ;707
000062  3238              ADDS     r2,r2,#0x38           ;707
000064  6a60              LDR      r0,[r4,#0x24]         ;707
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;710
00006c  68c1              LDR      r1,[r0,#0xc]          ;710
00006e  f4416180          ORR      r1,r1,#0x400          ;710
                  |L21.114|
000072  60c1              STR      r1,[r0,#0xc]          ;694
                  |L21.116|
000074  2204              MOVS     r2,#4                 ;751
000076  4629              MOV      r1,r5                 ;751
000078  6820              LDR      r0,[r4,#0]            ;751
00007a  f7fffffe          BL       TIM_CCxNChannelCmd
00007e  6820              LDR      r0,[r4,#0]            ;754
000080  6c41              LDR      r1,[r0,#0x44]         ;754
000082  f4414100          ORR      r1,r1,#0x8000         ;754
000086  6441              STR      r1,[r0,#0x44]         ;754
000088  6820              LDR      r0,[r4,#0]            ;757
00008a  6801              LDR      r1,[r0,#0]            ;757
00008c  f0410101          ORR      r1,r1,#1              ;757
000090  6001              STR      r1,[r0,#0]            ;757
000092  2000              MOVS     r0,#0                 ;760
000094  bd70              POP      {r4-r6,pc}
                  |L21.150|
000096  6aa2              LDR      r2,[r4,#0x28]         ;717
000098  63d0              STR      r0,[r2,#0x3c]         ;720
00009a  6aa0              LDR      r0,[r4,#0x28]         ;720
00009c  6481              STR      r1,[r0,#0x48]         ;723
00009e  6822              LDR      r2,[r4,#0]            ;723
0000a0  4631              MOV      r1,r6                 ;723
0000a2  323c              ADDS     r2,r2,#0x3c           ;723
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;723
0000a6  f7fffffe          BL       HAL_DMA_Start_IT
0000aa  6820              LDR      r0,[r4,#0]            ;726
0000ac  68c1              LDR      r1,[r0,#0xc]          ;726
0000ae  f4416100          ORR      r1,r1,#0x800          ;726
0000b2  e7de              B        |L21.114|
                  |L21.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;733
0000b6  63d0              STR      r0,[r2,#0x3c]         ;736
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;736
0000ba  6481              STR      r1,[r0,#0x48]         ;739
0000bc  6822              LDR      r2,[r4,#0]            ;739
0000be  4631              MOV      r1,r6                 ;739
0000c0  3240              ADDS     r2,r2,#0x40           ;739
0000c2  6ae0              LDR      r0,[r4,#0x2c]         ;739
0000c4  f7fffffe          BL       HAL_DMA_Start_IT
0000c8  6820              LDR      r0,[r4,#0]            ;742
0000ca  68c1              LDR      r1,[r0,#0xc]          ;742
0000cc  f4415180          ORR      r1,r1,#0x1000         ;742
0000d0  e7cf              B        |L21.114|
;;;762    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L21.212|
                          DCD      HAL_TIM_DMADelayPulseCplt
                  |L21.216|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;529      */
;;;530    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;531    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L22.22|
;;;532      /* Check the parameters */
;;;533      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;534      
;;;535      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L22.30|
00000c  2908              CMP      r1,#8
00000e  d01a              BEQ      |L22.70|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L22.38|
000014  e01b              B        |L22.78|
                  |L22.22|
;;;536      {
;;;537        case TIM_CHANNEL_1:
;;;538        {       
;;;539          /* Enable the TIM Output Compare interrupt */
;;;540          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;541        }
;;;542        break;
00001c  e002              B        |L22.36|
                  |L22.30|
;;;543        
;;;544        case TIM_CHANNEL_2:
;;;545        {
;;;546          /* Enable the TIM Output Compare interrupt */
;;;547          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L22.36|
000024  60d0              STR      r0,[r2,#0xc]          ;540
                  |L22.38|
;;;548        }
;;;549        break;
;;;550        
;;;551        case TIM_CHANNEL_3:
;;;552        {
;;;553          /* Enable the TIM Output Compare interrupt */
;;;554          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;555        }
;;;556        break;
;;;557        
;;;558        case TIM_CHANNEL_4:
;;;559        {
;;;560          /* Enable the TIM Output Compare interrupt */
;;;561          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;562        }
;;;563        break;
;;;564        
;;;565        default:
;;;566        break;
;;;567      } 
;;;568      
;;;569         /* Enable the Capture compare channel N */
;;;570         TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000026  2204              MOVS     r2,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;571        
;;;572      /* Enable the Main Ouput */
;;;573        __HAL_TIM_MOE_ENABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6c41              LDR      r1,[r0,#0x44]
000032  f4414100          ORR      r1,r1,#0x8000
000036  6441              STR      r1,[r0,#0x44]
;;;574    
;;;575      /* Enable the Peripheral */
;;;576      __HAL_TIM_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6801              LDR      r1,[r0,#0]
00003c  f0410101          ORR      r1,r1,#1
000040  6001              STR      r1,[r0,#0]
;;;577      
;;;578      /* Return function status */
;;;579      return HAL_OK;
000042  2000              MOVS     r0,#0
;;;580    } 
000044  bd10              POP      {r4,pc}
                  |L22.70|
000046  68d0              LDR      r0,[r2,#0xc]          ;554
000048  f0400008          ORR      r0,r0,#8              ;554
00004c  e7ea              B        |L22.36|
                  |L22.78|
00004e  68d0              LDR      r0,[r2,#0xc]          ;561
000050  f0400010          ORR      r0,r0,#0x10           ;561
000054  e7e6              B        |L22.36|
;;;581    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;499      */
;;;500    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;501    { 
000002  4604              MOV      r4,r0
;;;502      /* Check the parameters */
;;;503      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;504      
;;;505        /* Disable the Capture compare channel N */
;;;506      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;507        
;;;508      /* Disable the Main Ouput */
;;;509        __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L23.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L23.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L23.42|
;;;510    
;;;511      /* Disable the Peripheral */
;;;512      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L23.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L23.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L23.64|
;;;513      
;;;514      /* Return function status */
;;;515      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;516    } 
000042  bd10              POP      {r4,pc}
;;;517    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;774      */
;;;775    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;776    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L24.22|
;;;777      /* Check the parameters */
;;;778      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;779      
;;;780      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L24.30|
00000c  2908              CMP      r1,#8
00000e  d02d              BEQ      |L24.108|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L24.38|
000014  e02e              B        |L24.116|
                  |L24.22|
;;;781      {
;;;782        case TIM_CHANNEL_1:
;;;783        {       
;;;784          /* Disable the TIM Output Compare DMA request */
;;;785          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;786        }
;;;787        break;
00001c  e002              B        |L24.36|
                  |L24.30|
;;;788        
;;;789        case TIM_CHANNEL_2:
;;;790        {
;;;791          /* Disable the TIM Output Compare DMA request */
;;;792          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L24.36|
000024  60d0              STR      r0,[r2,#0xc]          ;785
                  |L24.38|
;;;793        }
;;;794        break;
;;;795        
;;;796        case TIM_CHANNEL_3:
;;;797        {
;;;798          /* Disable the TIM Output Compare DMA request */
;;;799          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;800        }
;;;801        break;
;;;802        
;;;803        case TIM_CHANNEL_4:
;;;804        {
;;;805          /* Disable the TIM Output Compare interrupt */
;;;806          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;807        }
;;;808        break;
;;;809        
;;;810        default:
;;;811        break;
;;;812      } 
;;;813      
;;;814      /* Disable the Capture compare channel N */
;;;815      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;816      
;;;817      /* Disable the Main Ouput */
;;;818      __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4213              TST      r3,r2
000038  f2404144          MOV      r1,#0x444
00003c  d106              BNE      |L24.76|
00003e  6a03              LDR      r3,[r0,#0x20]
000040  420b              TST      r3,r1
000042  d103              BNE      |L24.76|
000044  6c43              LDR      r3,[r0,#0x44]
000046  f4234300          BIC      r3,r3,#0x8000
00004a  6443              STR      r3,[r0,#0x44]
                  |L24.76|
;;;819      
;;;820      /* Disable the Peripheral */
;;;821      __HAL_TIM_DISABLE(htim);
00004c  6820              LDR      r0,[r4,#0]
00004e  6a03              LDR      r3,[r0,#0x20]
000050  4213              TST      r3,r2
000052  d106              BNE      |L24.98|
000054  6a02              LDR      r2,[r0,#0x20]
000056  420a              TST      r2,r1
000058  d103              BNE      |L24.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L24.98|
;;;822      
;;;823      /* Change the htim state */
;;;824      htim->State = HAL_TIM_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f8840039          STRB     r0,[r4,#0x39]
;;;825      
;;;826      /* Return function status */
;;;827      return HAL_OK;
000068  2000              MOVS     r0,#0
;;;828    }
00006a  bd10              POP      {r4,pc}
                  |L24.108|
00006c  68d0              LDR      r0,[r2,#0xc]          ;799
00006e  f4206000          BIC      r0,r0,#0x800          ;799
000072  e7d7              B        |L24.36|
                  |L24.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;806
000076  f4205080          BIC      r0,r0,#0x1000         ;806
00007a  e7d3              B        |L24.36|
;;;829    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;593      */
;;;594    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;595    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L25.22|
;;;596      /* Check the parameters */
;;;597      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;598      
;;;599      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L25.30|
00000c  2908              CMP      r1,#8
00000e  d02a              BEQ      |L25.102|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L25.38|
000014  e02b              B        |L25.110|
                  |L25.22|
;;;600      {
;;;601        case TIM_CHANNEL_1:
;;;602        {       
;;;603          /* Disable the TIM Output Compare interrupt */
;;;604          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;605        }
;;;606        break;
00001c  e002              B        |L25.36|
                  |L25.30|
;;;607        
;;;608        case TIM_CHANNEL_2:
;;;609        {
;;;610          /* Disable the TIM Output Compare interrupt */
;;;611          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L25.36|
000024  60d0              STR      r0,[r2,#0xc]          ;604
                  |L25.38|
;;;612        }
;;;613        break;
;;;614        
;;;615        case TIM_CHANNEL_3:
;;;616        {
;;;617          /* Disable the TIM Output Compare interrupt */
;;;618          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;619        }
;;;620        break;
;;;621        
;;;622        case TIM_CHANNEL_4:
;;;623        {
;;;624          /* Disable the TIM Output Compare interrupt */
;;;625          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;626        }
;;;627        break;
;;;628        
;;;629        default:
;;;630        break; 
;;;631      }
;;;632        
;;;633         /* Disable the Capture compare channel N */
;;;634         TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;635        
;;;636      /* Disable the Main Ouput */
;;;637        __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  f2411111          MOV      r1,#0x1111
000036  420b              TST      r3,r1
000038  f2404244          MOV      r2,#0x444
00003c  d106              BNE      |L25.76|
00003e  6a03              LDR      r3,[r0,#0x20]
000040  4213              TST      r3,r2
000042  d103              BNE      |L25.76|
000044  6c43              LDR      r3,[r0,#0x44]
000046  f4234300          BIC      r3,r3,#0x8000
00004a  6443              STR      r3,[r0,#0x44]
                  |L25.76|
;;;638    
;;;639      /* Disable the Peripheral */
;;;640      __HAL_TIM_DISABLE(htim);
00004c  6820              LDR      r0,[r4,#0]
00004e  6a03              LDR      r3,[r0,#0x20]
000050  420b              TST      r3,r1
000052  d106              BNE      |L25.98|
000054  6a01              LDR      r1,[r0,#0x20]
000056  4211              TST      r1,r2
000058  d103              BNE      |L25.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L25.98|
;;;641      
;;;642      /* Return function status */
;;;643      return HAL_OK;
000062  2000              MOVS     r0,#0
;;;644    } 
000064  bd10              POP      {r4,pc}
                  |L25.102|
000066  68d0              LDR      r0,[r2,#0xc]          ;618
000068  f0200008          BIC      r0,r0,#8              ;618
00006c  e7da              B        |L25.36|
                  |L25.110|
00006e  68d0              LDR      r0,[r2,#0xc]          ;625
000070  f0200010          BIC      r0,r0,#0x10           ;625
000074  e7d6              B        |L25.36|
;;;645    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1271     */
;;;1272   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1273     {
000002  4604              MOV      r4,r0
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1276     
;;;1277     /* Enable the complementary One Pulse output */
;;;1278     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1279     
;;;1280     /* Enable the Main Ouput */
;;;1281     __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;1282     
;;;1283     /* Return function status */
;;;1284     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1285   }
000018  bd10              POP      {r4,pc}
;;;1286   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1325     */
;;;1326   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1327   {
000002  4604              MOV      r4,r0
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1330   
;;;1331     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1332     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0420202          ORR      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1333     
;;;1334     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1335     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0420204          ORR      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1336     
;;;1337     /* Enable the complementary One Pulse output */
;;;1338     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
000018  2204              MOVS     r2,#4
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1339     
;;;1340     /* Enable the Main Ouput */
;;;1341     __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c41              LDR      r1,[r0,#0x44]
000024  f4414100          ORR      r1,r1,#0x8000
000028  6441              STR      r1,[r0,#0x44]
;;;1342     
;;;1343     /* Return function status */
;;;1344     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;1345     } 
00002c  bd10              POP      {r4,pc}
;;;1346     
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1298   {
000002  4604              MOV      r4,r0
;;;1299   
;;;1300     /* Check the parameters */
;;;1301     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1302   
;;;1303     /* Disable the complementary One Pulse output */
;;;1304       TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1305     
;;;1306     /* Disable the Main Ouput */
;;;1307       __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L28.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L28.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L28.42|
;;;1308     
;;;1309     /* Disable the Peripheral */
;;;1310     __HAL_TIM_DISABLE(htim); 
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L28.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L28.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L28.64|
;;;1311      
;;;1312     /* Return function status */
;;;1313     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1314   }
000042  bd10              POP      {r4,pc}
;;;1315   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1356     */
;;;1357   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1358   {
000002  4604              MOV      r4,r0
;;;1359     /* Check the parameters */
;;;1360     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1361   
;;;1362     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1363     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0220202          BIC      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1364     
;;;1365     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1366     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0220204          BIC      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1367     
;;;1368     /* Disable the complementary One Pulse output */
;;;1369     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000018  2200              MOVS     r2,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1370     
;;;1371     /* Disable the Main Ouput */
;;;1372     __HAL_TIM_MOE_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6a03              LDR      r3,[r0,#0x20]
000024  f2411111          MOV      r1,#0x1111
000028  420b              TST      r3,r1
00002a  f2404244          MOV      r2,#0x444
00002e  d106              BNE      |L29.62|
000030  6a03              LDR      r3,[r0,#0x20]
000032  4213              TST      r3,r2
000034  d103              BNE      |L29.62|
000036  6c43              LDR      r3,[r0,#0x44]
000038  f4234300          BIC      r3,r3,#0x8000
00003c  6443              STR      r3,[r0,#0x44]
                  |L29.62|
;;;1373     
;;;1374     /* Disable the Peripheral */
;;;1375      __HAL_TIM_DISABLE(htim);  
00003e  6820              LDR      r0,[r4,#0]
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L29.84|
000046  6a01              LDR      r1,[r0,#0x20]
000048  4211              TST      r1,r2
00004a  d103              BNE      |L29.84|
00004c  6801              LDR      r1,[r0,#0]
00004e  f0210101          BIC      r1,r1,#1
000052  6001              STR      r1,[r0,#0]
                  |L29.84|
;;;1376     
;;;1377     /* Return function status */
;;;1378     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1379   }
000056  bd10              POP      {r4,pc}
;;;1380   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;874      */
;;;875    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;876    {
000002  4604              MOV      r4,r0
;;;877      /* Check the parameters */
;;;878      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;879      
;;;880      /* Enable the complementary PWM output  */
;;;881      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  2204              MOVS     r2,#4
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;882      
;;;883      /* Enable the Main Ouput */
;;;884      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;885      
;;;886      /* Enable the Peripheral */
;;;887      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;888      
;;;889      /* Return function status */
;;;890      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;891    } 
000022  bd10              POP      {r4,pc}
;;;892    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1069     */
;;;1070   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1071   {
000002  4604              MOV      r4,r0
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1074     
;;;1075     if((htim->State == HAL_TIM_STATE_BUSY))
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  4616              MOV      r6,r2                 ;1071
00000a  460d              MOV      r5,r1                 ;1071
00000c  2802              CMP      r0,#2
00000e  d005              BEQ      |L31.28|
;;;1076     {
;;;1077        return HAL_BUSY;
;;;1078     }
;;;1079     else if((htim->State == HAL_TIM_STATE_READY))
000010  f8940039          LDRB     r0,[r4,#0x39]
000014  2801              CMP      r0,#1
000016  d105              BNE      |L31.36|
;;;1080     {
;;;1081       if(((uint32_t)pData == 0 ) && (Length > 0)) 
000018  b90e              CBNZ     r6,|L31.30|
00001a  b103              CBZ      r3,|L31.30|
                  |L31.28|
;;;1082       {
;;;1083         return HAL_ERROR;                                    
;;;1084       }
;;;1085       else
;;;1086       {
;;;1087         htim->State = HAL_TIM_STATE_BUSY;
;;;1088       }
;;;1089     }    
;;;1090     switch (Channel)
;;;1091     {
;;;1092       case TIM_CHANNEL_1:
;;;1093       {      
;;;1094         /* Set the DMA Period elapsed callback */
;;;1095         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1096        
;;;1097         /* Set the DMA error callback */
;;;1098         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1099         
;;;1100         /* Enable the DMA Stream */
;;;1101         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1102         
;;;1103         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1104         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1105       }
;;;1106       break;
;;;1107       
;;;1108       case TIM_CHANNEL_2:
;;;1109       {
;;;1110         /* Set the DMA Period elapsed callback */
;;;1111         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1112        
;;;1113         /* Set the DMA error callback */
;;;1114         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1115         
;;;1116         /* Enable the DMA Stream */
;;;1117         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1118         
;;;1119         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1120         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1121       }
;;;1122       break;
;;;1123       
;;;1124       case TIM_CHANNEL_3:
;;;1125       {
;;;1126         /* Set the DMA Period elapsed callback */
;;;1127         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1128        
;;;1129         /* Set the DMA error callback */
;;;1130         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1131         
;;;1132         /* Enable the DMA Stream */
;;;1133         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1134         
;;;1135         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1136         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1137       }
;;;1138       break;
;;;1139       
;;;1140       case TIM_CHANNEL_4:
;;;1141       {
;;;1142        /* Set the DMA Period elapsed callback */
;;;1143         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1144        
;;;1145         /* Set the DMA error callback */
;;;1146         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1147         
;;;1148         /* Enable the DMA Stream */
;;;1149         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1150         
;;;1151         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1152         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1153       }
;;;1154       break;
;;;1155       
;;;1156       default:
;;;1157       break;
;;;1158     }
;;;1159   
;;;1160     /* Enable the complementary PWM output  */
;;;1161        TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1162       
;;;1163     /* Enable the Main Ouput */
;;;1164       __HAL_TIM_MOE_ENABLE(htim);
;;;1165     
;;;1166     /* Enable the Peripheral */
;;;1167     __HAL_TIM_ENABLE(htim); 
;;;1168     
;;;1169     /* Return function status */
;;;1170     return HAL_OK;
;;;1171   }
00001c  bd70              POP      {r4-r6,pc}
                  |L31.30|
00001e  2002              MOVS     r0,#2                 ;1087
000020  f8840039          STRB     r0,[r4,#0x39]         ;1087
                  |L31.36|
000024  482b              LDR      r0,|L31.212|
000026  492c              LDR      r1,|L31.216|
000028  b135              CBZ      r5,|L31.56|
00002a  2d04              CMP      r5,#4                 ;1090
00002c  d013              BEQ      |L31.86|
00002e  2d08              CMP      r5,#8                 ;1090
000030  d031              BEQ      |L31.150|
000032  2d0c              CMP      r5,#0xc               ;1090
000034  d11e              BNE      |L31.116|
000036  e03d              B        |L31.180|
                  |L31.56|
000038  6a22              LDR      r2,[r4,#0x20]         ;1095
00003a  63d0              STR      r0,[r2,#0x3c]         ;1098
00003c  6a20              LDR      r0,[r4,#0x20]         ;1098
00003e  6481              STR      r1,[r0,#0x48]         ;1101
000040  6822              LDR      r2,[r4,#0]            ;1101
000042  4631              MOV      r1,r6                 ;1101
000044  3234              ADDS     r2,r2,#0x34           ;1101
000046  6a20              LDR      r0,[r4,#0x20]         ;1101
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  6820              LDR      r0,[r4,#0]            ;1104
00004e  68c1              LDR      r1,[r0,#0xc]          ;1104
000050  f4417100          ORR      r1,r1,#0x200          ;1104
000054  e00d              B        |L31.114|
                  |L31.86|
000056  6a62              LDR      r2,[r4,#0x24]         ;1111
000058  63d0              STR      r0,[r2,#0x3c]         ;1114
00005a  6a60              LDR      r0,[r4,#0x24]         ;1114
00005c  6481              STR      r1,[r0,#0x48]         ;1117
00005e  6822              LDR      r2,[r4,#0]            ;1117
000060  4631              MOV      r1,r6                 ;1117
000062  3238              ADDS     r2,r2,#0x38           ;1117
000064  6a60              LDR      r0,[r4,#0x24]         ;1117
000066  f7fffffe          BL       HAL_DMA_Start_IT
00006a  6820              LDR      r0,[r4,#0]            ;1120
00006c  68c1              LDR      r1,[r0,#0xc]          ;1120
00006e  f4416180          ORR      r1,r1,#0x400          ;1120
                  |L31.114|
000072  60c1              STR      r1,[r0,#0xc]          ;1104
                  |L31.116|
000074  2204              MOVS     r2,#4                 ;1161
000076  4629              MOV      r1,r5                 ;1161
000078  6820              LDR      r0,[r4,#0]            ;1161
00007a  f7fffffe          BL       TIM_CCxNChannelCmd
00007e  6820              LDR      r0,[r4,#0]            ;1164
000080  6c41              LDR      r1,[r0,#0x44]         ;1164
000082  f4414100          ORR      r1,r1,#0x8000         ;1164
000086  6441              STR      r1,[r0,#0x44]         ;1164
000088  6820              LDR      r0,[r4,#0]            ;1167
00008a  6801              LDR      r1,[r0,#0]            ;1167
00008c  f0410101          ORR      r1,r1,#1              ;1167
000090  6001              STR      r1,[r0,#0]            ;1167
000092  2000              MOVS     r0,#0                 ;1170
000094  bd70              POP      {r4-r6,pc}
                  |L31.150|
000096  6aa2              LDR      r2,[r4,#0x28]         ;1127
000098  63d0              STR      r0,[r2,#0x3c]         ;1130
00009a  6aa0              LDR      r0,[r4,#0x28]         ;1130
00009c  6481              STR      r1,[r0,#0x48]         ;1133
00009e  6822              LDR      r2,[r4,#0]            ;1133
0000a0  4631              MOV      r1,r6                 ;1133
0000a2  323c              ADDS     r2,r2,#0x3c           ;1133
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;1133
0000a6  f7fffffe          BL       HAL_DMA_Start_IT
0000aa  6820              LDR      r0,[r4,#0]            ;1136
0000ac  68c1              LDR      r1,[r0,#0xc]          ;1136
0000ae  f4416100          ORR      r1,r1,#0x800          ;1136
0000b2  e7de              B        |L31.114|
                  |L31.180|
0000b4  6ae2              LDR      r2,[r4,#0x2c]         ;1143
0000b6  63d0              STR      r0,[r2,#0x3c]         ;1146
0000b8  6ae0              LDR      r0,[r4,#0x2c]         ;1146
0000ba  6481              STR      r1,[r0,#0x48]         ;1149
0000bc  6822              LDR      r2,[r4,#0]            ;1149
0000be  4631              MOV      r1,r6                 ;1149
0000c0  3240              ADDS     r2,r2,#0x40           ;1149
0000c2  6ae0              LDR      r0,[r4,#0x2c]         ;1149
0000c4  f7fffffe          BL       HAL_DMA_Start_IT
0000c8  6820              LDR      r0,[r4,#0]            ;1152
0000ca  68c1              LDR      r1,[r0,#0xc]          ;1152
0000cc  f4415180          ORR      r1,r1,#0x1000         ;1152
0000d0  e7cf              B        |L31.114|
;;;1172   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L31.212|
                          DCD      HAL_TIM_DMADelayPulseCplt
                  |L31.216|
                          DCD      HAL_TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;933      */
;;;934    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;935    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L32.22|
;;;936      /* Check the parameters */
;;;937      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;938      
;;;939      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L32.30|
00000c  2908              CMP      r1,#8
00000e  d01f              BEQ      |L32.80|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L32.38|
000014  e020              B        |L32.88|
                  |L32.22|
;;;940      {
;;;941        case TIM_CHANNEL_1:
;;;942        {       
;;;943          /* Enable the TIM Capture/Compare 1 interrupt */
;;;944          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;945        }
;;;946        break;
00001c  e002              B        |L32.36|
                  |L32.30|
;;;947        
;;;948        case TIM_CHANNEL_2:
;;;949        {
;;;950          /* Enable the TIM Capture/Compare 2 interrupt */
;;;951          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L32.36|
000024  60d0              STR      r0,[r2,#0xc]          ;944
                  |L32.38|
;;;952        }
;;;953        break;
;;;954        
;;;955        case TIM_CHANNEL_3:
;;;956        {
;;;957          /* Enable the TIM Capture/Compare 3 interrupt */
;;;958          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;959        }
;;;960        break;
;;;961        
;;;962        case TIM_CHANNEL_4:
;;;963        {
;;;964          /* Enable the TIM Capture/Compare 4 interrupt */
;;;965          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;966        }
;;;967        break;
;;;968        
;;;969        default:
;;;970        break;
;;;971      } 
;;;972      
;;;973      /* Enable the TIM Break interrupt */
;;;974      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0420280          ORR      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;975      
;;;976      /* Enable the complementary PWM output  */
;;;977      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000030  2204              MOVS     r2,#4
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;978      
;;;979      /* Enable the Main Ouput */
;;;980      __HAL_TIM_MOE_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
;;;981      
;;;982      /* Enable the Peripheral */
;;;983      __HAL_TIM_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f0410101          ORR      r1,r1,#1
00004a  6001              STR      r1,[r0,#0]
;;;984      
;;;985      /* Return function status */
;;;986      return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;987    } 
00004e  bd10              POP      {r4,pc}
                  |L32.80|
000050  68d0              LDR      r0,[r2,#0xc]          ;958
000052  f0400008          ORR      r0,r0,#8              ;958
000056  e7e5              B        |L32.36|
                  |L32.88|
000058  68d0              LDR      r0,[r2,#0xc]          ;965
00005a  f0400010          ORR      r0,r0,#0x10           ;965
00005e  e7e1              B        |L32.36|
;;;988    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;903      */
;;;904    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;905    { 
000002  4604              MOV      r4,r0
;;;906      /* Check the parameters */
;;;907      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;908      
;;;909      /* Disable the complementary PWM output  */
;;;910      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);  
000004  6800              LDR      r0,[r0,#0]
000006  2200              MOVS     r2,#0
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;911      
;;;912      /* Disable the Main Ouput */
;;;913      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6a03              LDR      r3,[r0,#0x20]
000010  f2411111          MOV      r1,#0x1111
000014  420b              TST      r3,r1
000016  f2404244          MOV      r2,#0x444
00001a  d106              BNE      |L33.42|
00001c  6a03              LDR      r3,[r0,#0x20]
00001e  4213              TST      r3,r2
000020  d103              BNE      |L33.42|
000022  6c43              LDR      r3,[r0,#0x44]
000024  f4234300          BIC      r3,r3,#0x8000
000028  6443              STR      r3,[r0,#0x44]
                  |L33.42|
;;;914      
;;;915      /* Disable the Peripheral */
;;;916      __HAL_TIM_DISABLE(htim);
00002a  6820              LDR      r0,[r4,#0]
00002c  6a03              LDR      r3,[r0,#0x20]
00002e  420b              TST      r3,r1
000030  d106              BNE      |L33.64|
000032  6a01              LDR      r1,[r0,#0x20]
000034  4211              TST      r1,r2
000036  d103              BNE      |L33.64|
000038  6801              LDR      r1,[r0,#0]
00003a  f0210101          BIC      r1,r1,#1
00003e  6001              STR      r1,[r0,#0]
                  |L33.64|
;;;917      
;;;918      /* Return function status */
;;;919      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;920    } 
000042  bd10              POP      {r4,pc}
;;;921    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1184     */
;;;1185   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1186   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L34.22|
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1189     
;;;1190     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L34.30|
00000c  2908              CMP      r1,#8
00000e  d02d              BEQ      |L34.108|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L34.38|
000014  e02e              B        |L34.116|
                  |L34.22|
;;;1191     {
;;;1192       case TIM_CHANNEL_1:
;;;1193       {       
;;;1194         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1195         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1196       }
;;;1197       break;
00001c  e002              B        |L34.36|
                  |L34.30|
;;;1198       
;;;1199       case TIM_CHANNEL_2:
;;;1200       {
;;;1201         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1202         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L34.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1195
                  |L34.38|
;;;1203       }
;;;1204       break;
;;;1205       
;;;1206       case TIM_CHANNEL_3:
;;;1207       {
;;;1208         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1209         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1210       }
;;;1211       break;
;;;1212       
;;;1213       case TIM_CHANNEL_4:
;;;1214       {
;;;1215         /* Disable the TIM Capture/Compare 4 DMA request */
;;;1216         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1217       }
;;;1218       break;
;;;1219       
;;;1220       default:
;;;1221       break;
;;;1222     } 
;;;1223     
;;;1224     /* Disable the complementary PWM output */
;;;1225       TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  2200              MOVS     r2,#0
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1226        
;;;1227     /* Disable the Main Ouput */
;;;1228       __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  6a03              LDR      r3,[r0,#0x20]
000032  f2411211          MOV      r2,#0x1111
000036  4213              TST      r3,r2
000038  f2404144          MOV      r1,#0x444
00003c  d106              BNE      |L34.76|
00003e  6a03              LDR      r3,[r0,#0x20]
000040  420b              TST      r3,r1
000042  d103              BNE      |L34.76|
000044  6c43              LDR      r3,[r0,#0x44]
000046  f4234300          BIC      r3,r3,#0x8000
00004a  6443              STR      r3,[r0,#0x44]
                  |L34.76|
;;;1229   
;;;1230     /* Disable the Peripheral */
;;;1231     __HAL_TIM_DISABLE(htim);
00004c  6820              LDR      r0,[r4,#0]
00004e  6a03              LDR      r3,[r0,#0x20]
000050  4213              TST      r3,r2
000052  d106              BNE      |L34.98|
000054  6a02              LDR      r2,[r0,#0x20]
000056  420a              TST      r2,r1
000058  d103              BNE      |L34.98|
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  6001              STR      r1,[r0,#0]
                  |L34.98|
;;;1232     
;;;1233     /* Change the htim state */
;;;1234     htim->State = HAL_TIM_STATE_READY;
000062  2001              MOVS     r0,#1
000064  f8840039          STRB     r0,[r4,#0x39]
;;;1235     
;;;1236     /* Return function status */
;;;1237     return HAL_OK;
000068  2000              MOVS     r0,#0
;;;1238   }
00006a  bd10              POP      {r4,pc}
                  |L34.108|
00006c  68d0              LDR      r0,[r2,#0xc]          ;1209
00006e  f4206000          BIC      r0,r0,#0x800          ;1209
000072  e7d7              B        |L34.36|
                  |L34.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1216
000076  f4205080          BIC      r0,r0,#0x1000         ;1216
00007a  e7d3              B        |L34.36|
;;;1239   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1000     */
;;;1001   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1002   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L35.22|
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1005   
;;;1006     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L35.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L35.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L35.38|
000014  e030              B        |L35.120|
                  |L35.22|
;;;1007     {
;;;1008       case TIM_CHANNEL_1:
;;;1009       {       
;;;1010         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1011         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1012       }
;;;1013       break;
00001c  e002              B        |L35.36|
                  |L35.30|
;;;1014       
;;;1015       case TIM_CHANNEL_2:
;;;1016       {
;;;1017         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1018         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L35.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1011
                  |L35.38|
;;;1019       }
;;;1020       break;
;;;1021       
;;;1022       case TIM_CHANNEL_3:
;;;1023       {
;;;1024         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1025         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1026       }
;;;1027       break;
;;;1028       
;;;1029       case TIM_CHANNEL_4:
;;;1030       {
;;;1031         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1032         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1033       }
;;;1034       break;
;;;1035       
;;;1036       default:
;;;1037       break; 
;;;1038     }
;;;1039     
;;;1040     /* Disable the TIM Break interrupt */
;;;1041     __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0220280          BIC      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;1042     
;;;1043     /* Disable the complementary PWM output  */
;;;1044     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000030  2200              MOVS     r2,#0
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1045     
;;;1046     /* Disable the Main Ouput */
;;;1047     __HAL_TIM_MOE_DISABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6a03              LDR      r3,[r0,#0x20]
00003c  f2411111          MOV      r1,#0x1111
000040  420b              TST      r3,r1
000042  f2404244          MOV      r2,#0x444
000046  d106              BNE      |L35.86|
000048  6a03              LDR      r3,[r0,#0x20]
00004a  4213              TST      r3,r2
00004c  d103              BNE      |L35.86|
00004e  6c43              LDR      r3,[r0,#0x44]
000050  f4234300          BIC      r3,r3,#0x8000
000054  6443              STR      r3,[r0,#0x44]
                  |L35.86|
;;;1048     
;;;1049     /* Disable the Peripheral */
;;;1050     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a03              LDR      r3,[r0,#0x20]
00005a  420b              TST      r3,r1
00005c  d106              BNE      |L35.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L35.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L35.108|
;;;1051     
;;;1052     /* Return function status */
;;;1053     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1054   } 
00006e  bd10              POP      {r4,pc}
                  |L35.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1025
000072  f0200008          BIC      r0,r0,#8              ;1025
000076  e7d5              B        |L35.36|
                  |L35.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;1032
00007a  f0200010          BIC      r0,r0,#0x10           ;1032
00007e  e7d1              B        |L35.36|
;;;1055   
                          ENDP


                          AREA ||i.HAL_TIMEx_RemapConfig||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_RemapConfig PROC
;;;1659     */
;;;1660   HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
000000  f8902038          LDRB     r2,[r0,#0x38]
;;;1661   {
;;;1662     __HAL_LOCK(htim);
000004  2a01              CMP      r2,#1
000006  d00a              BEQ      |L36.30|
000008  2201              MOVS     r2,#1
00000a  f8002f38          STRB     r2,[r0,#0x38]!
;;;1663       
;;;1664     /* Check parameters */
;;;1665     assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
;;;1666     assert_param(IS_TIM_REMAP(Remap));
;;;1667     
;;;1668     /* Set the Timer remapping configuration */
;;;1669     htim->Instance->OR = Remap;
00000e  f8503c38          LDR      r3,[r0,#-0x38]
000012  6519              STR      r1,[r3,#0x50]
;;;1670     
;;;1671     htim->State = HAL_TIM_STATE_READY;
000014  7042              STRB     r2,[r0,#1]
;;;1672     
;;;1673     __HAL_UNLOCK(htim);  
000016  2100              MOVS     r1,#0
000018  7001              STRB     r1,[r0,#0]
;;;1674     
;;;1675     return HAL_OK;
00001a  4608              MOV      r0,r1
;;;1676   }
00001c  4770              BX       lr
                  |L36.30|
00001e  2002              MOVS     r0,#2                 ;1662
000020  4770              BX       lr
;;;1677   
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;1780     */
;;;1781   static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;1782   {
;;;1783     uint32_t tmp = 0;
;;;1784   
;;;1785     /* Check the parameters */
;;;1786     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1787     assert_param(IS_TIM_COMPLEMENTARY_CHANNELS(Channel));
;;;1788   
;;;1789     tmp = TIM_CCER_CC1NE << Channel;
000002  2304              MOVS     r3,#4
;;;1790   
;;;1791     /* Reset the CCxNE Bit */
;;;1792     TIMx->CCER &= ~tmp;
000004  6a04              LDR      r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1789
000008  439c              BICS     r4,r4,r3
00000a  6204              STR      r4,[r0,#0x20]
;;;1793   
;;;1794     /* Set or reset the CCxNE Bit */ 
;;;1795     TIMx->CCER |= (uint32_t)(ChannelNState << Channel);
00000c  6a03              LDR      r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6203              STR      r3,[r0,#0x20]
;;;1796   }
000014  bd10              POP      {r4,pc}
;;;1797   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f2xx_hal_tim_ex_c_e8ef3920____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___22_stm32f2xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f2xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 144
|__asm___22_stm32f2xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
