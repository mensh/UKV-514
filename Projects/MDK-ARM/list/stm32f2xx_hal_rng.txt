; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\stm32f2xx_hal_rng.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\stm32f2xx_hal_rng.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\stm32f2xx_hal_rng.crf" ..\..\Drivers\STM32F2xx_HAL_Driver\Src\stm32f2xx_hal_rng.c]
                          THUMB

                          AREA ||i.HAL_RNG_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_RNG_DeInit PROC
;;;136      */
;;;137    HAL_StatusTypeDef HAL_RNG_DeInit(RNG_HandleTypeDef *hrng)
000000  b570              PUSH     {r4-r6,lr}
;;;138    { 
000002  4604              MOV      r4,r0
;;;139      /* Check the RNG peripheral state */
;;;140      if(hrng->State == HAL_RNG_STATE_BUSY)
000004  7940              LDRB     r0,[r0,#5]
000006  2802              CMP      r0,#2
000008  d01a              BEQ      |L1.64|
;;;141      {
;;;142        return HAL_BUSY;
;;;143      }
;;;144      
;;;145      /* Update the RNG state */  
;;;146      hrng->State = HAL_RNG_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  7160              STRB     r0,[r4,#5]
;;;147      
;;;148      /* Disable the RNG Peripheral */
;;;149      __HAL_RNG_DISABLE(hrng);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0210104          BIC      r1,r1,#4
000016  6001              STR      r1,[r0,#0]
;;;150      
;;;151      /* Set the RNG registers to their reset values */
;;;152      hrng->Instance->CR &= 0xFFFFFFF3;
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f021010c          BIC      r1,r1,#0xc
000020  6001              STR      r1,[r0,#0]
;;;153      hrng->Instance->SR &= 0xFFFFFF98;
000022  6820              LDR      r0,[r4,#0]
000024  6841              LDR      r1,[r0,#4]
000026  f0210167          BIC      r1,r1,#0x67
00002a  6041              STR      r1,[r0,#4]
;;;154      hrng->Instance->DR &= 0x0;
00002c  6820              LDR      r0,[r4,#0]
00002e  6881              LDR      r1,[r0,#8]
000030  2500              MOVS     r5,#0
000032  6085              STR      r5,[r0,#8]
;;;155      
;;;156      /* DeInit the low level hardware */
;;;157      HAL_RNG_MspDeInit(hrng);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_RNG_MspDeInit
;;;158      
;;;159      /* Update the RNG state */
;;;160      hrng->State = HAL_RNG_STATE_RESET; 
00003a  7165              STRB     r5,[r4,#5]
;;;161    
;;;162      /* Release Lock */
;;;163      __HAL_UNLOCK(hrng);
00003c  7125              STRB     r5,[r4,#4]
;;;164      
;;;165      /* Return the function status */
;;;166      return HAL_OK;
00003e  2000              MOVS     r0,#0
                  |L1.64|
;;;167    }
000040  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP


                          AREA ||i.HAL_RNG_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_RNG_ErrorCallback PROC
;;;359      */
;;;360    __weak void HAL_RNG_ErrorCallback(RNG_HandleTypeDef *hrng)
000000  4770              BX       lr
;;;361    {
;;;362      /* NOTE : This function Should not be modified, when the callback is needed,
;;;363                the HAL_RNG_ErrorCallback could be implemented in the user file
;;;364       */ 
;;;365    }
;;;366     
                          ENDP


                          AREA ||i.HAL_RNG_GetRandomNumber||, CODE, READONLY, ALIGN=1

                  HAL_RNG_GetRandomNumber PROC
;;;220      */
;;;221    uint32_t HAL_RNG_GetRandomNumber(RNG_HandleTypeDef *hrng)
000000  b570              PUSH     {r4-r6,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223      uint32_t random32bit = 0;
;;;224      uint32_t timeout = 0;   
;;;225      
;;;226      /* Process Locked */
;;;227      __HAL_LOCK(hrng); 
000004  7900              LDRB     r0,[r0,#4]
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L3.24|
00000a  2001              MOVS     r0,#1
00000c  7120              STRB     r0,[r4,#4]
;;;228      
;;;229      timeout = HAL_GetTick() + RNG_TIMEOUT_VALUE;
00000e  f7fffffe          BL       HAL_GetTick
000012  f500757a          ADD      r5,r0,#0x3e8
000016  e007              B        |L3.40|
                  |L3.24|
000018  2002              MOVS     r0,#2                 ;227
;;;230      
;;;231      /* Check if data register contains valid random data */
;;;232      while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
;;;233      {
;;;234        if(HAL_GetTick() >= timeout)
;;;235        {    
;;;236          return HAL_TIMEOUT;
;;;237        } 
;;;238      }
;;;239      
;;;240      /* Get a 32bit Random number */ 
;;;241      random32bit = hrng->Instance->DR;
;;;242      
;;;243      /* Process Unlocked */
;;;244      __HAL_UNLOCK(hrng);
;;;245      
;;;246      /* Return the 32 bit random number */   
;;;247      return random32bit;
;;;248    }
00001a  bd70              POP      {r4-r6,pc}
                  |L3.28|
00001c  f7fffffe          BL       HAL_GetTick
000020  42a8              CMP      r0,r5                 ;234
000022  d301              BCC      |L3.40|
000024  2003              MOVS     r0,#3                 ;236
000026  bd70              POP      {r4-r6,pc}
                  |L3.40|
000028  6820              LDR      r0,[r4,#0]            ;232
00002a  6840              LDR      r0,[r0,#4]            ;232
00002c  43c0              MVNS     r0,r0                 ;232
00002e  07c0              LSLS     r0,r0,#31             ;232
000030  d1f4              BNE      |L3.28|
000032  6820              LDR      r0,[r4,#0]            ;241
000034  6880              LDR      r0,[r0,#8]            ;241
000036  2100              MOVS     r1,#0                 ;244
000038  7121              STRB     r1,[r4,#4]            ;244
00003a  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP


                          AREA ||i.HAL_RNG_GetRandomNumber_IT||, CODE, READONLY, ALIGN=1

                  HAL_RNG_GetRandomNumber_IT PROC
;;;254      */
;;;255    uint32_t HAL_RNG_GetRandomNumber_IT(RNG_HandleTypeDef *hrng)
000000  7901              LDRB     r1,[r0,#4]
;;;256    {
;;;257      uint32_t random32bit = 0;
;;;258      
;;;259      /* Process Locked */
;;;260      __HAL_LOCK(hrng);
000002  2901              CMP      r1,#1
000004  d00a              BEQ      |L4.28|
000006  2101              MOVS     r1,#1
000008  7101              STRB     r1,[r0,#4]
;;;261      
;;;262      /* Change RNG peripheral state */  
;;;263      hrng->State = HAL_RNG_STATE_BUSY;  
00000a  2102              MOVS     r1,#2
00000c  7141              STRB     r1,[r0,#5]
;;;264      
;;;265      /* Get a 32bit Random number */ 
;;;266      random32bit = hrng->Instance->DR;
00000e  6801              LDR      r1,[r0,#0]
000010  6888              LDR      r0,[r1,#8]
;;;267      
;;;268      /* Enable the RNG Interrupts: Data Ready, Clock error, Seed error */ 
;;;269      __HAL_RNG_ENABLE_IT(hrng); 
000012  680a              LDR      r2,[r1,#0]
000014  f0420208          ORR      r2,r2,#8
000018  600a              STR      r2,[r1,#0]
;;;270      
;;;271      /* Return the 32 bit random number */   
;;;272      return random32bit;
;;;273    }
00001a  4770              BX       lr
                  |L4.28|
00001c  2002              MOVS     r0,#2                 ;260
00001e  4770              BX       lr
;;;274    
                          ENDP


                          AREA ||i.HAL_RNG_GetState||, CODE, READONLY, ALIGN=1

                  HAL_RNG_GetState PROC
;;;390      */
;;;391    HAL_RNG_StateTypeDef HAL_RNG_GetState(RNG_HandleTypeDef *hrng)
000000  7940              LDRB     r0,[r0,#5]
;;;392    {
;;;393      return hrng->State;
;;;394    }
000002  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.HAL_RNG_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_RNG_IRQHandler PROC
;;;292      */
;;;293    void HAL_RNG_IRQHandler(RNG_HandleTypeDef *hrng)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
000002  4604              MOV      r4,r0
;;;295      /* RNG clock error interrupt occured */
;;;296      if(__HAL_RNG_GET_FLAG(hrng, RNG_IT_CEI) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6840              LDR      r0,[r0,#4]
;;;297      { 
;;;298        HAL_RNG_ErrorCallback(hrng);
;;;299        
;;;300        /* Clear the clock error flag */
;;;301        __HAL_RNG_CLEAR_FLAG(hrng, RNG_IT_CEI);
;;;302        
;;;303        /* Change RNG peripheral state */
;;;304        hrng->State = HAL_RNG_STATE_ERROR;
000008  f04f0604          MOV      r6,#4
00000c  43c0              MVNS     r0,r0                 ;296
00000e  0680              LSLS     r0,r0,#26             ;296
000010  f04f0500          MOV      r5,#0
000014  d409              BMI      |L6.42|
000016  4620              MOV      r0,r4                 ;298
000018  f7fffffe          BL       HAL_RNG_ErrorCallback
00001c  6820              LDR      r0,[r4,#0]            ;301
00001e  6841              LDR      r1,[r0,#4]            ;301
000020  f0210120          BIC      r1,r1,#0x20           ;301
000024  6041              STR      r1,[r0,#4]            ;301
000026  7166              STRB     r6,[r4,#5]
;;;305        
;;;306        /* Process Unlocked */
;;;307        __HAL_UNLOCK(hrng);
000028  7125              STRB     r5,[r4,#4]
                  |L6.42|
;;;308      }
;;;309      
;;;310      /* RNG seed error interrupt occured */
;;;311      if(__HAL_RNG_GET_FLAG(hrng, RNG_IT_SEI) != RESET)
00002a  6820              LDR      r0,[r4,#0]
00002c  6840              LDR      r0,[r0,#4]
00002e  43c0              MVNS     r0,r0
000030  0640              LSLS     r0,r0,#25
000032  d409              BMI      |L6.72|
;;;312      { 
;;;313        HAL_RNG_ErrorCallback(hrng);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_RNG_ErrorCallback
;;;314        
;;;315        /* Clear the seed error flag */
;;;316        __HAL_RNG_CLEAR_FLAG(hrng, RNG_IT_SEI);
00003a  6820              LDR      r0,[r4,#0]
00003c  6841              LDR      r1,[r0,#4]
00003e  f0210140          BIC      r1,r1,#0x40
000042  6041              STR      r1,[r0,#4]
;;;317        
;;;318        /* Change RNG peripheral state */
;;;319        hrng->State = HAL_RNG_STATE_ERROR;
000044  7166              STRB     r6,[r4,#5]
;;;320    
;;;321        /* Process Unlocked */
;;;322        __HAL_UNLOCK(hrng);    
000046  7125              STRB     r5,[r4,#4]
                  |L6.72|
;;;323      }
;;;324      
;;;325      /* Check RNG data ready flag */    
;;;326      if(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) != RESET)
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  43c0              MVNS     r0,r0
00004e  07c0              LSLS     r0,r0,#31
000050  d10a              BNE      |L6.104|
;;;327      {
;;;328        /* Data Ready callback */ 
;;;329        HAL_RNG_ReadyCallback(hrng);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_RNG_ReadyCallback
;;;330        
;;;331        /* Change RNG peripheral state */
;;;332        hrng->State = HAL_RNG_STATE_READY; 
000058  2001              MOVS     r0,#1
00005a  7160              STRB     r0,[r4,#5]
;;;333          
;;;334        /* Clear the RNG Data Ready flag */
;;;335        __HAL_RNG_CLEAR_FLAG(hrng, RNG_FLAG_DRDY);
00005c  6820              LDR      r0,[r4,#0]
00005e  6841              LDR      r1,[r0,#4]
000060  f0210101          BIC      r1,r1,#1
000064  6041              STR      r1,[r0,#4]
;;;336        
;;;337        /* Process Unlocked */
;;;338        __HAL_UNLOCK(hrng);
000066  7125              STRB     r5,[r4,#4]
                  |L6.104|
;;;339      }
;;;340    } 
000068  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP


                          AREA ||i.HAL_RNG_Init||, CODE, READONLY, ALIGN=1

                  HAL_RNG_Init PROC
;;;107      */
;;;108    HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
000000  b510              PUSH     {r4,lr}
;;;109    { 
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L7.12|
;;;110      /* Check the RNG handle allocation */
;;;111      if(hrng == NULL)
;;;112      {
;;;113        return HAL_ERROR;
;;;114      }
;;;115    
;;;116      if(hrng->State == HAL_RNG_STATE_RESET)
000006  7960              LDRB     r0,[r4,#5]
000008  b110              CBZ      r0,|L7.16|
00000a  e004              B        |L7.22|
                  |L7.12|
00000c  2001              MOVS     r0,#1                 ;113
;;;117      {  
;;;118        /* Init the low level hardware */
;;;119        HAL_RNG_MspInit(hrng);
;;;120      }
;;;121    
;;;122      /* Enable the RNG Peripheral */
;;;123      __HAL_RNG_ENABLE(hrng);
;;;124      
;;;125      /* Initialize the RNG state */
;;;126      hrng->State = HAL_RNG_STATE_READY;
;;;127      
;;;128      /* Return function status */
;;;129      return HAL_OK;
;;;130    }
00000e  bd10              POP      {r4,pc}
                  |L7.16|
000010  4620              MOV      r0,r4                 ;119
000012  f7fffffe          BL       HAL_RNG_MspInit
                  |L7.22|
000016  6820              LDR      r0,[r4,#0]            ;123
000018  6801              LDR      r1,[r0,#0]            ;123
00001a  f0410104          ORR      r1,r1,#4              ;123
00001e  6001              STR      r1,[r0,#0]            ;123
000020  2001              MOVS     r0,#1                 ;126
000022  7160              STRB     r0,[r4,#5]            ;126
000024  2000              MOVS     r0,#0                 ;129
000026  bd10              POP      {r4,pc}
;;;131    
                          ENDP


                          AREA ||i.HAL_RNG_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_RNG_MspDeInit PROC
;;;185      */
;;;186    __weak void HAL_RNG_MspDeInit(RNG_HandleTypeDef *hrng)
000000  4770              BX       lr
;;;187    {
;;;188      /* NOTE : This function Should not be modified, when the callback is needed,
;;;189                the HAL_RNG_MspDeInit could be implemented in the user file
;;;190       */
;;;191    }
;;;192    
                          ENDP


                          AREA ||i.HAL_RNG_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_RNG_MspInit PROC
;;;173      */
;;;174    __weak void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
000000  4770              BX       lr
;;;175    {
;;;176      /* NOTE : This function Should not be modified, when the callback is needed,
;;;177                the HAL_RNG_MspInit could be implemented in the user file
;;;178       */
;;;179    }
;;;180    
                          ENDP


                          AREA ||i.HAL_RNG_ReadyCallback||, CODE, READONLY, ALIGN=1

                  HAL_RNG_ReadyCallback PROC
;;;347    
;;;348    __weak void HAL_RNG_ReadyCallback(RNG_HandleTypeDef* hrng)
000000  4770              BX       lr
;;;349    {
;;;350      /* NOTE : This function Should not be modified, when the callback is needed,
;;;351                the HAL_RNG_ReadyCallback could be implemented in the user file
;;;352       */
;;;353    }
;;;354    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Drivers\\STM32F2xx_HAL_Driver\\Src\\stm32f2xx_hal_rng.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_rng_c_9f3aa4c0____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f2xx_hal_rng_c_9f3aa4c0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f2xx_hal_rng_c_9f3aa4c0____REVSH|
#line 144
|__asm___19_stm32f2xx_hal_rng_c_9f3aa4c0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
