; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o"bhd2 configuration\core.o" --asm_dir=.\list\ --list_dir=.\list\ --depend="bhd2 configuration\core.d" --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\..\Drivers\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Drivers\CMSIS\Include -I..\..\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Inc -I..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc -I..\..\Drivers\STM32F2xx_HAL_Driver\Inc -I..\..\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_HAL_DRIVER -DSTM32F215xx --omf_browse="bhd2 configuration\core.crf" ..\..\Src\core\core.c]
                          THUMB

                          AREA ||i.CORE_deviceMode||, CODE, READONLY, ALIGN=1

                  CORE_deviceMode PROC
;;;456    
;;;457    void CORE_deviceMode(void)
000000  b510              PUSH     {r4,lr}
;;;458    	{
;;;459    	CORE_threadHoltActiveChannels();
000002  f7fffffe          BL       CORE_threadHoltActiveChannels
;;;460    
;;;461    	#warning: "//CORE_threadGetData();"
;;;462    	CORE_threadGetData();
000006  f7fffffe          BL       CORE_threadGetData
;;;463    
;;;464    	CORE_threadClearNextBlock();
00000a  f7fffffe          BL       CORE_threadClearNextBlock
;;;465    	CORE_threadSaveToMemory();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      CORE_threadSaveToMemory
;;;466    	}
;;;467    
                          ENDP


                          AREA ||i.CORE_getErasingBlock||, CODE, READONLY, ALIGN=2

                  CORE_getErasingBlock PROC
;;;172    
;;;173    uint32_t CORE_getErasingBlock(void)
000000  4801              LDR      r0,|L2.8|
;;;174    	{
;;;175    	return mainMemoryErase.erasingBlock;
000002  6840              LDR      r0,[r0,#4]  ; mainMemoryErase
;;;176    	}
000004  4770              BX       lr
;;;177    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||+0x18

                          AREA ||i.CORE_holtIsChannelActive||, CODE, READONLY, ALIGN=2

                  CORE_holtIsChannelActive PROC
;;;218    */
;;;219    tdChannelState CORE_holtIsChannelActive(tdArinc *_pArinc, tdArincChannel *_pChannel, uint8_t _channelNumber)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220    	{
000004  4604              MOV      r4,r0
;;;221    	tdChannelState active = sameState;
;;;222    #if defined( BHD2_ACTIVE_CHANNEL_450S )
;;;223    	static uint8_t triggerOffCh1Prev = 0;
;;;224    	static uint8_t triggerOffCh2Prev = 0;
;;;225    	uint8_t triggerOffCh1;
;;;226    	uint8_t triggerOffCh2;
;;;227    	uint32_t msTick;
;;;228    #endif
;;;229    
;;;230    
;;;231    #if defined( BHD2_ACTIVE_CHANNEL_COUNTER_HANDLER )
;;;232    	active = notActiveState;
;;;233    
;;;234    #elif defined( BHD2_ACTIVE_CHANNEL_148FM )
;;;235    	/* It's our wision:) If they would insist on there algorithm you must to implemet it... */
;;;236    	if( _pChannel->data[ 0 ] & CORE_ACTIVE_CHANNEL_DEFAULT_TRIGGER )
;;;237    		{
;;;238    		active = activeState;
;;;239    		}
;;;240    	else
;;;241    		{
;;;242    		active = notActiveState;
;;;243    		}
;;;244    
;;;245    #elif defined( BHD2_ACTIVE_CHANNEL_450S )
;;;246    	if( BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_1, BHD2_A_C_450S_TRIGGER_ON_1_LABEL, BHD2_A_C_450S_TRIGGER_ON_1_BIT) == 1 ||
000006  6a40              LDR      r0,[r0,#0x24]
000008  2503              MOVS     r5,#3                 ;221
00000a  0481              LSLS     r1,r0,#18
00000c  d407              BMI      |L3.30|
;;;247    		  BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_1, BHD2_A_C_450S_TRIGGER_ON_2_LABEL, BHD2_A_C_450S_TRIGGER_ON_2_BIT) == 1 ||
00000e  0440              LSLS     r0,r0,#17
000010  d405              BMI      |L3.30|
;;;248    	    BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_2, BHD2_A_C_450S_TRIGGER_ON_1_LABEL, BHD2_A_C_450S_TRIGGER_ON_1_BIT) == 1 ||
000012  f8d40434          LDR      r0,[r4,#0x434]
000016  0481              LSLS     r1,r0,#18
000018  d401              BMI      |L3.30|
;;;249    		  BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_2, BHD2_A_C_450S_TRIGGER_ON_2_LABEL, BHD2_A_C_450S_TRIGGER_ON_2_BIT) == 1   )
00001a  0440              LSLS     r0,r0,#17
00001c  d500              BPL      |L3.32|
                  |L3.30|
;;;250    		{
;;;251    		active = activeState;
00001e  2501              MOVS     r5,#1
                  |L3.32|
;;;252    		}
;;;253    
;;;254    	triggerOffCh1 = BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_1, BHD2_A_C_450S_TRIGGER_OFF_1_LABEL, BHD2_A_C_450S_TRIGGER_OFF_1_BIT);
000020  8f20              LDRH     r0,[r4,#0x38]
000022  f3c03780          UBFX     r7,r0,#14,#1
;;;255    	triggerOffCh2 = BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_STATE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_2, BHD2_A_C_450S_TRIGGER_OFF_1_LABEL, BHD2_A_C_450S_TRIGGER_OFF_1_BIT);
000026  f8b40448          LDRH     r0,[r4,#0x448]
00002a  f3c03680          UBFX     r6,r0,#14,#1
;;;256    
;;;257    	msTick = HAL_GetTick();
00002e  f7fffffe          BL       HAL_GetTick
000032  4602              MOV      r2,r0
;;;258    
;;;259    	if( msTick < _pArinc->channel[ BHD2_A_C_450S_TRIGGER_CHANNEL_1 ].okTimeEnd )
000034  f8d4c404          LDR      r12,[r4,#0x404]
000038  2100              MOVS     r1,#0
;;;260    		{
;;;261    		if( triggerOffCh1Prev == 1 && triggerOffCh1 == 0 &&
00003a  4815              LDR      r0,|L3.144|
;;;262    				BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_VALUE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_1, BHD2_A_C_450S_TRIGGER_OFF_2_LABEL) <= BHD2_A_C_450S_TRIGGER_OFF_2_VALUE )
00003c  f2405333          MOV      r3,#0x533
000040  4594              CMP      r12,r2                ;259
000042  d90d              BLS      |L3.96|
000044  7802              LDRB     r2,[r0,#0]            ;261  ; triggerOffCh1Prev
000046  2a01              CMP      r2,#1                 ;261
000048  d11b              BNE      |L3.130|
00004a  b9df              CBNZ     r7,|L3.132|
00004c  f8d42394          LDR      r2,[r4,#0x394]
000050  f3c2324f          UBFX     r2,r2,#13,#16
000054  429a              CMP      r2,r3
000056  d816              BHI      |L3.134|
;;;263    			{
;;;264    			active = notActiveState;
;;;265    			triggerOffCh1Prev = 0;
000058  7001              STRB     r1,[r0,#0]
00005a  2500              MOVS     r5,#0                 ;264
;;;266    			triggerOffCh2Prev = 0;
00005c  7041              STRB     r1,[r0,#1]
00005e  e012              B        |L3.134|
                  |L3.96|
;;;267    			}
;;;268    		}
;;;269    	else if( msTick < _pArinc->channel[ BHD2_A_C_450S_TRIGGER_CHANNEL_2 ].okTimeEnd )
000060  f8d4c814          LDR      r12,[r4,#0x814]
000064  4594              CMP      r12,r2
000066  d90c              BLS      |L3.130|
;;;270    		{
;;;271    		if( triggerOffCh2Prev == 1 && triggerOffCh2 == 0 &&
000068  7842              LDRB     r2,[r0,#1]  ; triggerOffCh2Prev
00006a  2a01              CMP      r2,#1
00006c  d109              BNE      |L3.130|
00006e  b946              CBNZ     r6,|L3.130|
;;;272    				BHD2_ACTIVE_CHANNEL_450S_TRIGGER_SIGNAL_VALUE(_pArinc, BHD2_A_C_450S_TRIGGER_CHANNEL_2, BHD2_A_C_450S_TRIGGER_OFF_2_LABEL) <= BHD2_A_C_450S_TRIGGER_OFF_2_VALUE )
000070  f8d427a4          LDR      r2,[r4,#0x7a4]
000074  f3c2324f          UBFX     r2,r2,#13,#16
000078  429a              CMP      r2,r3
00007a  d802              BHI      |L3.130|
;;;273    			{
;;;274    			active = notActiveState;
;;;275    			triggerOffCh1Prev = 0;
00007c  7001              STRB     r1,[r0,#0]
00007e  2500              MOVS     r5,#0                 ;274
;;;276    			triggerOffCh2Prev = 0;
000080  7041              STRB     r1,[r0,#1]
                  |L3.130|
;;;277    			}
;;;278    		}
;;;279    
;;;280    	if( triggerOffCh1 )
000082  b107              CBZ      r7,|L3.134|
                  |L3.132|
;;;281    		triggerOffCh1Prev = triggerOffCh1;
000084  7007              STRB     r7,[r0,#0]
                  |L3.134|
;;;282    	if( triggerOffCh2 )
000086  b106              CBZ      r6,|L3.138|
;;;283    		triggerOffCh2Prev = triggerOffCh2;
000088  7046              STRB     r6,[r0,#1]
                  |L3.138|
;;;284    
;;;285    #else
;;;286    	active = activeState;
;;;287    
;;;288    #endif
;;;289    
;;;290    	return active;
00008a  4628              MOV      r0,r5
;;;291    	}
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;292    
                          ENDP

                  |L3.144|
                          DCD      ||.data||

                          AREA ||i.CORE_init||, CODE, READONLY, ALIGN=2

                  CORE_init PROC
;;;122    
;;;123    void CORE_init(void)
000000  b510              PUSH     {r4,lr}
;;;124    	{
;;;125    	tdUsbConectionStatus usbConectionStatus;
;;;126    
;;;127    #if !defined( USB_HARDWARE_FS ) && !defined( USB_HARDWARE_HS_VBUS_DETECT_BY_PIN )
;;;128    	ADC_CORE_init();
;;;129    #endif
;;;130    
;;;131    	FILE_SYSTEM_init(&FAT);
000002  4814              LDR      r0,|L4.84|
000004  f7fffffe          BL       FILE_SYSTEM_init
;;;132    
;;;133    	FILE_SYSTEM_readConfigurationTable(&configurationTable);
000008  4813              LDR      r0,|L4.88|
00000a  f7fffffe          BL       FILE_SYSTEM_readConfigurationTable
;;;134    
;;;135    	HOLT_CORE_init( &HOLT3598, &arinc );
00000e  4913              LDR      r1,|L4.92|
000010  4813              LDR      r0,|L4.96|
000012  f7fffffe          BL       HOLT_CORE_init
;;;136    
;;;137    	MX_USB_DEVICE_Init();
000016  f7fffffe          BL       MX_USB_DEVICE_Init
;;;138    
;;;139    	usbConectionStatus = isUsbConnected();
00001a  f7fffffe          BL       isUsbConnected
;;;140    
;;;141    	if( usbConectionStatus == usbConnect )
;;;142    		{
;;;143    		CORE_mode = CORE_usbMode;
00001e  4c11              LDR      r4,|L4.100|
000020  2801              CMP      r0,#1                 ;141
000022  d011              BEQ      |L4.72|
;;;144    		USB_CORE_init();
;;;145    		}
;;;146    	else
;;;147    		{
;;;148    		CORE_setSignalOk( 1 );
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       CORE_setSignalOk
;;;149    
;;;150    		CORE_mode = CORE_deviceMode;
00002a  480f              LDR      r0,|L4.104|
;;;151    
;;;152    		FILE_SYSTEM_newFile(&FAT);
00002c  6160              STR      r0,[r4,#0x14]  ; CORE_mode
00002e  4809              LDR      r0,|L4.84|
000030  f7fffffe          BL       FILE_SYSTEM_newFile
;;;153    
;;;154    		tdMemoryPage *pPage = &pagesQueue.page[ 0 ];
000034  480d              LDR      r0,|L4.108|
;;;155    		pPage->dataSize = 0;
000036  2100              MOVS     r1,#0
;;;156    		pPage->dataReady = 0;
000038  6001              STR      r1,[r0,#0]
00003a  7101              STRB     r1,[r0,#4]
;;;157    		pagesQueue.eye = 0;
00003c  480c              LDR      r0,|L4.112|
;;;158    		pagesQueue.pen = 0;
00003e  f8c013a0          STR      r1,[r0,#0x3a0]  ; pagesQueue
;;;159    		
;;;160    			#warning:
;;;161    //		TIM_CORE_initTim7();
;;;162    //		TIM_CORE_setCallback(&htim7, CORE_threadGetData);
;;;163    		}
000042  f8c013a4          STR      r1,[r0,#0x3a4]  ; pagesQueue
;;;164    
;;;165    	}
000046  bd10              POP      {r4,pc}
                  |L4.72|
000048  480a              LDR      r0,|L4.116|
00004a  6160              STR      r0,[r4,#0x14]         ;144  ; CORE_mode
00004c  e8bd4010          POP      {r4,lr}               ;144
000050  f7ffbffe          B.W      USB_CORE_init
;;;166    
                          ENDP

                  |L4.84|
                          DCD      ||.bss||+0x40c
                  |L4.88|
                          DCD      ||.bss||
                  |L4.92|
                          DCD      ||.bss||+0x47c0
                  |L4.96|
                          DCD      HOLT3598
                  |L4.100|
                          DCD      ||.data||
                  |L4.104|
                          DCD      CORE_deviceMode
                  |L4.108|
                          DCD      ||.bss||+0x14f8
                  |L4.112|
                          DCD      ||.bss||+0x4418
                  |L4.116|
                          DCD      CORE_usbMode

                          AREA ||i.CORE_initClearBadBlocks||, CODE, READONLY, ALIGN=2

                  CORE_initClearBadBlocks PROC
;;;195    
;;;196    void CORE_initClearBadBlocks(void)
000000  4802              LDR      r0,|L5.12|
;;;197    	{
;;;198    	clearBadBlocks.clear = 1;
000002  2101              MOVS     r1,#1
000004  7001              STRB     r1,[r0,#0]
;;;199    	clearBadBlocks.counter = 0;
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]  ; clearBadBlocks
;;;200    	}
00000a  4770              BX       lr
;;;201    
                          ENDP

                  |L5.12|
                          DCD      ||.data||+0x20

                          AREA ||i.CORE_initEraseMainMemory||, CODE, READONLY, ALIGN=2

                  CORE_initEraseMainMemory PROC
;;;166    
;;;167    void CORE_initEraseMainMemory(void)
000000  4802              LDR      r0,|L6.12|
;;;168    	{
;;;169    	mainMemoryErase.erase = 1;
000002  2101              MOVS     r1,#1
000004  7001              STRB     r1,[r0,#0]
;;;170    	mainMemoryErase.erasingBlock = 0;
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]  ; mainMemoryErase
;;;171    	}
00000a  4770              BX       lr
;;;172    
                          ENDP

                  |L6.12|
                          DCD      ||.data||+0x18

                          AREA ||i.CORE_isErasing||, CODE, READONLY, ALIGN=2

                  CORE_isErasing PROC
;;;177    
;;;178    uint32_t CORE_isErasing(void)
000000  4801              LDR      r0,|L7.8|
;;;179    	{
;;;180    	return mainMemoryErase.erase;
000002  7800              LDRB     r0,[r0,#0]  ; mainMemoryErase
;;;181    	}
000004  4770              BX       lr
;;;182    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||+0x18

                          AREA ||i.CORE_setSignalOk||, CODE, READONLY, ALIGN=2

                  CORE_setSignalOk PROC
;;;109    
;;;110    void CORE_setSignalOk(uint8_t _state)
000000  b108              CBZ      r0,|L8.6|
;;;111    	{
;;;112    	GPIO_PinState state;
;;;113    
;;;114    	state = _state ? GPIO_PIN_SET : GPIO_PIN_RESET;
000002  2201              MOVS     r2,#1
000004  e000              B        |L8.8|
                  |L8.6|
000006  2200              MOVS     r2,#0
                  |L8.8|
;;;115    
;;;116    #ifdef USB_HARDWARE_FS
;;;117    	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, state); // ISPR
;;;118    #else
;;;119    	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_13, state); // ISPR
000008  f44f5100          MOV      r1,#0x2000
00000c  4801              LDR      r0,|L8.20|
00000e  f7ffbffe          B.W      HAL_GPIO_WritePin
;;;120    #endif
;;;121    	}
;;;122    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40021400

                          AREA ||i.CORE_threadClearBadBlocks||, CODE, READONLY, ALIGN=2

                  CORE_threadClearBadBlocks PROC
;;;201    
;;;202    void CORE_threadClearBadBlocks(void)
000000  b510              PUSH     {r4,lr}
;;;203    	{
;;;204    	#define CORE_CLEAR_BLOCKS 16
;;;205    	FILE_SYSTEM_clearBadBlocksList_( clearBadBlocks.counter, CORE_CLEAR_BLOCKS );
000002  4c07              LDR      r4,|L9.32|
000004  2110              MOVS     r1,#0x10
000006  6860              LDR      r0,[r4,#4]  ; clearBadBlocks
000008  f7fffffe          BL       FILE_SYSTEM_clearBadBlocksList_
;;;206    
;;;207    	clearBadBlocks.counter += CORE_CLEAR_BLOCKS;
00000c  6860              LDR      r0,[r4,#4]  ; clearBadBlocks
00000e  3010              ADDS     r0,r0,#0x10
;;;208    	if( (clearBadBlocks.counter < FILE_SYSTEM_MEMORY_BAD_BLOCK_LIST_SIZE) == 0 )
000010  6060              STR      r0,[r4,#4]  ; clearBadBlocks
000012  f5b07f00          CMP      r0,#0x200
000016  d302              BCC      |L9.30|
;;;209    		{
;;;210    		clearBadBlocks.clear = 0;
000018  2000              MOVS     r0,#0
00001a  7020              STRB     r0,[r4,#0]
;;;211    		clearBadBlocks.counter = 0;
00001c  6060              STR      r0,[r4,#4]  ; clearBadBlocks
                  |L9.30|
;;;212    		}
;;;213    	#undef CORE_CLEAR_BLOCKS
;;;214    	}
00001e  bd10              POP      {r4,pc}
;;;215    
                          ENDP

                  |L9.32|
                          DCD      ||.data||+0x20

                          AREA ||i.CORE_threadClearNextBlock||, CODE, READONLY, ALIGN=2

                  CORE_threadClearNextBlock PROC
;;;417    
;;;418    void CORE_threadClearNextBlock(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;419    	{
;;;420    	static uint32_t prevBlock = FILE_SYSTEM_MEMORY_BLOCKS_AMOUNT + 1;
;;;421    	nand_addr_t address;
;;;422    
;;;423    	FILE_SYSTEM_generateNandAddress(&address, FAT.pFirstFile->addressEnd);
000002  4c10              LDR      r4,|L10.68|
000004  6860              LDR      r0,[r4,#4]  ; FAT
000006  6881              LDR      r1,[r0,#8]
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       FILE_SYSTEM_generateNandAddress
;;;424    
;;;425    	if( prevBlock != address.block )
00000e  4d0e              LDR      r5,|L10.72|
000010  9801              LDR      r0,[sp,#4]
000012  6929              LDR      r1,[r5,#0x10]  ; prevBlock
000014  4288              CMP      r0,r1
000016  d008              BEQ      |L10.42|
                  |L10.24|
;;;426    		{
;;;427    		FILE_SYSTEM_eraseBlock( address.block );
000018  f7fffffe          BL       FILE_SYSTEM_eraseBlock
;;;428    
;;;429    		while( FILE_SYSTEM_isBadBlock( address.block ) == 1 )
00001c  9801              LDR      r0,[sp,#4]
00001e  f7fffffe          BL       FILE_SYSTEM_isBadBlock
000022  2801              CMP      r0,#1
000024  d002              BEQ      |L10.44|
;;;430    			{
;;;431    			FILE_SYSTEM_getNextBlockAddress(&FAT.pFirstFile->addressEnd);
;;;432    
;;;433    			FILE_SYSTEM_generateNandAddress(&address, FAT.pFirstFile->addressEnd);
;;;434    
;;;435    			FILE_SYSTEM_eraseBlock( address.block );
;;;436    			}
;;;437    
;;;438    		prevBlock = address.block;
000026  9801              LDR      r0,[sp,#4]
000028  6128              STR      r0,[r5,#0x10]  ; prevBlock
                  |L10.42|
;;;439    		}
;;;440    	}
00002a  bd7f              POP      {r0-r6,pc}
                  |L10.44|
00002c  6860              LDR      r0,[r4,#4]            ;431  ; FAT
00002e  3008              ADDS     r0,r0,#8              ;431
000030  f7fffffe          BL       FILE_SYSTEM_getNextBlockAddress
000034  6860              LDR      r0,[r4,#4]            ;433  ; FAT
000036  6881              LDR      r1,[r0,#8]            ;433
000038  4668              MOV      r0,sp                 ;433
00003a  f7fffffe          BL       FILE_SYSTEM_generateNandAddress
00003e  9801              LDR      r0,[sp,#4]            ;435
000040  e7ea              B        |L10.24|
;;;441    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      ||.bss||+0x40c
                  |L10.72|
                          DCD      ||.data||

                          AREA ||i.CORE_threadEraseMainMemory||, CODE, READONLY, ALIGN=2

                  CORE_threadEraseMainMemory PROC
;;;182    
;;;183    void CORE_threadEraseMainMemory(void)
000000  b510              PUSH     {r4,lr}
;;;184    	{
;;;185    	FILE_SYSTEM_eraseBlock( mainMemoryErase.erasingBlock );
000002  4c0a              LDR      r4,|L11.44|
000004  6860              LDR      r0,[r4,#4]  ; mainMemoryErase
000006  f7fffffe          BL       FILE_SYSTEM_eraseBlock
;;;186    
;;;187    	mainMemoryErase.erasingBlock++;
00000a  6860              LDR      r0,[r4,#4]  ; mainMemoryErase
00000c  1c40              ADDS     r0,r0,#1
;;;188    	if( (mainMemoryErase.erasingBlock < FILE_SYSTEM_MEMORY_BLOCKS_AMOUNT ) == 0 )
00000e  6060              STR      r0,[r4,#4]  ; mainMemoryErase
000010  f5b05f80          CMP      r0,#0x1000
000014  d309              BCC      |L11.42|
;;;189    		{
;;;190    		mainMemoryErase.erase = 0;
000016  2000              MOVS     r0,#0
000018  7020              STRB     r0,[r4,#0]
;;;191    		FILE_SYSTEM_clearFatTable(&FAT);
00001a  4805              LDR      r0,|L11.48|
00001c  f7fffffe          BL       FILE_SYSTEM_clearFatTable
;;;192    		FILE_SYSTEM_createFatTable(&FAT);
000020  e8bd4010          POP      {r4,lr}
000024  4802              LDR      r0,|L11.48|
000026  f7ffbffe          B.W      FILE_SYSTEM_createFatTable
                  |L11.42|
;;;193    		}
;;;194    	}
00002a  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  |L11.44|
                          DCD      ||.data||+0x18
                  |L11.48|
                          DCD      ||.bss||+0x40c

                          AREA ||i.CORE_threadGetData||, CODE, READONLY, ALIGN=2

                  CORE_threadGetData PROC
;;;376    
;;;377    void CORE_threadGetData(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;378    	{
;;;379    	uint32_t time;
;;;380    	static uint32_t prevDataSize = 0;
;;;381    	static uint32_t crc32 = 0;
;;;382    
;;;383    	tdMemoryPage *pPage = &pagesQueue.page[ pagesQueue.pen % CORE_PAGES_QUEUE_SIZE ];
000004  4f36              LDR      r7,|L12.224|
000006  f240211d          MOV      r1,#0x21d
00000a  f89703a4          LDRB     r0,[r7,#0x3a4]  ; pagesQueue
00000e  f0000003          AND      r0,r0,#3
000012  4348              MULS     r0,r1,r0
000014  f5a74180          SUB      r1,r7,#0x4000
000018  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;384    
;;;385    	time = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
;;;386    
;;;387    	if( pPage->dataSize < CORE_PAGES_QUEUE_DATA_MAX_SIZE )
000020  f5065480          ADD      r4,r6,#0x1000
000024  f64079ff          MOV      r9,#0xfff
000028  f8d410e0          LDR      r1,[r4,#0xe0]
00002c  4605              MOV      r5,r0                 ;385
00002e  4549              CMP      r1,r9
000030  d209              BCS      |L12.70|
;;;388    		{
;;;389    		HOLT_CORE_ReedAvailableData(&HOLT3598, &arinc, pPage->data, &pPage->dataSize, CORE_PAGES_QUEUE_DATA_MAX_SIZE);
000032  f5065387          ADD      r3,r6,#0x10e0
000036  4632              MOV      r2,r6
000038  f507716a          ADD      r1,r7,#0x3a8
00003c  4829              LDR      r0,|L12.228|
00003e  f8cd9000          STR      r9,[sp,#0]
000042  f7fffffe          BL       HOLT_CORE_ReedAvailableData
                  |L12.70|
;;;390    		}
;;;391    
;;;392    	if( prevDataSize == 0 && pPage->dataSize != 0 )
000046  f8df80a0          LDR      r8,|L12.232|
00004a  f8d80008          LDR      r0,[r8,#8]  ; prevDataSize
00004e  b980              CBNZ     r0,|L12.114|
000050  f8d410e0          LDR      r1,[r4,#0xe0]
000054  b1d1              CBZ      r1,|L12.140|
;;;393    		{
;;;394    		MWN_M_setValue8ToBuffer( ARINC429, pPage->spare, FILE_SYSTEM_DATA_SPARE_DATA_TYPE_POSITION);
000056  2010              MOVS     r0,#0x10
000058  7020              STRB     r0,[r4,#0]
;;;395    		MWN_M_setValue32ToBuffer( time, pPage->spare, FILE_SYSTEM_DATA_SPARE_TIME_BEGIN_POSITION);
00005a  0e28              LSRS     r0,r5,#24
00005c  7420              STRB     r0,[r4,#0x10]
00005e  0c28              LSRS     r0,r5,#16
000060  73e0              STRB     r0,[r4,#0xf]
000062  0a28              LSRS     r0,r5,#8
000064  73a0              STRB     r0,[r4,#0xe]
000066  7365              STRB     r5,[r4,#0xd]
;;;396    		crc32 = CRC32_(pPage->data,  pPage->dataSize);
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       CRC32_
00006e  f8c8000c          STR      r0,[r8,#0xc]  ; crc32
                  |L12.114|
;;;397    		}
;;;398    
;;;399    	if( prevDataSize != pPage->dataSize )
000072  f8d410e0          LDR      r1,[r4,#0xe0]
000076  f8d80008          LDR      r0,[r8,#8]  ; prevDataSize
00007a  4281              CMP      r1,r0
00007c  d006              BEQ      |L12.140|
;;;400    		{
;;;401    		crc32 = CRC32(pPage->data + prevDataSize,  pPage->dataSize, crc32);
00007e  4430              ADD      r0,r0,r6
000080  f8d8200c          LDR      r2,[r8,#0xc]  ; crc32
000084  f7fffffe          BL       CRC32
000088  f8c8000c          STR      r0,[r8,#0xc]  ; crc32
                  |L12.140|
;;;402    		}
;;;403    
;;;404    	prevDataSize = pPage->dataSize;
00008c  f8d400e0          LDR      r0,[r4,#0xe0]
000090  4641              MOV      r1,r8
;;;405    
;;;406    	if( ((pPage->dataSize < CORE_PAGES_QUEUE_DATA_MAX_SIZE) == 0) || (pPage->dataSize != 0 && arinc.activeChannelsAmount == 0) )
000092  f8c80008          STR      r0,[r8,#8]  ; prevDataSize
000096  4548              CMP      r0,r9
000098  d205              BCS      |L12.166|
00009a  2800              CMP      r0,#0
00009c  d01d              BEQ      |L12.218|
00009e  4813              LDR      r0,|L12.236|
0000a0  6800              LDR      r0,[r0,#0]  ; arinc
0000a2  2800              CMP      r0,#0
0000a4  d119              BNE      |L12.218|
                  |L12.166|
;;;407    		{
;;;408    		MWN_M_setValue32ToBuffer( time, pPage->spare, FILE_SYSTEM_DATA_SPARE_TIME_END_POSITION);
0000a6  0e28              LSRS     r0,r5,#24
0000a8  7520              STRB     r0,[r4,#0x14]
0000aa  0c28              LSRS     r0,r5,#16
0000ac  74e0              STRB     r0,[r4,#0x13]
0000ae  0a28              LSRS     r0,r5,#8
0000b0  74a0              STRB     r0,[r4,#0x12]
0000b2  7465              STRB     r5,[r4,#0x11]
;;;409    		MWN_M_setValue32ToBuffer( crc32, pPage->spare, FILE_SYSTEM_DATA_SPARE_CRC32_POSITION);
0000b4  68c8              LDR      r0,[r1,#0xc]  ; crc32
0000b6  0e02              LSRS     r2,r0,#24
0000b8  7622              STRB     r2,[r4,#0x18]
0000ba  0c02              LSRS     r2,r0,#16
0000bc  75e2              STRB     r2,[r4,#0x17]
0000be  0a02              LSRS     r2,r0,#8
0000c0  75a2              STRB     r2,[r4,#0x16]
0000c2  7560              STRB     r0,[r4,#0x15]
;;;410    
;;;411    		pPage->dataReady = 1;
0000c4  2001              MOVS     r0,#1
0000c6  f88400e4          STRB     r0,[r4,#0xe4]
;;;412    		pagesQueue.pen++;
0000ca  f8d703a4          LDR      r0,[r7,#0x3a4]  ; pagesQueue
0000ce  1c40              ADDS     r0,r0,#1
;;;413    
;;;414    		prevDataSize = 0;
0000d0  f8c703a4          STR      r0,[r7,#0x3a4]  ; pagesQueue
0000d4  2000              MOVS     r0,#0
0000d6  f8c80008          STR      r0,[r8,#8]  ; prevDataSize
                  |L12.218|
;;;415    		}
;;;416    	}
0000da  e8bd83f8          POP      {r3-r9,pc}
;;;417    
                          ENDP

0000de  0000              DCW      0x0000
                  |L12.224|
                          DCD      ||.bss||+0x4418
                  |L12.228|
                          DCD      HOLT3598
                  |L12.232|
                          DCD      ||.data||
                  |L12.236|
                          DCD      ||.bss||+0x47c0

                          AREA ||i.CORE_threadHoltActiveChannels||, CODE, READONLY, ALIGN=2

                  CORE_threadHoltActiveChannels PROC
;;;292    
;;;293    void CORE_threadHoltActiveChannels(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;294    	{
;;;295    	tdArincChannel *pChannel;
;;;296    	tdArincChannel *pChannelEnd;
;;;297    	uint32_t time;
;;;298    	tdChannelState channelState;
;;;299    	uint8_t channel;
;;;300    	#if defined( BHD2_SYNCHRONIZE_ARINC_ACTIVE_CHANNELS )
;;;301    	uint32_t active = 0;
000004  f04f0900          MOV      r9,#0
;;;302    	uint32_t notActive = 0;
000008  46c8              MOV      r8,r9
;;;303    	#endif
;;;304    	static uint32_t prevTime = 0;
;;;305    
;;;306    	time = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
;;;307    
;;;308    	if( time - prevTime < 100 ) /* cheking active channels each 100 ms */
00000e  492a              LDR      r1,|L13.184|
000010  4604              MOV      r4,r0                 ;306
000012  684a              LDR      r2,[r1,#4]  ; prevTime
000014  1a80              SUBS     r0,r0,r2
000016  2864              CMP      r0,#0x64
000018  d34c              BCC      |L13.180|
;;;309    		return;
;;;310    	prevTime = time;
;;;311    
;;;312    	channel = 0;
;;;313    
;;;314    	pChannel = &arinc.channel[ 0 ];
00001a  f8dfa0a0          LDR      r10,|L13.188|
00001e  2700              MOVS     r7,#0                 ;312
000020  f10a0504          ADD      r5,r10,#4
;;;315    	pChannelEnd = &arinc.channel[ 0 ] + sizeof(arinc.channel) / sizeof(arinc.channel[ 0 ]);
000024  f5055602          ADD      r6,r5,#0x2080
000028  604c              STR      r4,[r1,#4]  ; prevTime
                  |L13.42|
;;;316    	do
;;;317    		{
;;;318    		channelState = CORE_holtIsChannelActive( &arinc, pChannel, channel++ );
00002a  463a              MOV      r2,r7
00002c  1c7f              ADDS     r7,r7,#1
00002e  b2ff              UXTB     r7,r7
000030  4629              MOV      r1,r5
000032  4822              LDR      r0,|L13.188|
000034  f7fffffe          BL       CORE_holtIsChannelActive
;;;319    
;;;320    		if( pChannel->status.enable == 0 )
000038  f8951408          LDRB     r1,[r5,#0x408]
00003c  b159              CBZ      r1,|L13.86|
;;;321    				continue;
;;;322    
;;;323    		if( channelState != sameState )
00003e  2803              CMP      r0,#3
000040  d001              BEQ      |L13.70|
;;;324    			{
;;;325    			pChannel->status.state = channelState;
000042  f885040a          STRB     r0,[r5,#0x40a]
                  |L13.70|
;;;326    			}
;;;327    
;;;328    		#if defined( BHD2_SYNCHRONIZE_ARINC_ACTIVE_CHANNELS )
;;;329    		if( pChannel->status.state != notActiveState )
000046  f895040a          LDRB     r0,[r5,#0x40a]
00004a  b110              CBZ      r0,|L13.82|
;;;330    			{
;;;331    			active++;
00004c  f1090901          ADD      r9,r9,#1
000050  e001              B        |L13.86|
                  |L13.82|
;;;332    			}
;;;333    		else
;;;334    			{
;;;335    			notActive++;
000052  f1080801          ADD      r8,r8,#1
                  |L13.86|
000056  f5056582          ADD      r5,r5,#0x410
;;;336    			}
;;;337    		#else
;;;338    		if( pChannel->status.state != notActiveState )
;;;339    			{
;;;340    			pChannel->status.activeTimeEnd = time + BHD2_ARINC_CHANNEL_ACTIVE_TIMEOUT_MS;
;;;341    			}
;;;342    		#endif
;;;343    
;;;344    		}	while( ++pChannel < pChannelEnd );
00005a  42b5              CMP      r5,r6
00005c  d3e5              BCC      |L13.42|
;;;345    
;;;346    	#if defined( BHD2_SYNCHRONIZE_ARINC_ACTIVE_CHANNELS )
;;;347    	if( active != 0 && notActive == 0 )
00005e  f1b90f00          CMP      r9,#0
000062  d010              BEQ      |L13.134|
000064  f1b80f00          CMP      r8,#0
000068  d10d              BNE      |L13.134|
;;;348    		{
;;;349    		pChannel = &arinc.channel[ 0 ];
00006a  f10a0004          ADD      r0,r10,#4
;;;350    		do
;;;351    			{
;;;352    			if( pChannel->status.enable == 0 )
;;;353    				continue;
;;;354    
;;;355    			pChannel->status.activeTimeEnd = time + BHD2_ARINC_CHANNEL_ACTIVE_TIMEOUT_MS;
00006e  f60431b8          ADD      r1,r4,#0xbb8
000072  bf00              NOP                            ;352
                  |L13.116|
000074  f8902408          LDRB     r2,[r0,#0x408]        ;352
000078  b10a              CBZ      r2,|L13.126|
00007a  f8c01404          STR      r1,[r0,#0x404]
                  |L13.126|
00007e  f5006082          ADD      r0,r0,#0x410
;;;356    			}	while( ++pChannel < pChannelEnd );
000082  42b0              CMP      r0,r6
000084  d3f6              BCC      |L13.116|
                  |L13.134|
;;;357    		}
;;;358    	#endif
;;;359    
;;;360    	active = 0;
000086  2200              MOVS     r2,#0
;;;361    	pChannel = &arinc.channel[ 0 ];
000088  f10a0104          ADD      r1,r10,#4
                  |L13.140|
;;;362    	do
;;;363    		{
;;;364    		if( pChannel->status.enable == 0 )
00008c  f8913408          LDRB     r3,[r1,#0x408]
000090  b153              CBZ      r3,|L13.168|
;;;365    			continue;
;;;366    
;;;367    		pChannel->status.active = ( time < pChannel->status.activeTimeEnd ) ? 1 : 0;
000092  f8d13404          LDR      r3,[r1,#0x404]
000096  42a3              CMP      r3,r4
000098  d901              BLS      |L13.158|
00009a  2301              MOVS     r3,#1
00009c  e000              B        |L13.160|
                  |L13.158|
00009e  2300              MOVS     r3,#0
                  |L13.160|
0000a0  f8813409          STRB     r3,[r1,#0x409]
;;;368    		
;;;369    		if( pChannel->status.active )
0000a4  b103              CBZ      r3,|L13.168|
0000a6  1c52              ADDS     r2,r2,#1
                  |L13.168|
0000a8  f5016182          ADD      r1,r1,#0x410
;;;370    			active++;
;;;371    
;;;372    		}	while( ++pChannel < pChannelEnd );
0000ac  42b1              CMP      r1,r6
0000ae  d3ed              BCC      |L13.140|
;;;373    	
;;;374    	arinc.activeChannelsAmount = active;
0000b0  f8ca2000          STR      r2,[r10,#0]  ; arinc
                  |L13.180|
;;;375    	}
0000b4  e8bd87f0          POP      {r4-r10,pc}
;;;376    
                          ENDP

                  |L13.184|
                          DCD      ||.data||
                  |L13.188|
                          DCD      ||.bss||+0x47c0

                          AREA ||i.CORE_threadMain||, CODE, READONLY, ALIGN=2

                  CORE_threadMain PROC
;;;483    
;;;484    void CORE_threadMain(void)
000000  4801              LDR      r0,|L14.8|
;;;485    	{
;;;486    	CORE_mode();
000002  6940              LDR      r0,[r0,#0x14]  ; CORE_mode
000004  4700              BX       r0
;;;487    	}
;;;488    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.CORE_threadSaveToMemory||, CODE, READONLY, ALIGN=2

                  CORE_threadSaveToMemory PROC
;;;441    
;;;442    void CORE_threadSaveToMemory(void)
000000  b538              PUSH     {r3-r5,lr}
;;;443    	{
;;;444    	tdMemoryPage *pPage = &pagesQueue.page[ pagesQueue.eye % CORE_PAGES_QUEUE_SIZE ];
000002  4d13              LDR      r5,|L15.80|
000004  f240211d          MOV      r1,#0x21d
000008  f89503a0          LDRB     r0,[r5,#0x3a0]  ; pagesQueue
00000c  f0000003          AND      r0,r0,#3
000010  4348              MULS     r0,r1,r0
000012  f5a54180          SUB      r1,r5,#0x4000
000016  eb0101c0          ADD      r1,r1,r0,LSL #3
;;;445    
;;;446    	if( pPage->dataReady )
00001a  f5015480          ADD      r4,r1,#0x1000
00001e  f89400e4          LDRB     r0,[r4,#0xe4]
000022  2800              CMP      r0,#0                 ;443
000024  d012              BEQ      |L15.76|
;;;447    		{
;;;448    		FILE_SYSTEM_writeDataToFile(FAT.pFirstFile, pPage->data, FILE_SYSTEM_MEMORY_PAGE_DATA_SIZE, pPage->spare, FILE_SYSTEM_MEMORY_SPARE_DATA_SIZE);
000026  20e0              MOVS     r0,#0xe0
000028  9000              STR      r0,[sp,#0]
00002a  480a              LDR      r0,|L15.84|
00002c  4623              MOV      r3,r4
00002e  f44f5280          MOV      r2,#0x1000
000032  6840              LDR      r0,[r0,#4]  ; FAT
000034  f7fffffe          BL       FILE_SYSTEM_writeDataToFile
;;;449    
;;;450    		pPage->dataReady = 0;
000038  2000              MOVS     r0,#0
00003a  f88400e4          STRB     r0,[r4,#0xe4]
;;;451    		pPage->dataSize = 0;
;;;452    
;;;453    		pagesQueue.eye++;
00003e  f8c400e0          STR      r0,[r4,#0xe0]
000042  f8d503a0          LDR      r0,[r5,#0x3a0]  ; pagesQueue
000046  1c40              ADDS     r0,r0,#1
000048  f8c503a0          STR      r0,[r5,#0x3a0]  ; pagesQueue
                  |L15.76|
;;;454    		}
;;;455    	}
00004c  bd38              POP      {r3-r5,pc}
;;;456    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      ||.bss||+0x4418
                  |L15.84|
                          DCD      ||.bss||+0x40c

                          AREA ||i.CORE_usbMode||, CODE, READONLY, ALIGN=2

                  CORE_usbMode PROC
;;;467    
;;;468    void CORE_usbMode(void)
000000  b510              PUSH     {r4,lr}
;;;469    	{
;;;470    	if( mainMemoryErase.erase == 1 && clearBadBlocks.clear == 0 )
000002  480c              LDR      r0,|L16.52|
000004  4c0b              LDR      r4,|L16.52|
000006  7800              LDRB     r0,[r0,#0]  ; mainMemoryErase
000008  3408              ADDS     r4,r4,#8
00000a  2801              CMP      r0,#1
00000c  d109              BNE      |L16.34|
00000e  7820              LDRB     r0,[r4,#0]  ; clearBadBlocks
000010  b938              CBNZ     r0,|L16.34|
;;;471    		{
;;;472    		HAL_NVIC_DisableIRQ(OTG_HS_IRQn);
000012  204d              MOVS     r0,#0x4d
000014  f7fffffe          BL       HAL_NVIC_DisableIRQ
;;;473    
;;;474    		CORE_threadEraseMainMemory();
000018  f7fffffe          BL       CORE_threadEraseMainMemory
;;;475    
;;;476    		HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
00001c  204d              MOVS     r0,#0x4d
00001e  f7fffffe          BL       HAL_NVIC_EnableIRQ
                  |L16.34|
;;;477    		}
;;;478    	if( clearBadBlocks.clear == 1 )
000022  7820              LDRB     r0,[r4,#0]  ; clearBadBlocks
000024  2801              CMP      r0,#1
000026  d103              BNE      |L16.48|
;;;479    		{
;;;480    		CORE_threadClearBadBlocks();
000028  e8bd4010          POP      {r4,lr}
00002c  f7ffbffe          B.W      CORE_threadClearBadBlocks
                  |L16.48|
;;;481    		}
;;;482    	}
000030  bd10              POP      {r4,pc}
;;;483    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      ||.data||+0x18

                          AREA ||i.isUsbConnected||, CODE, READONLY, ALIGN=2

                  isUsbConnected PROC
;;;42     	#if defined( USB_HARDWARE_HS_VBUS_DETECT_BY_PIN )
;;;43     	tdUsbConectionStatus isUsbConnected(void)
000000  b570              PUSH     {r4-r6,lr}
;;;44     		{
;;;45     		uint16_t vBus = 0;
000002  2400              MOVS     r4,#0
;;;46     		uint16_t vBusChecks = 0xFF;
000004  25ff              MOVS     r5,#0xff
;;;47     
;;;48     		while( vBusChecks-- )
;;;49     			{
;;;50     			if( HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) )
000006  4e09              LDR      r6,|L17.44|
000008  e006              B        |L17.24|
                  |L17.10|
00000a  2101              MOVS     r1,#1
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       HAL_GPIO_ReadPin
000012  b108              CBZ      r0,|L17.24|
000014  1c64              ADDS     r4,r4,#1
;;;51     				{
;;;52     				vBus++;
000016  b2a4              UXTH     r4,r4
                  |L17.24|
000018  1e6d              SUBS     r5,r5,#1              ;48
00001a  b2ad              UXTH     r5,r5                 ;48
00001c  d2f5              BCS      |L17.10|
;;;53     				}
;;;54     			}
;;;55     
;;;56     		return ( vBus > 0xFF / 2 ) ? usbNotConnect : usbConnect;
00001e  2c7f              CMP      r4,#0x7f
000020  d801              BHI      |L17.38|
000022  2001              MOVS     r0,#1
;;;57     		}
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  2000              MOVS     r0,#0                 ;56
000028  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

00002a  0000              DCW      0x0000
                  |L17.44|
                          DCD      0x40020000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  configurationTable
                          %        1036
                  ||FAT||
                          %        12
                  pagesQueue
                          %        17320
                  arinc
                          %        8584

                          AREA ||.data||, DATA, ALIGN=2

                  triggerOffCh1Prev
000000  00                DCB      0x00
                  triggerOffCh2Prev
000001  000000            DCB      0x00,0x00,0x00
                  prevTime
                          DCD      0x00000000
                  prevDataSize
                          DCD      0x00000000
                  crc32
                          DCD      0x00000000
                  prevBlock
                          DCD      0x00001001
                  CORE_mode
                          DCD      0x00000000
                  mainMemoryErase
                          %        8
                  clearBadBlocks
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\Src\\core\\core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_core_c_9c4b5aff____REV16|
#line 129 "..\\..\\Drivers\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_core_c_9c4b5aff____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_core_c_9c4b5aff____REVSH|
#line 144
|__asm___6_core_c_9c4b5aff____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
